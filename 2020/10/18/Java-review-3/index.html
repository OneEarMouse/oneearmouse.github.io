<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"codesh.xyz","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Java复健系列(3)：复习Java继承、多态、接口的相关知识。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java复健系列(3)：Java的面向对象">
<meta property="og:url" content="http://codesh.xyz/2020/10/18/Java-review-3/index.html">
<meta property="og:site_name" content="OneEarMouse&#39;s Page">
<meta property="og:description" content="Java复健系列(3)：复习Java继承、多态、接口的相关知识。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-10-18T07:15:36.000Z">
<meta property="article:modified_time" content="2023-10-07T06:39:59.502Z">
<meta property="article:author" content="OneEarMouse">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://codesh.xyz/2020/10/18/Java-review-3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java复健系列(3)：Java的面向对象 | OneEarMouse's Page</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">OneEarMouse's Page</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">程序员一只耳</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://codesh.xyz/2020/10/18/Java-review-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="OneEarMouse">
      <meta itemprop="description" content="程序员一只耳的个人编程问题记录存档，仅供参考">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OneEarMouse's Page">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java复健系列(3)：Java的面向对象
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-18 15:15:36" itemprop="dateCreated datePublished" datetime="2020-10-18T15:15:36+08:00">2020-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-07 14:39:59" itemprop="dateModified" datetime="2023-10-07T14:39:59+08:00">2023-10-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>
            <div class="post-description">Java复健系列(3)：复习Java继承、多态、接口的相关知识。</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="面向对象三大特征">1. 面向对象三大特征</h1><h2 id="封装">1.1. 封装</h2><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。</p>
<h2 id="继承">1.2. 继承</h2><p>不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<ul>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
</ul>
<h2 id="多态">1.3. 多态</h2><p>多态，顾名思义，表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例。</p>
<ul>
<li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li>
<li>对象类型不可变，引用类型可变；</li>
<li>方法具有多态性，属性不具有多态性；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
<h1 id="继承-1">2. 继承</h1><h2 id="继承-2">2.1. 继承</h2><p>关键字 extend</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class People&#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    int height;</span><br><span class="line">   </span><br><span class="line">    void say()&#123;</span><br><span class="line">        System.out.println(&quot;我的名字是 &quot; + name + &quot;，年龄是 &quot; + age + &quot;，身高是 &quot; + height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Teacher extends People&#123;</span><br><span class="line">    String school;  &#x2F;&#x2F; 所在学校</span><br><span class="line">    String subject;  &#x2F;&#x2F; 学科</span><br><span class="line">    int seniority;  &#x2F;&#x2F; 教龄</span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F; 覆盖 People 类中的 say() 方法</span><br><span class="line">    void say()&#123;</span><br><span class="line">        System.out.println(&quot;我叫&quot; + name + &quot;，在&quot; + school + &quot;教&quot; + subject + &quot;，有&quot; + seniority + &quot;年教龄&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    void lecturing()&#123;</span><br><span class="line">        System.out.println(&quot;我已经&quot; + age + &quot;岁了，依然站在讲台上讲课&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>子类可以覆盖父类的方法。</li>
<li>子类可以继承父类除private以为的所有的成员。</li>
<li>构造方法不能被继承。</li>
</ul>
<p>单继承性：Java 允许一个类仅能继承一个其它类，即一个类只能有一个父类，这个限制被称做单继承性。后面将会学到接口(interface)的概念，接口允许多继承。</p>
<h2 id="super-关键字">2.2. super 关键字</h2><p>super 用来表示父类。super 可以用在子类中，通过点号(.)来获取父类的成员变量和方法。super 也可以用在子类的子类中，Java 能自动向上层类追溯。父类行为被调用，就好象该行为是本类的行为一样，而且调用行为不必发生在父类中，它能自动向上层类追溯。<br>super 关键字的功能：</p>
<ul>
<li>调用父类中声明为 private 的变量。</li>
<li>点取已经覆盖了的方法。</li>
<li>作为方法名表示父类构造方法。</li>
</ul>
<p>Java 具有追溯性，会一直向上找，直到找到该方法为止。通过 super 调用父类的private隐藏变量，必须要在父类中声明 getter 方法，因为声明为 private 的数据成员对子类是不可见的。</p>
<p>最后注意 super 与 this 的区别：super 不是一个对象的引用，不能将 super 赋值给另一个对象变量，它只是一个指示编译器调用父类方法的特殊关键字。</p>
<h3 id="调用父类方法">2.2.1. 调用父类方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Animal&#123;</span><br><span class="line">    String name;</span><br><span class="line">    public Animal(String name)&#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line">    int age;</span><br><span class="line">    public Dog(String name, int age)&#123;</span><br><span class="line">        super(name);</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在构造方法中调用另一个构造方法，调用动作必须置于最起始的位置。</li>
<li>不能在构造方法以外的任何方法内调用构造方法。</li>
<li>在一个构造方法内只能调用一个构造方法。</li>
</ul>
<p>如果编写一个构造方法，既没有调用 super() 也没有调用 this()，编译器会自动插入一个调用到父类构造方法中，而且不带参数。</p>
<h2 id="重写和重载">2.3. 重写和重载</h2><h3 id="重写（Override）">2.3.1. 重写（Override）</h3><p>在类继承中，子类可以修改从父类继承来的方法，也就是说子类能创建一个与父类方法有不同功能的方法，但具有相同的名称、返回值类型、参数列表。如果在新类中定义一个方法，其名称、返回值类型和参数列表正好与父类中的相同，那么，新方法被称做重写旧方法。参数列表又叫参数签名，包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同。被覆盖的方法在子类中只能通过super调用。</p>
<p>注意：重写不会删除父类中的方法，而是对子类的实例隐藏，暂时不使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">    String name;</span><br><span class="line">    public Animal(String name)&#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public void say()&#123;</span><br><span class="line">        System.out.println(&quot;我是一只小动物，我的名字叫&quot; + name + &quot;，我会发出叫声&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line">    &#x2F;&#x2F; 构造方法不能被继承，通过super()调用</span><br><span class="line">    public Dog(String name)&#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 覆盖say() 方法</span><br><span class="line">    public void say()&#123;</span><br><span class="line">        System.out.println(&quot;我是一只小狗，我的名字叫&quot; + name + &quot;，我会发出汪的叫声&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原则：</p>
<ul>
<li>覆盖方法的返回类型、方法名称、参数列表必须与原方法的相同。</li>
<li>覆盖方法不能比原方法访问性差（即访问权限不允许缩小）。</li>
<li>覆盖方法不能比原方法抛出更多的异常。</li>
<li>被覆盖的方法不能是final类型，因为final修饰的方法是无法覆盖的。</li>
<li>被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。</li>
<li>被覆盖的方法不能为static。如果父类中的方法为静态的，而子类中的方法不是静态的，但是两个方法除了这一点外其他都满足覆盖条件，那么会发生编译错误；反之亦然。即使父类和子类中的方法都是静态的，并且满足覆盖条件，但是仍然不会发生覆盖，因为静态方法是在编译的时候把静态方法和类的引用类型进行匹配。</li>
</ul>
<h3 id="重载Overload">2.3.2. 重载Overload</h3><p>前面已经对Java方法重载进行了说明，这里再强调一下，Java父类和子类中的方法都会参与重载，例如，父类中有一个方法是 func(){ … }，子类中有一个方法是 func(int i){ … }，就构成了方法的重载。</p>
<p>覆盖和重载的不同：</p>
<p>方法覆盖要求参数列表必须一致，而方法重载要求参数列表必须不一致。<br>方法覆盖要求返回类型必须一致，方法重载对此没有要求。<br>方法覆盖只能用于子类覆盖父类的方法，方法重载用于同一个类中的所有方法（包括从父类中继承而来的方法）。<br>方法覆盖对方法的访问权限和抛出的异常有特殊的要求，而方法重载在这方面没有任何限制。<br>父类的一个方法只能被子类覆盖一次，而一个方法可以在所有的类中可以被重载多次</p>
<h2 id="重写与重载之间的区别">2.4. 重写与重载之间的区别</h2><table>
<thead>
<tr>
<th>区别点</th>
<th>重载方法</th>
<th>重写方法</th>
</tr>
</thead>
<tbody><tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可以修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>异常</td>
<td>可以修改</td>
<td>可以减少或删除，一定不能抛出新的或者更广的异常</td>
</tr>
<tr>
<td>访问</td>
<td>可以修改</td>
<td>一定不能做更严格的限制（可以降低限制）</td>
</tr>
</tbody></table>
<h1 id="多态-1">3. 多态</h1><p>必要条件</p>
<ul>
<li>继承</li>
<li>重写</li>
<li>父类引用指向子类对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Animal obj &#x3D; new Animal();</span><br><span class="line">        obj.cry();</span><br><span class="line">        obj &#x3D; new Cat();</span><br><span class="line">        obj.cry();</span><br><span class="line">        obj &#x3D; new Dog();</span><br><span class="line">        obj.cry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Animal&#123;</span><br><span class="line">    &#x2F;&#x2F; 动物的叫声</span><br><span class="line">    public void cry()&#123;</span><br><span class="line">        System.out.println(&quot;不叫&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line">class Cat extends Animal&#123;</span><br><span class="line">    &#x2F;&#x2F; 猫的叫声</span><br><span class="line">    public void cry()&#123;</span><br><span class="line">        System.out.println(&quot;喵&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line">    &#x2F;&#x2F; 狗的叫声</span><br><span class="line">    public void cry()&#123;</span><br><span class="line">        System.out.println(&quot;汪&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>多态的一个好处是：当子类比较多时，也不需要定义多个变量，可以只定义一个父类类型的变量来引用不同子类的实例</p>
<h2 id="动态绑定">3.1. 动态绑定</h2><p>Java调用方法详细流程</p>
<ul>
<li>编译器查看对象声明类型和方法名。一一列举所有类中名为func的方法和其父类中访问属性为 public 且名为func的方法。这样，编译器就获得了所有可能被调用的候选方法列表。</li>
<li>检查调用方法时提供的参数签名。重载解析（overloading resolution）。编译器自动选举对应参数签名的函数。如果没有匹配，则编译错误</li>
<li>如果方法的修饰符是private、static、final（static和final将在后续讲解），或者是构造方法，那么编译器将可以准确地知道应该调用哪个方法，我们将这种调用方式 称为静态绑定(static binding)。</li>
<li>当程序运行，并且釆用动态绑定调用方法时，JVM一定会调用与 obj 所引用对象的实际类型最合适的那个类的方法。</li>
</ul>
<p>每次调用方法都要进行搜索，时间开销相当大，因此，JVM预先为每个类创建了一个方法表(method lable)，其中列出了所有方法的名称、参数签名和所属的类。这样一来，在真正调用方法的时候，虚拟机仅查找这个表就行了。</p>
<h2 id="instanceof-运算符">3.2. instanceof 运算符</h2><p>多态性带来了一个问题，就是如何判断一个变量所实际引用的对象的类型 。 C++使用runtime-type information(RTTI)，Java 使用 instanceof 操作符。instanceof 运算符用来判断一个变量所引用的对象的实际类型，注意是它引用的对象的类型，不是变量的类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable instanceof classname</span><br></pre></td></tr></table></figure>
<p>如果变量引用的是当前类或它的子类的实例，instanceof 返回 true，否则返回 false。</p>
<h2 id="多态对象的类型转换">3.3. 多态对象的类型转换</h2><p>我们将子类向父类转换称为“向上转型”，将父类向子类转换称为“向下转型”。很多时候，我们会将变量定义为父类的类型，却引用子类的对象，这个过程就是向上转型。程序运行时通过动态绑定来实现对子类方法的调用，也就是多态性。然而有些时候为了完成某些父类没有的功能，我们需要将向上转型后的子类对象再转成子类，调用子类的方法，这就是向下转型。<br>注意：不能直接将父类的对象强制转换为子类类型，只能将向上转型后的子类对象再次转换为子类类型。也就是说，子类对象必须向上转型后，才能再向下转型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Demo &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        SuperClass superObj &#x3D; new SuperClass();</span><br><span class="line">        SonClass sonObj &#x3D; new SonClass();</span><br><span class="line">        &#x2F;&#x2F; 下面的代码运行时会抛出异常，不能将父类对象直接转换为子类类型</span><br><span class="line">        &#x2F;&#x2F; SonClass sonObj2 &#x3D; (SonClass)superObj;</span><br><span class="line">        &#x2F;&#x2F; 先向上转型，再向下转型</span><br><span class="line">        superObj &#x3D; sonObj;</span><br><span class="line">        SonClass sonObj1 &#x3D; (SonClass)superObj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class SuperClass&#123; &#125;</span><br><span class="line">class SonClass extends SuperClass&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>因为向下转型存在风险，所以在接收到父类的一个引用时，请务必使用 instanceof 运算符来判断该对象是否是你所要的子类。</p>
<h1 id="内部类">4. 内部类</h1><p>在 Java 中，允许在一个类（或方法、语句块）的内部定义另一个类，称为内部类(Inner Class)，有时也称为嵌套类(Nested Class)。</p>
<p>内部类和外层封装它的类之间存在逻辑上的所属关系，一般只用在定义它的类或语句块之内，实现一些没有通用意义的功能逻辑，在外部引用它时必须给出完整的名称。</p>
<p>使用内部类的主要原因有：</p>
<ul>
<li>内部类可以访问外部类中的数据，包括私有的数据。</li>
<li>内部类可以对同一个包中的其他类隐藏起来。</li>
<li>当想要定义一个回调函数且不想编写大量代码时，使用匿名(anonymous)内部类比较便捷。</li>
<li>减少类的命名冲突。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    private int size;</span><br><span class="line">    public class Inner &#123;</span><br><span class="line">        private int counter &#x3D; 10;</span><br><span class="line">        public void doStuff() &#123;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Demo outer &#x3D; new Demo();</span><br><span class="line">        Inner inner &#x3D; outer.new Inner();</span><br><span class="line">        inner.doStuff();</span><br><span class="line">        System.out.println(outer.size);</span><br><span class="line">        System.out.println(inner.counter);</span><br><span class="line">        &#x2F;&#x2F; 编译错误，外部类不能访问内部类的变量</span><br><span class="line">&#x2F;&#x2F;        System.out.println(counter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译，会生成两个 <code>.class </code>文件：<code>Outer.class</code> 和 <code>Outer$Inner.class</code>。也就是说，内部类会被编译成独立的字节码文件。内部类是一种编译器现象，与虚拟机无关。编译器将会把内部类翻译成用<code>$</code>符号分隔外部类名与内部类名的常规类文件，而虚拟机则对此一无所知。</p>
<p>注意：必须先有外部类的对象才能生成内部类的对象，因为内部类有时需要访问外部类中的成员变量，成员变量必须实例化才有意义。</p>
<p>内部类是 Java 1.1 的新增特性，有些程序员认为这是一个值得称赞的进步，但是内部类的语法很复杂，严重破坏了良好的代码结构， 违背了Java要比C++更加简单的设计理念。</p>
<h2 id="内部类的分类">4.1. 内部类的分类</h2><p>内部类可以是静态(static)的，可以使用 public、protected 和 private 访问控制符，而外部类只能使用 public，或者默认。</p>
<p>在外部类内部直接定义（不在方法内部或代码块内部）的类就是成员式内部类，它可以直接使用外部类的所有变量和方法，即使是 private 的。外部类要想访问内部类的成员变量和方法，则需要通过内部类的对象来获取。</p>
<h1 id="抽象类">5. 抽象类</h1><p>在自上而下的继承层次结构中，位于上层的类更具有通用性，甚至可能更加抽象。从某种角度看，祖先类更加通用，它只包含一些最基本的成员，人们只将它作为派生其他类的基类，而不会用来创建对象。甚至，你可以只给出方法的定义而不实现，由子类根据具体需求来具体实现。这种只给出方法定义而不具体实现的方法被称为抽象方法，抽象方法是没有方法体的，在代码的表达上就是没有“{}”。包含一个或多个抽象方法的类也必须被声明为抽象类。</p>
<p>抽象类除了包含抽象方法外，还可以包含具体的变量和具体的方法。类即使不包含抽象方法，也可以被声明为抽象类，防止被实例化。抽象类不能被实例化，抽象方法必须在子类中被实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import static java.lang.System.*;</span><br><span class="line">public  class Demo&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Teacher t &#x3D; new Teacher();</span><br><span class="line">        t.setName(&quot;王明&quot;);</span><br><span class="line">        t.work();</span><br><span class="line">       </span><br><span class="line">        Driver d &#x3D; new Driver();</span><br><span class="line">        d.setName(&quot;小陈&quot;);</span><br><span class="line">        d.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 定义一个抽象类</span><br><span class="line">abstract class People&#123;</span><br><span class="line">    private String name;  &#x2F;&#x2F; 实例变量</span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F; 共有的 setter 和 getter 方法</span><br><span class="line">    public void setName(String name)&#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F; 抽象方法</span><br><span class="line">    public abstract void work();</span><br><span class="line">&#125;</span><br><span class="line">class Teacher extends People&#123;</span><br><span class="line">    &#x2F;&#x2F; 必须实现该方法</span><br><span class="line">    public void work()&#123;</span><br><span class="line">        out.println(&quot;我的名字叫&quot; + this.getName() + &quot;，我正在讲课，请大家不要东张西望...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Driver extends People&#123;</span><br><span class="line">    &#x2F;&#x2F; 必须实现该方法</span><br><span class="line">    public void work()&#123;</span><br><span class="line">        out.println(&quot;我的名字叫&quot; + this.getName() + &quot;，我正在开车，不能接听电话...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于抽象类的几点说明：</p>
<ul>
<li>抽象类不能直接使用，必须用子类去实现抽象类，然后使用其子类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例，也就是可以使用抽象类来充当形参，实际实现类作为实参，这是多态的应用。</li>
<li>不能有抽象构造方法或抽象静态方法。</li>
</ul>
<p>在下列情况下，一个类将成为抽象类：</p>
<ul>
<li>当一个类的一个或多个方法是抽象方法时；</li>
<li>当类是一个抽象类的子类，并且不能为任何抽象方法提供任何实现细节或方法主体时；</li>
<li>当一个类实现一个接口，并且不能为任何抽象方法提供实现细节或方法主体时；</li>
</ul>
<p>注意：这里说的是这些情况下一个类将成为抽象类，没有说抽象类一定会有这些情况。一个典型的错误：抽象类一定包含抽象方法。 但是反过来说“包含抽象方法的类一定是抽象类”就是正确的。事实上，抽象类可以是一个完全正常实现的类</p>
<h1 id="接口">6. 接口</h1><h2 id="接口的概念">6.1. 接口的概念</h2><p>在抽象类中，可以包含一个或多个抽象方法；但在接口(interface)中，所有的方法必须都是抽象的，不能有方法体，它比抽象类更加“抽象”。</p>
<p>接口使用 interface 关键字来声明，可以看做是一种特殊的抽象类，可以指定一个类必须做什么，而不是规定它如何去做。</p>
<p>现实中也有很多接口的实例，比如说串口电脑硬盘，Serial ATA委员会指定了Serial ATA 2.0规范，这种规范就是接口。Serial ATA委员会不负责生产硬盘，只是指定通用的规范。</p>
<p>希捷、日立、三星等生产厂家会按照规范生产符合接口的硬盘，这些硬盘就可以实现通用化，如果正在用一块160G日立的串口硬盘，现在要升级了，可以购买一块320G的希捷串口硬盘，安装上去就可以继续使用了。</p>
<p>下面的代码可以模拟Serial ATA委员会定义以下串口硬盘接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Demo&#123;</span><br><span class="line">    &#x2F;&#x2F;连接线的数量</span><br><span class="line">    public static final int CONNECT_LINE&#x3D;4;</span><br><span class="line">    &#x2F;&#x2F;写数据</span><br><span class="line">    public void writeData(String data);</span><br><span class="line">    &#x2F;&#x2F;读数据</span><br><span class="line">    public String readData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：接口中声明的成员变量默认都是 public static final 的，必须显式地初始化。因而在常量声明时可以省略这些修饰符。</p>
<p>接口是若干常量和抽象方法的集合，目前看来和抽象类差不多。确实如此，接口本就是从抽象类中演化而来的，因而除特别规定，接口享有和类同样的“待遇”。比如，源程序中可以定义多个类或接口，但最多只能有一个public 的类或接口，如果有则源文件必须取和public的类和接口相同的名字。和类的继承格式一样，接口之间也可以继承，子接口可以继承父接口中的常量和抽象方法并添加新的抽象方法等。</p>
<p>接口特性：</p>
<ol>
<li>接口中只能定义抽象方法，这些方法默认为 public abstract 的，因而在声明方法时可以省略这些修饰符。试图在接口中定义实例变量、非抽象的实例方法及静态方法，都是非法的。例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface SataHdd&#123;</span><br><span class="line">    &#x2F;&#x2F;连接线的数量</span><br><span class="line">    public int connectLine; &#x2F;&#x2F;编译出错，connectLine被看做静态常量，必须显式初始化</span><br><span class="line">    &#x2F;&#x2F;写数据</span><br><span class="line">    protected void writeData(String data); &#x2F;&#x2F;编译出错，必须是public类型</span><br><span class="line">    &#x2F;&#x2F;读数据</span><br><span class="line">    public static String readData()&#123; &#x2F;&#x2F;编译出错，接口中不能包含静态方法</span><br><span class="line">        return &quot;数据&quot;; &#x2F;&#x2F;编译出错，接口中只能包含抽象方法，</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>接口没有构造方法，不能初始化</li>
<li>一个接口不实现另一个接口，但可以继承多个其他接口。接口的多继承特点弥补了类的单继承。例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;串行硬盘接口</span><br><span class="line">public interface SataHdd extends A,B&#123;</span><br><span class="line">    &#x2F;&#x2F; 连接线的数量</span><br><span class="line">    public static final int CONNECT_LINE &#x3D; 4;</span><br><span class="line">    &#x2F;&#x2F; 写数据</span><br><span class="line">    public void writeData(String data);</span><br><span class="line">    &#x2F;&#x2F; 读数据</span><br><span class="line">    public String readData();</span><br><span class="line">&#125;</span><br><span class="line">interface A&#123;</span><br><span class="line">    public void a();</span><br><span class="line">&#125;</span><br><span class="line">interface B&#123;</span><br><span class="line">    public void b();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="why-接口">6.2. why 接口</h2><p>大型项目开发中，可能需要从继承链的中间插入一个类，让它的子类具备某些功能而不影响它们的父类。例如 A -&gt; B -&gt; C -&gt; D -&gt; E，A 是祖先类，如果需要为C、D、E类添加某些通用的功能，最简单的方法是让C类再继承另外一个类。但是问题来了，Java 是一种单继承的语言，不能再让C继承另外一个父类了，只到移动到继承链的最顶端，让A再继承一个父类。这样一来，对C、D、E类的修改，影响到了整个继承链，不具备可插入性的设计。</p>
<p>接口是可插入性的保证。在一个继承链中的任何一个类都可以实现一个接口，这个接口会影响到此类的所有子类，但不会影响到此类的任何父类。此类将不得不实现这个接口所规定的方法，而子类可以从此类自动继承这些方法，这时候，这些子类具有了可插入性。</p>
<p>我们关心的不是哪一个具体的类，而是这个类是否实现了我们需要的接口。</p>
<p>接口提供了关联以及方法调用上的可插入性，软件系统的规模越大，生命周期越长，接口使得软件系统的灵活性和可扩展性，可插入性方面得到保证。</p>
<p>接口在面向对象的 Java 程序设计中占有举足轻重的地位。事实上在设计阶段最重要的任务之一就是设计出各部分的接口，然后通过接口的组合，形成程序的基本框架结构。</p>
<h2 id="接口的使用">6.3. 接口的使用</h2><p>接口的使用与类的使用有些不同。在需要使用类的地方，会直接使用new关键字来构建一个类的实例，但接口不可以这样使用，因为接口不能直接使用 new 关键字来构建实例。</p>
<p>接口必须通过类来实现(implements)它的抽象方法，然后再实例化类。类实现接口的关键字为implements。</p>
<p>如果一个类不能实现该接口的所有抽象方法，那么这个类必须被定义为抽象方法。</p>
<p>不允许创建接口的实例，但允许定义接口类型的引用变量，该变量指向了实现接口的类的实例。</p>
<p>一个类只能继承一个父类，但却可以实现多个接口。</p>
<p>实现接口的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 类名 extends 父类 implements 多个接口(逗号分隔) &#123;</span><br><span class="line">实现方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import static java.lang.System.*;</span><br><span class="line">public class Demo&#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">      SataHdd sh1&#x3D;new SeagateHdd(); &#x2F;&#x2F;初始化希捷硬盘</span><br><span class="line">      SataHdd sh2&#x3D;new SamsungHdd(); &#x2F;&#x2F;初始化三星硬盘</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;串行硬盘接口</span><br><span class="line">interface SataHdd&#123;</span><br><span class="line">    &#x2F;&#x2F;连接线的数量</span><br><span class="line">    public static final int CONNECT_LINE&#x3D;4;</span><br><span class="line">    &#x2F;&#x2F;写数据</span><br><span class="line">    public void writeData(String data);</span><br><span class="line">    &#x2F;&#x2F;读数据</span><br><span class="line">    public String readData();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 维修硬盘接口</span><br><span class="line">interface fixHdd&#123;</span><br><span class="line">    &#x2F;&#x2F; 维修地址</span><br><span class="line">    String address &#x3D; &quot;北京市海淀区&quot;;</span><br><span class="line">    &#x2F;&#x2F; 开始维修</span><br><span class="line">    boolean doFix();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;捷硬盘</span><br><span class="line">class SeagateHdd implements SataHdd, fixHdd&#123;</span><br><span class="line">    &#x2F;&#x2F;希捷硬盘读取数据</span><br><span class="line">    public String readData()&#123;</span><br><span class="line">        return &quot;数据&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;希捷硬盘写入数据</span><br><span class="line">    public void writeData(String data) &#123;</span><br><span class="line">        out.println(&quot;写入成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 维修希捷硬盘</span><br><span class="line">    public boolean doFix()&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;三星硬盘</span><br><span class="line">class SamsungHdd implements SataHdd&#123;</span><br><span class="line">    &#x2F;&#x2F;三星硬盘读取数据</span><br><span class="line">    public String readData()&#123;</span><br><span class="line">        return &quot;数据&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;三星硬盘写入数据</span><br><span class="line">    public void writeData(String data)&#123;</span><br><span class="line">        out.println(&quot;写入成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;某劣质硬盘，不能写数据</span><br><span class="line">abstract class XXHdd implements SataHdd&#123;</span><br><span class="line">    &#x2F;&#x2F;硬盘读取数据</span><br><span class="line">    public String readData() &#123;</span><br><span class="line">        return &quot;数据&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口作为类使用">6.4. 接口作为类使用</h2><p>接口作为引用类型来使用，任何实现该接口的类的实例都可以存储在该接口类型的变量中，通过这些变量可以访问类中所实现的接口中的方法，Java 运行时系统会动态地确定应该使用哪个类中的方法，实际上是调用相应的实现类的方法。下面例子中可以看到接口可以作为一个类型来使用，把接口作为方法的参数和返回类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Demo&#123;</span><br><span class="line">    public void test1(A a) &#123;</span><br><span class="line">        a.doSth();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Demo d &#x3D; new Demo();</span><br><span class="line">        A a &#x3D; new B();</span><br><span class="line">        d.test1(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface A &#123;</span><br><span class="line">    public int doSth();</span><br><span class="line">&#125;</span><br><span class="line">class B implements A &#123;</span><br><span class="line">    public int doSth() &#123;</span><br><span class="line">        System.out.println(&quot;now in B&quot;);</span><br><span class="line">        return 123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="接口与抽象类">7. 接口与抽象类</h1><p>类是对象的模板，抽象类和接口可以看做是具体的类的模板。</p>
<p>由于从某种角度讲，接口是一种特殊的抽象类，它们的渊源颇深，有很大的相似之处，所以在选择使用谁的问题上很容易迷糊。</p>
<p>相同点：</p>
<ul>
<li>都代表类树形结构的抽象层。在使用引用变量时，尽量使用类结构的抽象层，使方法的定义和实现分离，这样做对于代码有松散耦合的好处。</li>
<li>都不能被实例化。</li>
<li>都能包含抽象方法。抽象方法用来描述系统提供哪些功能，而不必关心具体的实现。</li>
</ul>
<p>区别</p>
<ol>
<li>抽象类可以为部分方法提供实现，避免了在子类中重复实现这些方法，提高了代码的可重用性，这是抽象类的优势；而接口中只能包含抽象方法，不能包含任何实现。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public abstract class A&#123;</span><br><span class="line">    public abstract void method1();</span><br><span class="line">    public void method2()&#123;</span><br><span class="line">        &#x2F;&#x2F;A method2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class B extends A&#123;</span><br><span class="line">    public void method1()&#123;</span><br><span class="line">        &#x2F;&#x2F;B method1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class C extends A&#123;</span><br><span class="line">    public void method1()&#123;</span><br><span class="line">        &#x2F;&#x2F;C method1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>抽象类A有两个子类B、C，由于A中有方法method2的实现，子类B、C中不需要重写method2方法，我们就说A为子类提供了公共的功能，或A约束了子类的行为。method2就是代码可重用的例子。A 并没有定义 method1的实现，也就是说B、C 可以根据自己的特点实现method1方法，这又体现了松散耦合的特性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public interface A&#123;</span><br><span class="line">    public void method1();</span><br><span class="line">    public void method2();</span><br><span class="line">&#125;</span><br><span class="line">public class B implements A&#123;</span><br><span class="line">    public void method1()&#123;</span><br><span class="line">        &#x2F;&#x2F;B method1</span><br><span class="line">    &#125;</span><br><span class="line">    public void method2()&#123;</span><br><span class="line">        &#x2F;&#x2F;B method2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class C implements A&#123;</span><br><span class="line">    public void method1()&#123;</span><br><span class="line">        &#x2F;&#x2F;C method1</span><br><span class="line">    &#125;</span><br><span class="line">    public void method2()&#123;</span><br><span class="line">        &#x2F;&#x2F;C method2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口A无法为实现类B、C提供公共的功能，也就是说A无法约束B、C的行为。B、C可以自由地发挥自己的特点现实 method1和 method2方法，接口A毫无掌控能力。</p>
<ol start="2">
<li>一个类只能继承一个直接的父类（可能是抽象类），但一个类可以实现多个接口，这个就是接口的优势。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">interface A&#123;</span><br><span class="line">    public void method2();</span><br><span class="line">&#125;</span><br><span class="line">interface B&#123;</span><br><span class="line">    public void method1();</span><br><span class="line">&#125;</span><br><span class="line">class C implements A,B&#123;</span><br><span class="line">    public void method1()&#123;</span><br><span class="line">        &#x2F;&#x2F;C method1</span><br><span class="line">    &#125;</span><br><span class="line">    public void method2()&#123;</span><br><span class="line">        &#x2F;&#x2F;C method2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;可以如此灵活的使用C，并且C还有机会进行扩展，实现其他接口</span><br><span class="line">A a&#x3D;new C();</span><br><span class="line">B b&#x3D;new C();</span><br><span class="line">abstract class A&#123;</span><br><span class="line">    public abstract void method1();</span><br><span class="line">&#125;</span><br><span class="line">abstract class B extends A&#123;</span><br><span class="line">    public abstract void method2();</span><br><span class="line">&#125;</span><br><span class="line">class C extends B&#123;</span><br><span class="line">    public void method1()&#123;</span><br><span class="line">        &#x2F;&#x2F;C method1</span><br><span class="line">    &#125;</span><br><span class="line">    public void method2() &#123;</span><br><span class="line">        &#x2F;&#x2F;C method2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>综上所述，接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：</p>
<ul>
<li>行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。</li>
<li>选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。</li>
</ul>
<p>接口和抽象类的区别是什么？</p>
<ul>
<li>接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。</li>
<li>接口中除了 static、final 变量，不能有其他变量，而抽象类中则不一定。</li>
<li>一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过 extends 关键字扩展多个接口。</li>
<li>接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用 private 关键字修饰！）。</li>
<li>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li>
</ul>
<p>总结一下 jdk7~jdk9 Java 中接口概念的变化：</p>
<ul>
<li>在 jdk 7 或更早版本中，接口里面只能有常量变量和抽象方法。这些接口方法必须由选择实现接口的类实现。</li>
<li>jdk8 的时候接口可以有默认方法和静态方法功能。</li>
<li>Jdk 9 在接口中引入了私有方法和私有静态方法。</li>
</ul>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>OneEarMouse
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://codesh.xyz/2020/10/18/Java-review-3/" title="Java复健系列(3)：Java的面向对象">http://codesh.xyz/2020/10/18/Java-review-3/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/10/18/Java-review-2/" rel="prev" title="Java复健系列(2)：Java的类与对象">
      <i class="fa fa-chevron-left"></i> Java复健系列(2)：Java的类与对象
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/10/19/Java-review-4/" rel="next" title="Java复健系列(4)：Java中的异常处理">
      Java复健系列(4)：Java中的异常处理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="nav-text">1. 面向对象三大特征</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-text">1.1. 封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-text">1.2. 继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-text">1.3. 多态</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF-1"><span class="nav-text">2. 继承</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF-2"><span class="nav-text">2.1. 继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#super-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">2.2. super 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="nav-text">2.2.1. 调用父类方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD"><span class="nav-text">2.3. 重写和重载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%86%99%EF%BC%88Override%EF%BC%89"><span class="nav-text">2.3.1. 重写（Override）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BDOverload"><span class="nav-text">2.3.2. 重载Overload</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">2.4. 重写与重载之间的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E6%80%81-1"><span class="nav-text">3. 多态</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="nav-text">3.1. 动态绑定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#instanceof-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">3.2. instanceof 运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">3.3. 多态对象的类型转换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">4. 内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">4.1. 内部类的分类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-text">5. 抽象类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-text">6. 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">6.1. 接口的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#why-%E6%8E%A5%E5%8F%A3"><span class="nav-text">6.2. why 接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">6.3. 接口的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E4%BD%9C%E4%B8%BA%E7%B1%BB%E4%BD%BF%E7%94%A8"><span class="nav-text">6.4. 接口作为类使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-text">7. 接口与抽象类</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="OneEarMouse"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">OneEarMouse</p>
  <div class="site-description" itemprop="description">程序员一只耳的个人编程问题记录存档，仅供参考</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">OneEarMouse</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">143k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:10</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
