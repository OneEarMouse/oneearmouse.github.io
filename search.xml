<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Rate Limiter解析</title>
    <url>/2022/01/30/Analyse-rate-limiter/</url>
    <content><![CDATA[<h1 id="限流">1. 限流</h1><p>限流是保护高并发系统的三大利器之一，另外两个是缓存和降级。限流在很多场景中用来限制并发和请求量，比如说秒杀抢购，保护自身系统和下游系统不被巨型流量冲垮等。</p>
<p>限流的目的是通过对并发访问&#x2F;请求进行限速或者一个时间窗口内的的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务或进行流量整形。</p>
<h2 id="常用限流方法">1.1. 常用限流方法</h2><p>常用的限流方式和场景有：限制总并发数（比如数据库连接池、线程池）、限制瞬时并发数（如nginx的limitconn模块，用来限制瞬时并发连接数，Java的Semaphore也可以实现）、限制时间窗口内的平均速率（如Guava的RateLimiter、nginx的limitreq模块，限制每秒的平均速率）；其他还有如限制远程接口调用速率、限制MQ的消费速率。另外还可以根据网络连接数、网络流量、CPU或内存负载等来限流。</p>
<p>RateLimiter常用：限制方法在一段时间内平均被调用次数不超过某个数字</p>
<h1 id="限流算法">2. 限流算法</h1><h2 id="漏桶算法">2.1. 漏桶算法</h2><p><img src="/.xyz//leaky-bucket.png" alt="漏桶算法图示"><br>形象解释：<br>入口-&gt;水流-&gt;桶（有漏洞）-&gt;水流-&gt;出口</p>
<ol>
<li>正常情况：入口水流与出口水流持平。桶中几乎没有积水</li>
<li>超量情况：入口水流远大于出口水流。桶中不断积水，最后溢出</li>
</ol>
<p>实现方法：<br>使用队列实现，有处理器按照固定速率从队列头取出请求进行计算。<br>请求到达如队列未满则直接放入队列。如请求量大导致队列满，则抛弃新请求</p>
<h2 id="令牌桶算法">2.2. 令牌桶算法</h2><p><img src="/.xyz//token-bucket.png" alt="令牌桶算法图示"><br>形象解释：<br>令牌（固定速率）-&gt;桶<br>请求-&gt;缓冲器-&gt;能否拿到令牌？-&gt;计算</p>
<ol>
<li>按照固定速率往桶里添加令牌。桶中存放的令牌数有最大上限，超出之后就被丢弃或者拒绝</li>
<li>当流量或者网络请求到达时，每个请求都要获取一个令牌，如果能够获取到，则直接处理，并且令牌桶删除一个令牌</li>
<li>如无法获取令牌，则选择丢弃或在缓冲区等待</li>
</ol>
<h1 id="RateLimiter">3. RateLimiter</h1><p>Guava是Java领域优秀的开源项目，它包含了Google在Java项目中使用一些核心库。RateLimiter是其中的限流器实现。RateLimiter提供了令牌桶算法的两种具体实现。由RateLimiter的两个子类实现：</p>
<ul>
<li>平滑突发限流 SmoothBursty :</li>
<li>平滑预热限流 SmoothWarmingUp :</li>
</ul>
<p>注：本文源码分析基于：com.google.guava-18.0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RateLimiter提供了两个工厂方法，最终会调用下面两个函数，生成RateLimiter的两个子类。</span></span><br><span class="line"><span class="comment">// SmoothBursty类</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> RateLimiter <span class="title">create</span><span class="params">(SleepingStopwatch stopwatch, <span class="keyword">double</span> permitsPerSecond)</span> </span>&#123;</span><br><span class="line"> RateLimiter rateLimiter = <span class="keyword">new</span> SmoothBursty(stopwatch, <span class="number">1.0</span> <span class="comment">/* maxBurstSeconds */</span>);</span><br><span class="line">    rateLimiter.setRate(permitsPerSecond);</span><br><span class="line"> <span class="keyword">return</span> rateLimiter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SmoothWarmingUp类</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> RateLimiter <span class="title">create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"> SleepingStopwatch stopwatch, <span class="keyword">double</span> permitsPerSecond, <span class="keyword">long</span> warmupPeriod, TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">double</span> coldFactor)</span> </span>&#123;</span><br><span class="line"> RateLimiter rateLimiter = <span class="keyword">new</span> SmoothWarmingUp(stopwatch, warmupPeriod, unit, coldFactor);</span><br><span class="line">    rateLimiter.setRate(permitsPerSecond);</span><br><span class="line"> <span class="keyword">return</span> rateLimiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="平滑突发限流">3.1. 平滑突发限流</h2><p>使用：<br>使用 RateLimiter的静态方法创建一个限流器，设置每秒放置的令牌数为10个。返回的RateLimiter对象可以保证1秒内不会给超过10个令牌，并且以固定速率进行放置，达到平滑输出的效果。</p>
<p>注意：最终使用时计算出的时间间隔不保证一定是准确的0.1s。可能存在误差，在需要精确限流时需要注意</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创造一个limiter，平均每秒能获取10个token</span></span><br><span class="line">  RateLimiter limiter = RateLimiter.create(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;get 1 token, need: &quot;</span> + limiter.acquire() + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 约0.1s执行一次</span></span><br><span class="line"><span class="comment">     * get 1 token, need: 0.0s</span></span><br><span class="line"><span class="comment">     * get 1 token, need: 0.099736s</span></span><br><span class="line"><span class="comment">     * get 1 token, need: 0.084306s</span></span><br><span class="line"><span class="comment">     * get 1 token, need: 0.099511s</span></span><br><span class="line"><span class="comment">     * get 1 token, need: 0.089593s</span></span><br><span class="line"><span class="comment">     * get 1 token, need: 0.095184s</span></span><br><span class="line"><span class="comment">     * get 1 token, need: 0.099848s</span></span><br><span class="line"><span class="comment">     * get 1 token, need: 0.089194s</span></span><br><span class="line"><span class="comment">     * get 1 token, need: 0.099824s</span></span><br><span class="line"><span class="comment">     * get 1 token, need: 0.090818s</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<h2 id="平滑预热限流">3.2. 平滑预热限流</h2><p>SmoothWarmingUp是带有预热期的平滑限流，它启动后有一段预热期，逐步将分发频率提升到配置的速率。<br>如下代码中分发速率是2，预热期是5秒。限流器会在前5秒内限制速度，最后再恢复到每秒2次的分发速率</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创造一个limiter，平均每秒能获取10个token</span></span><br><span class="line">  RateLimiter limiter = RateLimiter.create(<span class="number">2</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;get 1 token, need: &quot;</span> + limiter.acquire() + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先预热，再加速到预设时间</span></span><br><span class="line"><span class="comment">     * get 1 token, need: 0.0s</span></span><br><span class="line"><span class="comment">     * get 1 token, need: 1.39981s</span></span><br><span class="line"><span class="comment">     * get 1 token, need: 1.189238s</span></span><br><span class="line"><span class="comment">     * get 1 token, need: 0.999016s</span></span><br><span class="line"><span class="comment">     * get 1 token, need: 0.799373s</span></span><br><span class="line"><span class="comment">     * get 1 token, need: 0.599583s</span></span><br><span class="line"><span class="comment">     * get 1 token, need: 0.487746s</span></span><br><span class="line"><span class="comment">     * get 1 token, need: 0.499393s</span></span><br><span class="line"><span class="comment">     * get 1 token, need: 0.499531s</span></span><br><span class="line"><span class="comment">     * get 1 token, need: 0.495839s</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用方法">3.3. 使用方法</h2><ol>
<li>使用acquire</li>
</ol>
<p>每次调用<code>doSomeThing</code>时，程序都会在<code>limiter.acquier()</code>处阻塞等待。直到limiter获取token，才会继续往后执行do something。从而达到限流效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">limiter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RateLimiter limiter = RateLimiter.create(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        limiter.acquire();</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用tryAcquire</li>
</ol>
<p>每次调用<code>doSomeThing</code>时，程序都会在<code>limiter.tryAcquier()</code>等待。与上面不同的时，这个阻塞式等待设置有最长等待时间。如成功在500ms内获取token，则返回true可以继续执行逻辑。如果未能在500ms内获取token，则表示获取token失败，事实上已经超过了qps限制，需要执行失败逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">limiter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RateLimiter limiter = RateLimiter.create(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 等待获取token，最大时长为500ms</span></span><br><span class="line">        <span class="keyword">if</span>(limiter.tryAcquire(<span class="number">500</span>, TimeUnit.MILLISECONDS))&#123;</span><br><span class="line">            <span class="comment">// 执行逻辑</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 超过500ms，无法获取到token</span></span><br><span class="line">            <span class="comment">// 执行失败逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="源码解析">4. 源码解析</h1><h2 id="构造函数">4.1. 构造函数</h2><p>创建stopWatch，然后调用create，传入<code>permitsPerSecond</code>创建子类的SmoothBursty</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">create(SleepingStopwatch.createFromSystemTimer(), permitsPerSecond);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> RateLimiter <span class="title">create</span><span class="params">(SleepingStopwatch stopwatch, <span class="keyword">double</span> permitsPerSecond)</span> </span>&#123;</span><br><span class="line">  RateLimiter rateLimiter = <span class="keyword">new</span> SmoothBursty(stopwatch, <span class="number">1.0</span> <span class="comment">/* maxBurstSeconds */</span>);</span><br><span class="line">  rateLimiter.setRate(permitsPerSecond);</span><br><span class="line">  <span class="keyword">return</span> rateLimiter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond)</span> </span>&#123;</span><br><span class="line">  checkArgument(</span><br><span class="line">      permitsPerSecond &gt; <span class="number">0.0</span> &amp;&amp; !Double.isNaN(permitsPerSecond), <span class="string">&quot;rate must be positive&quot;</span>);</span><br><span class="line">  <span class="keyword">synchronized</span> (mutex()) &#123;</span><br><span class="line">    doSetRate(permitsPerSecond, stopwatch.readMicros());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="时间相关">4.2. 时间相关</h2><p>先来看看代码中时间相关的基本计算方法</p>
<p>stopWatch源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Stopwatch</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Ticker ticker;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isRunning;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> elapsedNanos;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> startTick;</span><br><span class="line"></span><br><span class="line">  Stopwatch() &#123;</span><br><span class="line">    <span class="keyword">this</span>(Ticker.systemTicker());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Stopwatch <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkState(!isRunning, <span class="string">&quot;This stopwatch is already running.&quot;</span>);</span><br><span class="line">    isRunning = <span class="keyword">true</span>;</span><br><span class="line">    startTick = ticker.read();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> SleepingStopwatch <span class="title">createFromSystemTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SleepingStopwatch() &#123;</span><br><span class="line">        <span class="keyword">final</span> Stopwatch stopwatch = Stopwatch.createStarted();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">long</span> <span class="title">readMicros</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> stopwatch.elapsed(MICROSECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sleepMicrosUninterruptibly</span><span class="params">(<span class="keyword">long</span> micros)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (micros &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Uninterruptibles.sleepUninterruptibly(micros, MICROSECONDS);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure>

<p>其中ticker.read()调用系统的ticker并记录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Ticker <span class="title">systemTicker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> SYSTEM_TICKER;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Ticker SYSTEM_TICKER = <span class="keyword">new</span> Ticker() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Platform.systemNanoTime();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以明白，rateLimiter的时间计算本质上基于系统的ticker计算。由于系统的tick计算是基于系统所在的计算平台的CPU频率与时钟频率，如不能精确计算CPU时钟频率则无法实现精密时间计算。因此RateLimiter在计算高精度的时间时可能出现误差。一个具体表现就是上面例子中预估0.1s获取一次时，经常出现误差，无法精确做到0.1s一次。（其实这个问题还有另一种解释，可以继续往下看）</p>
<h2 id="SmoothBursty">4.3. SmoothBursty</h2><p>我们继续查看SmoothBursty类的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SmoothBursty</span> <span class="keyword">extends</span> <span class="title">SmoothRateLimiter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The work (permits) of how many seconds can be saved up if this RateLimiter is unused? */</span></span><br><span class="line">    <span class="comment">// 当未使用时，最多可以缓存几秒的令牌（默认为0）</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> maxBurstSeconds; </span><br><span class="line">    </span><br><span class="line">    SmoothBursty(SleepingStopwatch stopwatch, <span class="keyword">double</span> maxBurstSeconds) &#123;</span><br><span class="line">      <span class="keyword">super</span>(stopwatch);</span><br><span class="line">      <span class="keyword">this</span>.maxBurstSeconds = maxBurstSeconds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>doSetRate流程：</p>
<p>先计算<code>double stableIntervalMicros = SECONDS.toMicros(1L) / permitsPerSecond;</code>然后设置SmoothBursty中的<code>maxPermits</code>（默认为1秒的值）为<code>permitsPerSecond</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">doSetRate(permitsPerSecond, stopwatch.readMicros());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doSetRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// resync函数用于刷新同步tokens，具体见后面分析</span></span><br><span class="line">  resync(nowMicros);</span><br><span class="line">  <span class="comment">// 计算每个令牌之间的时间间隔</span></span><br><span class="line">  <span class="keyword">double</span> stableIntervalMicros = SECONDS.toMicros(<span class="number">1L</span>) / permitsPerSecond;</span><br><span class="line">  <span class="keyword">this</span>.stableIntervalMicros = stableIntervalMicros;</span><br><span class="line">  doSetRate(permitsPerSecond, stableIntervalMicros);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doSetRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">double</span> stableIntervalMicros)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> oldMaxPermits = <span class="keyword">this</span>.maxPermits;</span><br><span class="line">    <span class="comment">// 计算能够存放的最大令牌数量</span></span><br><span class="line">    maxPermits = maxBurstSeconds * permitsPerSecond;</span><br><span class="line">    <span class="keyword">if</span> (oldMaxPermits == Double.POSITIVE_INFINITY) &#123;</span><br><span class="line">      <span class="comment">// if we don&#x27;t special-case this, we would get storedPermits == NaN, below</span></span><br><span class="line">      storedPermits = maxPermits;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      storedPermits = (oldMaxPermits == <span class="number">0.0</span>)</span><br><span class="line">          ? <span class="number">0.0</span> <span class="comment">// initial state</span></span><br><span class="line">          : storedPermits * maxPermits / oldMaxPermits;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h2 id="acquire流程">4.4. acquire流程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算令牌获取所需等待时间</span></span><br><span class="line">    <span class="keyword">long</span> microsToWait = reserve(permits);</span><br><span class="line">    <span class="comment">// 线程sleep</span></span><br><span class="line">    stopwatch.sleepMicrosUninterruptibly(microsToWait);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * microsToWait / SECONDS.toMicros(<span class="number">1L</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserve</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    checkPermits(permits);</span><br><span class="line">    <span class="comment">// 并发操作，使用锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mutex()) &#123;</span><br><span class="line">      <span class="keyword">return</span> reserveAndGetWaitLength(permits, stopwatch.readMicros());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserveAndGetWaitLength</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算获取令牌的时间，并将这个时间存储到下一次</span></span><br><span class="line">    <span class="keyword">long</span> momentAvailable = reserveEarliestAvailable(permits, nowMicros);</span><br><span class="line">    <span class="comment">// 减去当前时间，获得等待时间</span></span><br><span class="line">    <span class="keyword">return</span> max(momentAvailable - nowMicros, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserveEarliestAvailable</span><span class="params">(<span class="keyword">int</span> requiredPermits, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    resync(nowMicros);</span><br><span class="line">    <span class="keyword">long</span> returnValue = nextFreeTicketMicros;</span><br><span class="line">    <span class="comment">// 计算当前可以获得的令牌数量</span></span><br><span class="line">    <span class="keyword">double</span> storedPermitsToSpend = min(requiredPermits, <span class="keyword">this</span>.storedPermits);</span><br><span class="line">    <span class="comment">// 机制上允许一次获取大量令牌，并预支未来的令牌</span></span><br><span class="line">    <span class="comment">// 计算预先支付令牌数量</span></span><br><span class="line">    <span class="keyword">double</span> freshPermits = requiredPermits - storedPermitsToSpend;</span><br><span class="line">    <span class="comment">// 需要等待的时间=当前消耗令牌所占用时间+预支令牌所占用时间</span></span><br><span class="line">    <span class="keyword">long</span> waitMicros = storedPermitsToWaitTime(<span class="keyword">this</span>.storedPermits, storedPermitsToSpend)</span><br><span class="line">        + (<span class="keyword">long</span>) (freshPermits * stableIntervalMicros);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算出下一次空闲的时间</span></span><br><span class="line">    <span class="keyword">this</span>.nextFreeTicketMicros = nextFreeTicketMicros + waitMicros;</span><br><span class="line">    <span class="comment">// 消耗令牌</span></span><br><span class="line">    <span class="keyword">this</span>.storedPermits -= storedPermitsToSpend;</span><br><span class="line">    <span class="keyword">return</span> returnValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 刷新token函数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">resync</span><span class="params">(<span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前时间晚于nextFreeTicketMicros，刷新令牌和nextFreeTicketMicros</span></span><br><span class="line">    <span class="keyword">if</span> (nowMicros &gt; nextFreeTicketMicros) &#123;</span><br><span class="line">      <span class="comment">// 计算刷新后的storedPermits</span></span><br><span class="line">      <span class="comment">// 当前时间减去nextFreeTicketMicros，再除以获取令牌的时间间隔，得到这段时间内的令牌数</span></span><br><span class="line">      storedPermits = min(maxPermits,</span><br><span class="line">        storedPermits+ (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros());</span><br><span class="line">      nextFreeTicketMicros = nowMicros;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前时间早于nextFreeTicketMicros，则获取令牌的线程要一直等待到nextFreeTicketMicros,该线程获取令牌所需</span></span><br><span class="line">    <span class="comment">// 额外等待的时间由下一次获取的线程来代替等待。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// coolDownIntervalMicros函数获生成一个令牌的间隔</span></span><br><span class="line">  <span class="comment">// 注：SmoothWarmingUp和SmoothBuresty的实现不同</span></span><br><span class="line">  <span class="comment">// SmoothBuresty的coolDownIntervalMicros直接返回stableIntervalMicros（之前在setRate中获取）</span></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">coolDownIntervalMicros</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stableIntervalMicros;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>流程：</p>
<ol>
<li>尝试获取令牌</li>
<li>调用reserveEarliestAvailable</li>
<li>调用resync，同步时间与令牌</li>
<li>计算storedPermitsToSpend</li>
<li>计算是否需要预先支付令牌</li>
<li>计算waitMicros</li>
<li>更新nextFreeTicketMicros</li>
<li>减少storedPermits</li>
<li>让stopWatch等待nextFreeTicketMicros</li>
<li>返回，表示acquire成功</li>
</ol>
<p>注意点：</p>
<ol>
<li>RateLimiter在没有足够令牌发放时，采用滞后处理的方式。前一个请求获取令牌所需等待的时间计算waitMicros由下一次请求来承受，也就是代替前一个请求进行等待。</li>
<li>RateLimiter拥有预支令牌机制。当请求的令牌数量超过设置的qps上限后，可以预支后几秒的令牌放行当前动作。后果是后几秒的令牌获取受阻</li>
</ol>
<h1 id="总结">5. 总结</h1><ul>
<li>RateLimiter可以用于单机qps限制，并且带有令牌预支付功能。使用起来简单方便。</li>
<li>缺点：无法实现qps的精确计算，仅能限制到一定时间内的平均qps。</li>
<li>仅适用于单机qps。如需用于集群的qps限制，可能需要将总qps除以集群机器数量，得到单机qps上限后再设置。</li>
</ul>
]]></content>
      <categories>
        <category>源码解析</category>
      </categories>
  </entry>
  <entry>
    <title>在github使用hexo搭建博客记录Vol.1</title>
    <url>/2019/06/17/BuildRecord-Vol1/</url>
    <content><![CDATA[<p>参考资料：</p>
<ul>
<li>Hexo搭建独立博客全纪录（三）使用Hexo搭建博客: <a href="https://baoyuzhang.github.io/2017/05/12/%E3%80%90Hexo%E6%90%AD%E5%BB%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2%E5%85%A8%E7%BA%AA%E5%BD%95%E3%80%91%EF%BC%88%E4%B8%89%EF%BC%89%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/">链接</a></li>
<li>Hexo官方中文文档：<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></li>
<li>Next官方文档：<a href="http://theme-next.iissnan.com/">http://theme-next.iissnan.com/</a></li>
</ul>
<h1 id="环境配置">1. 环境配置</h1><p>要求：</p>
<ul>
<li>一个github账号</li>
<li>node.js</li>
<li>npm</li>
<li>git</li>
</ul>
<p>本文环境：</p>
<ul>
<li>Windows 10 17763</li>
<li>node.js-10.16.0 (node -version)</li>
<li>git - 2.20.1.windows.1 (git version)</li>
<li>hexo - 3.8.0 (hexo version)</li>
</ul>
<h1 id="github配置">2. github配置</h1><h2 id="创建仓库">2.1. 创建仓库</h2><p>在github中新建名为“用户名.github.io”的repo。该repo作为网站代码存储，同时，http:&#x2F;&#x2F;用户名.github.io 为未来网站访问地址。github也允许绑定自定义地址，可以在repo的setting中设置。<br>注意点：</p>
<ul>
<li>该repo在非付费账户中必须设置为public，付费账户可以设置为private；</li>
<li>仓库名字必须是：username.github.io，其中username是你的用户名；</li>
</ul>
<h2 id="配置SSH-Key">2.2. 配置SSH Key</h2><p>使用Hexo配置服务器时，需要github的访问权限。同时，本地git配置的访问方式无法被Hexo直接调用，因此需要配置SSH Key使Hexo能直接调用并获得访问权限。</p>
<ol>
<li>首先在git设置身份和邮箱，关联到你的github账号。如果已经配置过请跳过 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email“your@email.com&quot;</span><br></pre></td></tr></table></figure></li>
<li>Windows环境下：&#x2F;Users&#x2F;your_user&#x2F;.ssh删除known_hosts</li>
<li>git bash 在输入命令<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your@email.com&quot;</span><br></pre></td></tr></table></figure>
git bash提示：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Generating public&#x2F;private rsa key pair.</span><br><span class="line">Enter file in which to save the key (&#x2F;Users&#x2F;your_user_directory.ssh&#x2F;id_rsa):</span><br></pre></td></tr></table></figure>
根据提示保存到该目录，获得id_rsa和id_rsa.pub。id_rsa是私钥，id_rsa.pub是公钥，请注意保管用文本方式打开id_rsa.pub，获取其中SSH Key</li>
<li>打开<a href="https://github.com/%EF%BC%8C%E7%99%BB%E9%99%86%E4%BD%A0%E7%9A%84%E8%B4%A6%E6%88%B7%EF%BC%8C%E8%BF%9B%E5%85%A5ssh%E8%AE%BE%E7%BD%AE%EF%BC%8C%E7%82%B9%E5%87%BBnew">https://github.com/，登陆你的账户，进入ssh设置，点击new</a> SSH Key，将获得的Key粘贴</li>
<li>完成</li>
</ol>
<h1 id="Hexo博客框架">3. Hexo博客框架</h1><h2 id="Hexo简介">3.1. Hexo简介</h2><p>Hexo是一个简单、快速、强大的基于 Github Pages 的博客框架，支持Markdown格式，有众多优秀插件和主题。<br>github: <a href="https://github.com/hexojs/hexo">https://github.com/hexojs/hexo</a><br>Hexo中文官网： <a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p>
<h2 id="Hexo原理">3.2. Hexo原理</h2><p>github page只能存放静态文件，而博客需要多种动态内容。如果手动更新，非常不便。Hexo将这些文件全部放在本地。每次需要更新时，先使用MarkDown语言编辑要发布的文章。写完后调用Hexo命令来批量生成页面，最后将所有改动提交到github，是一种适合github page的框架。</p>
<h2 id="Hexo安装">3.3. Hexo安装</h2><p>注意本文所有cmd命令均使用git bash输入。<br>安装命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>

<h2 id="Hexo初始化">3.4. Hexo初始化</h2><p>在本地硬盘中找一个地方新建文件夹，例如我的D:\hexo，用于存放hexo生成的网页代码。在该目录中使用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<p>hexo会自动在该目录中创建文件，结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>
<h2 id="生成静态文件">3.5. 生成静态文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo generate (完整写法)</span><br><span class="line">hexo g        (缩写)</span><br></pre></td></tr></table></figure>
<p>根据目前目录中的文件，在public文件夹中生成html文件，用于提交到github</p>
<h2 id="本地测试">3.6. 本地测试</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo start  (完整写法)</span><br><span class="line">hexo s      (缩写)</span><br></pre></td></tr></table></figure>
<p>hexo会在本地调用4000端口开启本地服务器。如果端口被占用请自行调整端口分配。<br>启动后，就能直接在浏览器中看到Hexo的默认界面了，还有一篇hello world的初始文章</p>
<h2 id="部署到github">3.7. 部署到github</h2><h3 id="配置文件">3.7.1. 配置文件</h3><p>打开hexo根目录下配置文件_config.yml，在最后配置有关deploy的部分.注意冒号与属性直接的空格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:yourusername&#x2F;yourusername.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<h3 id="安装npm的git插件">3.7.2. 安装npm的git插件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure>
<h3 id="部署到github-1">3.7.3. 部署到github</h3><p>在git bash中使用命令来部署。注意：必须使用git bash，否则无法访问本地SSH Key文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo deploy (完整命令)</span><br><span class="line">hexo d      (缩写)</span><br></pre></td></tr></table></figure>
<p>经过一小段时间的等待，部署完成了！<br>查看github上的repo，如果已经出现了内容，那么说明部署成功<br>打开 <a href="http://yourusername.github.io/">http://yourusername.github.io/</a> ，就能看到你的网站了！<br>如何调整网站配置及主体，请期待Vol.2</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>在github使用hexo搭建博客记录Vol.2</title>
    <url>/2019/06/20/BuildRecord-Vol2/</url>
    <content><![CDATA[<p>参考资料：</p>
<ul>
<li>Hexo搭建独立博客全纪录（三）使用Hexo搭建博客: <a href="https://baoyuzhang.github.io/2017/05/12/%E3%80%90Hexo%E6%90%AD%E5%BB%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2%E5%85%A8%E7%BA%AA%E5%BD%95%E3%80%91%EF%BC%88%E4%B8%89%EF%BC%89%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/">链接</a></li>
<li>NexT主题的优化定制修改指南: <a href="https://blog.csdn.net/u012195214/article/details/79204088">链接</a></li>
<li>Next官方页面：<a href="https://github.com/theme-next">链接</a></li>
</ul>
<h1 id="Hexo使用">1. Hexo使用</h1><h2 id="页面配置">1.1. 页面配置</h2><p>hexo文件夹下的配置文件<code>_config.yml</code>为整个hexo的配置文件。首先第一段属性主要用于配置网站的整体信息，description和keywords用于SEO搜索引擎优化，可以暂时不管。<br><img src="/.xyz//config.png" alt="config"></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>title</td>
<td>网站标题</td>
</tr>
<tr>
<td>subtitle</td>
<td>网站副标题</td>
</tr>
<tr>
<td>description</td>
<td>网站描述</td>
</tr>
<tr>
<td>keywords</td>
<td>网站关键词</td>
</tr>
<tr>
<td>author</td>
<td>网站作者</td>
</tr>
<tr>
<td>language</td>
<td>网站使用的语言(中文为zh-CN)</td>
</tr>
<tr>
<td>timezone</td>
<td>网站时区，默认为电脑时区</td>
</tr>
</tbody></table>
<p>第二部分的配置有关网站的写作布局格式以及资源链接功能<br><img src="/.xyz//config2.png" alt="config2"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Writing</span><br><span class="line">new_post_name: :title.md    #新文章的名称</span><br><span class="line">default_layout: post    #默认的文章格式</span><br><span class="line">titlecase: false # Transform title into titlecase   #标题转换为首字母大写</span><br><span class="line">external_link: true # Open external links in new tab    #新标签中打开链接</span><br><span class="line">filename_case: 0    #文件名转换为（0）不变（1）小写（2）大写</span><br><span class="line">render_drafts: false    #显示草稿</span><br><span class="line">post_asset_folder: true #对每篇文章生成asset文件夹</span><br><span class="line">relative_link: false</span><br><span class="line">future: true    #显示上一篇与下一篇文章文章</span><br><span class="line">highlight:#代码块相关</span><br><span class="line">  enable: true          #允许使用代码块</span><br><span class="line">  line_number: true     #显示行号</span><br><span class="line">  auto_detect: false    #自动检测</span><br><span class="line">  tab_replace:          #tab替换</span><br></pre></td></tr></table></figure>

<h2 id="Hexo常用命令">1.2. Hexo常用命令</h2><p>常用命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo clean #清除当前生成的所有页面，用于配合generate重新生成，去除bug</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure>
<p>常用命令缩写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo n &#x3D;&#x3D; hexo new</span><br><span class="line">hexo g &#x3D;&#x3D; hexo generate</span><br><span class="line">hexo s &#x3D;&#x3D; hexo server</span><br><span class="line">hexo d &#x3D;&#x3D; hexo deploy</span><br></pre></td></tr></table></figure>
<p>组合命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s -g #生成并本地预览</span><br><span class="line">hexo d -g #生成并上传</span><br></pre></td></tr></table></figure>

<h2 id="新建页面">1.3. 新建页面</h2><p>执行<code>hexo new &#39;文章名&#39;</code>，hexo会帮我们在<code>..\hexo\source\_posts</code>下生成相关markdown文件,打开该文件就可以开始编辑博客了<br>其中的文件头有以下含义，注意每个属性冒号后都有空格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: #文章名</span><br><span class="line">date: 2019-06-20 19:41:17</span><br><span class="line">categories: #分类</span><br><span class="line">tags: #文章标签 使用[tag1,tag2,tag3]的形式，</span><br><span class="line">description: #该文章简介</span><br></pre></td></tr></table></figure>
<p>使用<code>hexo g</code>命令后，该markdown文件会在public文件夹中自动生成对应的html文件，之后会自动加入文章列表</p>
<h2 id="页面模板">1.4. 页面模板</h2><p>在hexo根目录下有scaffold文件夹。Hexo会根据scaffold中的markdown文件为模板来新建文章。使用<code>hexo new 文章名</code>命令时，默认按照post.md为模板</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123;title&#125;&#125;</span><br><span class="line">date: &#123;&#123;date&#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>例如，我想要默认生成的文件中加入categories这个属性，可以把这个模板改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123;title&#125;&#125;</span><br><span class="line">date: &#123;&#123;date&#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>同理，可以创建多个不同模板，使用<code>hexo new 模板名称 文章名</code>来调用不同模板</p>
<h2 id="插入图片">1.5. 插入图片</h2><h3 id="我的做法">1.5.1. 我的做法</h3><ol>
<li>首先，在hexo的<code>_config.yml</code>中将<code>post_asset_folder</code>设为true。这样每次创建新文章，hexo都会在source的post文件夹中创建同名的资源文件夹，用于存放图片等资源</li>
<li>在hexo根目录执行<code>npm install hexo-asset-image --save</code>，安装图片地址转换的插件</li>
<li>使用<code>hexo new XXX</code>生成文章时，在<code>source/_posts</code>中放入需要插入的图片</li>
<li>在文章的markdown文件中使用如下格式插入图片：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![你想输入的替代文字](xxxx&#x2F;图片名.jpg)</span><br></pre></td></tr></table></figure></li>
<li>检查生成的网页中是否成功</li>
</ol>
<h3 id="官方文档做法">1.5.2. 官方文档做法</h3><p>官网链接：<a href="https://hexo.io/zh-cn/docs/asset-folders.html">https://hexo.io/zh-cn/docs/asset-folders.html</a></p>
<blockquote>
<p>通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_path slug %&#125;</span><br><span class="line">&#123;% asset_img slug [title] %&#125;</span><br><span class="line">&#123;% asset_link slug [title] %&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 <img src="/.xyz//example.jpg"> ，它将 不会 出现在首页上。（但是它会在文章中按你期待的方式工作）<br>正确的引用图片方式是使用下列的标签插件而不是 markdown ：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img example.jpg This is an example image %&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过这种方式，图片将会同时出现在文章和主页以及归档页中。</p>
</blockquote>
<p>官方的做法需要在markdown文档中插入html标签，我个人认为这种方式并不好。所以我没有选择官方做法，而是继续采取markdown语句来插入。如果未来遇到无法插入的问题，会再尝试官方方法。</p>
<h1 id="Next主题">2. Next主题</h1><p>现在，你学会了Hexo的基本操作，但是你可能还觉得你的网站不够好看。怎么办呢？我们可以在github上寻找主题来美化我们的网站。<br>这里我使用的是github使用排名第一的Next主题。</p>
<h2 id="Next主题的安装">2.1. Next主题的安装</h2><h3 id="下载">2.1.1. 下载</h3><p>这里直接从github下载最新版本。如果这种方法不行，可以考虑下载release page中的zip解压到对应目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd hexo</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>
<h3 id="启用">2.1.2. 启用</h3><p>在hexo目录下的<code>_config.yml</code>中，将<code>theme</code>字段的值改为<code>next</code>。这样Hexo会直接调用themes文件夹下的next主题包<br><img src="/.xyz//next_config.png" alt="next_config"><br>接着使用<code>hexo clean</code>清除缓存，使用<code>hexo g</code>重新编译。可以看到主题已经生效，能够显示最基本的helloworld页面了</p>
<h2 id="Next配置">2.2. Next配置</h2><h3 id="主题设置">2.2.1. 主题设置</h3><p>Next提供了4个默认主题，在themes&#x2F;next&#x2F;_config.yml&#96;中搜索scheme关键字，可以看到如何配置。这里我选用了Pisces主题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Scheme Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Schemes</span><br><span class="line"># scheme: Muse</span><br><span class="line"># scheme: Mist</span><br><span class="line">scheme: Pisces</span><br><span class="line"># scheme: Gemini</span><br></pre></td></tr></table></figure>
<ul>
<li>Muse：默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</li>
<li>Mist：Muse 的紧凑版本，整洁有序的单栏外观</li>
<li>Pisces：双栏 Scheme，小家碧玉似的清新</li>
<li>Gemini：左侧网站信息及目录，块+片段结构布局</li>
</ul>
<h3 id="动态背景">2.2.2. 动态背景</h3><p>你经常在别人博客上看到并眼馋的动态背景！就是这个。<br>在<code>themes/next/_config.yml</code>中搜索canvas关键字，可以看到如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Canvas-nest</span><br><span class="line"># Dependencies: https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-canvas-nest</span><br><span class="line">canvas_nest:</span><br><span class="line">  enable: true</span><br><span class="line">  onmobile: true # display on mobile or not</span><br><span class="line">  color: &quot;0,0,255&quot; # RGB values, use &#39;,&#39; to separate</span><br><span class="line">  opacity: 0.5 # the opacity of line: 0~1</span><br><span class="line">  zIndex: -1 # z-index property of the background</span><br><span class="line">  count: 50 # the number of lines</span><br><span class="line"></span><br><span class="line"># JavaScript 3D library.</span><br><span class="line"># Dependencies: https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-three</span><br><span class="line"># three_waves</span><br><span class="line">three_waves: false</span><br><span class="line"># canvas_lines</span><br><span class="line">canvas_lines: false</span><br><span class="line"># canvas_sphere</span><br><span class="line">canvas_sphere: false</span><br></pre></td></tr></table></figure>
<p>设置为true则开启动态背景。在具体属性中可以设置线条的样式。建议将count减少，防止低配置电脑打开的卡顿。同时还提供了3种3D动态背景，喜欢的可以自己尝试</p>
<h3 id="当前浏览进度">2.2.3. 当前浏览进度</h3><p>修改<code>themes/next/_config.yml</code>， <code>scrollpercent</code> 值由 false 改为 true：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Scroll percent label in b2t button</span><br><span class="line">scrollpercent: true</span><br></pre></td></tr></table></figure>

<h3 id="文章“分类”与“标签”的设置">2.2.4. 文章“分类”与“标签”的设置</h3><p>使用<code>hexo new page categories</code>建立categories，其中自动生成了<code>index.md</code>，修改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2019-06-20 17:06:31</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>对tags也进行同样操作，这样在Next主题的主页下就能进入“分类”和“标签”页面了。之后的内容会自动生成，可以不用管</p>
<h3 id="“About”页面设置">2.2.5. “About”页面设置</h3><p>同理，使用<code>hexo new page about</code>来生成about页面，在index.md中可以编辑个人相关信息。</p>
<h3 id="字数统计功能">2.2.6. 字数统计功能</h3><p>参考页面<a href="https://github.com/theme-next/hexo-symbols-count-time">https://github.com/theme-next/hexo-symbols-count-time</a><br>新版本的Next主题中，插件重新整合，因此使用了新api。这里直接使用新api来进行字数统计</p>
<ol>
<li>安装<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure></li>
<li>在hexo根目录下的<code>_config.yml</code>中，添加如下代码来启用word count功能。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line"> symbols: true</span><br><span class="line"> time: true</span><br><span class="line"> total_symbols: true</span><br><span class="line"> total_time: true</span><br><span class="line"> exclude_codeblock: false</span><br></pre></td></tr></table></figure></li>
<li>在Next主题中寻找相关代码进行配置 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">    separated_meta: true</span><br><span class="line">    item_text_post: true</span><br><span class="line">    item_text_total: false</span><br><span class="line">    awl: 2</span><br><span class="line">    wpm: 275</span><br><span class="line">    suffix: mins.</span><br></pre></td></tr></table></figure>
 其中，<code>awl</code>和<code>wpm</code>的值请参阅官方文档进行配置。<br> 如果页面中字数统计的文字出现了乱码，请打开<code>theme/next/languages</code>文件夹对自己选用的语言进行查看并debug</li>
</ol>
<h1 id="最后的话">3. 最后的话</h1><p>Next还有许多优化手段，这里就不一一写出（其实我也不会）。大家有兴趣的可以自己再去研究</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>在SpringBoot中整合ElasticSearch</title>
    <url>/2023/09/14/ES-in-Spring/</url>
    <content><![CDATA[<h1 id="依赖及相关配置">1. 依赖及相关配置</h1><ol>
<li>在pom.xml中引入依赖<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>application.yml配置<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">elasticsearch:</span></span><br><span class="line">    <span class="attr">rest:</span></span><br><span class="line">      <span class="comment"># 如果是集群，用逗号隔开</span></span><br><span class="line">      <span class="attr">uris:</span> <span class="string">http://ip:port</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">xxx</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">yyy</span></span><br><span class="line">      <span class="attr">connection-timeout:</span> <span class="number">3000</span></span><br><span class="line">      <span class="attr">read-timeout:</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>注：在ES7.1.5版本后，使用RestHighLevelClient已经被标为过时并放弃，因此这里不再介绍。本文主要介绍使用ElasticsearchRestTemplate和使用ElasticsearchRepository的方法</p>
<h1 id="创建对应实体类">2. 创建对应实体类</h1><p>创建一个实体类，例子如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Document(indexName = &quot;file_record&quot;, shards = 2, replicas = 0)</span></span><br><span class="line"><span class="meta">@Setting(settingPath = &quot;ElasticSearch/settings.json&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileRecordESInfo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@Field(name = &quot;id&quot;, type = FieldType.Keyword)</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(name = &quot;task_uuid&quot;, type = FieldType.Keyword)</span></span><br><span class="line">    <span class="keyword">private</span> String taskUuid;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(name = &quot;file_name&quot;, type = FieldType.Text, analyzer = &quot;custom_analyzer&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(name = &quot;file_size&quot;, type = FieldType.Long, index = false)</span></span><br><span class="line">    <span class="keyword">private</span> Long fileSize;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(name = &quot;file_type&quot;, type = FieldType.Integer)</span></span><br><span class="line">    <span class="keyword">private</span> Integer fileType;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(name = &quot;file_create_time&quot;, type = FieldType.Date, format = DateFormat.epoch_millis)</span></span><br><span class="line">    <span class="keyword">private</span> Date fileCreateTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(name = &quot;tag_list&quot;, type = FieldType.Nested)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Tag&gt; tagList;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tag</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Field(name = &quot;tag_id&quot;, type = FieldType.Keyword)</span></span><br><span class="line">        <span class="keyword">private</span> String tagId;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Field(name = &quot;tag_name&quot;, type = FieldType.Keyword)</span></span><br><span class="line">        <span class="keyword">private</span> String tagName;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Field(name = &quot;tag_type&quot;, type = FieldType.Integer, index = false)</span></span><br><span class="line">        <span class="keyword">private</span> Integer tagType;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Field(name = &quot;tag_set_time&quot;, type = FieldType.Date, format = DateFormat.epoch_millis, index = false)</span></span><br><span class="line">        <span class="keyword">private</span> Date tagSetTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>@Document()注解可指定对应index，分片数量等</li>
<li>@Field()注解可指定字段在es索引中的名称及属性等，并指定是否需要被索引</li>
<li>注解中的字段属性、索引等值的选取，需仔细思考后赋值</li>
</ul>
<h1 id="使用ElasticsearchRepository">3. 使用ElasticsearchRepository</h1><p>ElasticsearchRepository接口封装了Document的CRUD操作。对于需要在es中操作的实体类，如果在application.yml中已经配置了<code>spring.elasticsearch</code>相关属性，则可以直接通过ElasticsearchRepository实现CRUD操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ESFileRecordRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">FileRecordESInfo</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// add other methods here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常见的可调用接口如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CrudRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line">    &lt;S extends T&gt; <span class="function">S <span class="title">save</span><span class="params">(S entity)</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;S extends T&gt; <span class="function">Iterable&lt;S&gt; <span class="title">saveAll</span><span class="params">(Iterable&lt;S&gt; entities)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Optional&lt;T&gt; <span class="title">findById</span><span class="params">(ID id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">existsById</span><span class="params">(ID id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterable&lt;T&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterable&lt;T&gt; <span class="title">findAllById</span><span class="params">(Iterable&lt;ID&gt; ids)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(ID id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(T entity)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAllById</span><span class="params">(Iterable&lt;? extends ID&gt; ids)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">(Iterable&lt;? extends T&gt; entities)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，我们可以这样调用。以下是调用批量保存的例子。其他方法的逻辑类似</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ESService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ESCollectRecordRepository esCollectRecordRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveRecordESInfoList</span><span class="params">(List&lt;RecordESInfo&gt; recordESInfoList)</span> </span>&#123;</span><br><span class="line">        esCollectRecordRepository.saveAll(recordESInfoList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意：">3.1. 注意：</h2><h3 id="索引初始化问题">3.1.1. 索引初始化问题</h3><p>如果连接到的ES中不存在对应实体类的索引，那么Spring会在启动时，将连接的所有ES实例中按照所有ElasticsearchRepository创建空索引。在实际生产环境中部署时，需要注意这点！</p>
<h3 id="查询问题">3.1.2. 查询问题</h3><p>该CURD接口无法使用复杂的查询，我们需要另外配置查询相关内容</p>
<h1 id="使用ElasticsearchRestTemplate">4. 使用ElasticsearchRestTemplate</h1><h2 id="引入">4.1. 引入</h2><p>如果在application.yml中已经配置了<code>spring.elasticsearch</code>相关属性。则可以在service中直接引入，例如批量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ESService</span></span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> ElasticsearchRestTemplate elasticsearchRestTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用">4.2. 使用</h2><p>elasticsearchRestTemplate中也对应了许多预定义操作，可以直接通过<code>org.springframework.data.elasticsearch.core</code>中的源码查看，这里仅介绍查询相关，其他功能不再赘述。</p>
<h2 id="查询">4.3. 查询</h2><p>在<code>org.springframework.data.elasticsearch.core.query</code>中实现了Query类及其子类。我们可以通过其中的类组装ES的查询参数，再通过<code>elasticsearchRestTemplate.search</code>进行es的查询。以下是一个分页查询及不同子类型查询的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PageVo&lt;RecordESInfo&gt; <span class="title">searchRecordESInfo</span><span class="params">(PageVo&lt;RecordESInfo&gt; pageVo, RecordQueryParam recordQueryParam)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建布尔查询构造器，对应ES中布尔查询（各个子句之间的逻辑关系是与的查询）</span></span><br><span class="line">        BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 根据recordQueryParam中的查询参数，给布尔查询中添加查询参数。</span></span><br><span class="line"><span class="comment">        * 以下是一些查询的列子</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// matchQuery类型查询，会走倒查索引</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(recordQueryParam.getFileNamePattern())) &#123;</span><br><span class="line">            boolQueryBuilder.must(QueryBuilders.matchQuery(<span class="string">&quot;file_name&quot;</span>, recordQueryParam.getFileNamePattern()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 时间类型查询</span></span><br><span class="line">        <span class="keyword">if</span> (recordQueryParam.getStartTime() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String startDate = String.valueOf(recordQueryParam.getStartTime().getTime());</span><br><span class="line">            boolQueryBuilder.must(QueryBuilders.rangeQuery(<span class="string">&quot;file_create_time&quot;</span>).gte(startDate));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (recordQueryParam.getEndTime() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String endDate = String.valueOf(recordQueryParam.getEndTime().getTime());</span><br><span class="line">            boolQueryBuilder.must(QueryBuilders.rangeQuery(<span class="string">&quot;file_create_time&quot;</span>).lte(endDate));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 完全匹配查询</span></span><br><span class="line">        <span class="keyword">if</span> (recordQueryParam.getFileType() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            boolQueryBuilder.must(QueryBuilders.termQuery(<span class="string">&quot;file_type&quot;</span>, recordQueryParam.getFileType()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nest类型查询，对应实体类中的子类</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(recordQueryParam.getTagId())) &#123;</span><br><span class="line">            boolQueryBuilder.must(QueryBuilders.nestedQuery(<span class="string">&quot;tag_list&quot;</span>,</span><br><span class="line">                    QueryBuilders.matchPhraseQuery(<span class="string">&quot;tag_list.tag_id&quot;</span>, recordQueryParam.getTagId()), ScoreMode.None));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同样是nest类型查询</span></span><br><span class="line">        <span class="comment">// 字符查询可通过使用wildcard进行类似MySQl的LIKE查询</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(recordQueryParam.getTagNamePattern())) &#123;</span><br><span class="line">            boolQueryBuilder.must(QueryBuilders.nestedQuery(<span class="string">&quot;tag_list&quot;</span>,</span><br><span class="line">                    QueryBuilders.wildcardQuery(<span class="string">&quot;tag_list.tag_name&quot;</span>, <span class="string">&quot;*&quot;</span> + recordQueryParam.getTagNamePattern() + <span class="string">&quot;*&quot;</span>), ScoreMode.None));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 NativeSearchQuery 对象并设置排序与分页参数</span></span><br><span class="line">        NativeSearchQuery searchQuery = <span class="keyword">new</span> NativeSearchQueryBuilder().withQuery(boolQueryBuilder)</span><br><span class="line">                .withSorts(SortBuilders.fieldSort(<span class="string">&quot;file_create_time&quot;</span>).order(SortOrder.DESC))</span><br><span class="line">                .withPageable(PageRequest.of(pageVo.getCurrent(), pageVo.getSize()))</span><br><span class="line">                .withTrackTotalHits(<span class="keyword">true</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行查询</span></span><br><span class="line">            SearchHits&lt;RecordESInfo&gt; searchHits = elasticsearchRestTemplate.search(searchQuery, RecordESInfo.class);</span><br><span class="line">            <span class="comment">// 获取查询中的结果及分页参数</span></span><br><span class="line">            <span class="keyword">if</span> (searchHits.getTotalHits() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                List&lt;RecordESInfo&gt; searchProductList = searchHits.stream().map(SearchHit::getContent).collect(Collectors.toList());</span><br><span class="line">                pageVo.setTotal(searchHits.getTotalHits());</span><br><span class="line">                pageVo.setPages((<span class="keyword">int</span>) Math.ceil((<span class="keyword">double</span>) pageVo.getTotal() / pageVo.getSize()));</span><br><span class="line">                pageVo.setRecords(searchProductList);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pageVo.setTotal(<span class="number">0L</span>);</span><br><span class="line">                pageVo.setPages(<span class="number">0</span>);</span><br><span class="line">                pageVo.setRecords(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// todo 处理查询中异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pageVo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>传入参数，调用searchRecordESInfo，即可完成一次分页查询</p>
<h1 id="自定义索引Setting">5. 自定义索引Setting</h1><ol>
<li>创建setting.json，放到resources目录下，用于存放配置<br>例如这里创建一个自定义分词器，放在resources目录中的ElasticSearch目录下<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	  <span class="attr">&quot;analysis&quot;</span>: &#123;</span><br><span class="line">	    <span class="attr">&quot;analyzer&quot;</span>: &#123;</span><br><span class="line">	      <span class="attr">&quot;url_analyzer&quot;</span>: &#123;</span><br><span class="line">	        <span class="attr">&quot;tokenizer&quot;</span>: <span class="string">&quot;standard&quot;</span>,</span><br><span class="line">	        <span class="attr">&quot;char_filter&quot;</span>: [</span><br><span class="line">	          <span class="string">&quot;url_char_filter&quot;</span></span><br><span class="line">	        ]</span><br><span class="line">	      &#125;</span><br><span class="line">	    &#125;,</span><br><span class="line">	    <span class="attr">&quot;char_filter&quot;</span>: &#123;</span><br><span class="line">	      <span class="attr">&quot;url_char_filter&quot;</span>: &#123;</span><br><span class="line">	        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;pattern_replace&quot;</span>,</span><br><span class="line">	        <span class="attr">&quot;pattern&quot;</span>: <span class="string">&quot;\\.&quot;</span>,</span><br><span class="line">	        <span class="attr">&quot;replacement&quot;</span>: <span class="string">&quot;-&quot;</span></span><br><span class="line">	      &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
<li>在对应ES的实体类上加入<code>@Setting</code>注解，填写对应路径。这里使用刚才第一步中创建的<code>ElasticSearch/setting.json</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Document(indexName = &quot;es_info&quot;)</span></span><br><span class="line"><span class="meta">@Setting(settingPath = &quot;ElasticSearch/settings.json&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ESInfo</span></span>&#123;</span><br><span class="line">    <span class="comment">// data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用类似如下语句创建索引<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">elasticsearchRestTemplate.indexOps(RecordESInfo.class).create(); <span class="comment">// 创建实体类对应索引</span></span><br><span class="line">elasticsearchRestTemplate.indexOps(RecordESInfo.class).putMapping(); <span class="comment">// 创建实体类对应索引mapping</span></span><br><span class="line">elasticsearchRestTemplate.indexOps(RecordESInfo.class).createSettings(); <span class="comment">// 创建对应索引设置</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>ElasticSearch</category>
      </categories>
  </entry>
  <entry>
    <title>ElasticSearch自定义分词器</title>
    <url>/2023/09/14/ES-custom-analyzer/</url>
    <content><![CDATA[<h1 id="分词器的组成">1. 分词器的组成</h1><p>ES中的分词器的概念包括以下三个部分</p>
<h2 id="字符过滤器-char-filter">1.1. 字符过滤器 char_filter</h2><p>作用：在tokenizer之前对原始文本进行处理，比如增加，删除，替换字符等</p>
<p>例子：</p>
<ul>
<li>去除HTML标签</li>
<li>将&amp;替换为and</li>
</ul>
<h2 id="分词器-tokenizer">1.2. 分词器 tokenizer</h2><p>作用：按照一定规律，将过滤后的原始文档切分为文本块</p>
<p>例子：</p>
<ul>
<li>根据下划线、空格、单词大小写等分割</li>
</ul>
<h2 id="分词过滤器-token-filter">1.3. 分词过滤器 token filter</h2><p>作用：针对tokenizer 输出的单词进行增删改等操作。可以修改、去除、增加等</p>
<p>例子：</p>
<ul>
<li>将单词全部小写化</li>
<li>去除无意义单词</li>
<li>增加词缀等</li>
</ul>
<h1 id="ES中的内置分词器">2. ES中的内置分词器</h1><p>ES中的默认分词器为：standard tokenizer, 是标准分词器。包含：</p>
<ol>
<li>standard token filter: 去掉无意义的标签, 如&lt;&gt;, &amp;, - 等.</li>
<li>lowercase token filter: 将所有字母转换为小写字母.</li>
<li>stop token filer(默认被禁用): 移除停用词, 比如”a”、”the”等.</li>
</ol>
<h1 id="制作自定义分词器">3. 制作自定义分词器</h1><h2 id="设置中的分词器格式">3.1. 设置中的分词器格式</h2><p>在ES中，设置自定义分词器需要对索引操作。具体json路径为settings-analysis。格式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;settings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;analysis&quot;</span>: &#123;           <span class="comment">// 分词设置</span></span><br><span class="line">      <span class="attr">&quot;char_filter&quot;</span>: &#123;&#125;,    <span class="comment">// char_filter  关键字 对应字符过滤器</span></span><br><span class="line">      <span class="attr">&quot;tokenizer&quot;</span>: &#123;&#125;,      <span class="comment">// tokenizer 关键字 对应分词器</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: &#123;&#125;,         <span class="comment">// filter  关键字 对应分词过滤器</span></span><br><span class="line">      <span class="attr">&quot;analyzer&quot;</span>: &#123;&#125;        <span class="comment">// analyzer 关键字 定义自定义分词器</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一个例子">3.2. 一个例子</h2><p>一下是一个自定义分词器的例子</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT test_index/_settings</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;analysis&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;char_filter&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;&amp;_to_and&quot;</span>: &#123;   <span class="comment">// 自定义&amp;_to_and过滤器</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;mapping&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;mappings&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;&amp; =&gt; and&quot;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;tokenizer&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;custom_tokenizer&quot;</span>: &#123; <span class="comment">// 自定义分词器，根据下划线、横线、斜线、点分词</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;pattern&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;pattern&quot;</span>: <span class="string">&quot;[/_\\-\\.]&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;filter&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;my_stopwords&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;stop&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;stopwords&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;the&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;a&quot;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;my_analyzer&quot;</span>: &#123; <span class="comment">// 自定义的分析器名称</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;custom&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;char_filter&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;html_strip&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;&amp;_to_and&quot;</span></span><br><span class="line">                ], <span class="comment">// 跳过HTML标签, 将&amp;符号转换为&quot;and&quot;</span></span><br><span class="line">                <span class="attr">&quot;tokenizer&quot;</span>: <span class="string">&quot;custom_tokenizer&quot;</span>, <span class="comment">// 自定义分词</span></span><br><span class="line">                <span class="attr">&quot;filter&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;lowercase&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;my_stopwords&quot;</span></span><br><span class="line">                ] <span class="comment">// 转换为小写</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用">4. 使用</h1><p>分词器有两种使用情景</p>
<ul>
<li>创建或更新文档时，会对文档进行分词</li>
<li>查询时，对查询语句中的关键词分词</li>
</ul>
<p>以下简单介绍了一些用法及操作</p>
<h2 id="创建索引时加入分词器">4.1. 创建索引时加入分词器</h2><p>在创建索引时，可直接指定在索引中加入分词器。</p>
<p>注意：</p>
<ul>
<li>加入分词器仅仅是在索引中添加分词器</li>
<li>如果某字段需要使用自定义分词器，则需要手动指定，否则使用默认分词器</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT index_name/_settings</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;analysis&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;char_filter&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;&amp;_to_and&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;mapping&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;mappings&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;&amp; =&gt; and&quot;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;filter&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;my_stopwords&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;stop&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;stopwords&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;the&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;a&quot;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;my_analyzer&quot;</span>: &#123; <span class="comment">// 自定义的分析器名称</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;custom&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;char_filter&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;html_strip&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;&amp;_to_and&quot;</span></span><br><span class="line">                ], <span class="comment">// 跳过HTML标签, 将&amp;符号转换为&quot;and&quot;</span></span><br><span class="line">                <span class="attr">&quot;tokenizer&quot;</span>: <span class="string">&quot;standard&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;filter&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;lowercase&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;my_stopwords&quot;</span></span><br><span class="line">                ] <span class="comment">// 转换为小写</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;doc&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;my_text&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;my_analyzer&quot;</span>, <span class="comment">// my_text字段使用my_analyzer分词器</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改索引中的分词器">4.2. 修改索引中的分词器</h2><p>在ES中如果想修改当前索引的分词器。必须先关闭索引, 添加完成后, 再及时打开索引进行搜索等操作, 否则将出现错误。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关闭索引:</span></span><br><span class="line">POST index_name/_close</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启用English停用词token filter</span></span><br><span class="line">PUT index_name/_settings</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;analysis&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span>: &#123;               <span class="comment">// 关键字</span></span><br><span class="line">            <span class="attr">&quot;my_analyzer&quot;</span>: &#123;        <span class="comment">// 自定义的分词器</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;standard&quot;</span>, <span class="comment">//分词器类型standard</span></span><br><span class="line">                <span class="attr">&quot;stopwords&quot;</span>: <span class="string">&quot;_english_&quot;</span> <span class="comment">//standard分词器的参数，默认的stopwords是\_none_</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新打开索引:</span></span><br><span class="line">POST index_name/_open</span><br></pre></td></tr></table></figure>

<h2 id="测试ES自带分词器效果">4.3. 测试ES自带分词器效果</h2><p>测试自带分词器时，可直接使用_analyze命令，不指定索引</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET _analyze			// ES引擎中已有standard分词器, 所以可以不指定index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;standard&quot;</span>, </span><br><span class="line">    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;There-is &amp; a DOG&lt;br/&gt; in house&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试自定义分词器效果">4.4. 测试自定义分词器效果</h2><p>在测试自定义分词器时，必须指定索引以及索引中使用了自定义分词器的字段，才能使用索引中的自定义分词器</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST test/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;my_text&quot;</span>,    <span class="comment">// my_text字段使用my_analyzer分词器</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: [<span class="string">&quot;The test message.&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指定查询时使用哪个分词器">4.5. 指定查询时使用哪个分词器</h2><ul>
<li>查询时通过analyzer指定分词器<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET test_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;lin&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;standard&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="创建索引时指定search-analyzer">4.6. 创建索引时指定search_analyzer</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT test_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;doc&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;title&quot;</span>:&#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;whitespace&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;search_analyzer&quot;</span>: <span class="string">&quot;standard&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结">5. 总结</h1><p>本文简单介绍了ES中分词器的基本概念、构造及使用方法，并给出了一些简单的例子。</p>
<p>如果对分词器有进一步的学习需要，可以参考ElasticSearch官网。如果需求复杂的分词器，也可参考<a href="https://github.com/medcl/elasticsearch-analysis-ik">IK分词器 github页面</a></p>
<p>注：本文参考来源：</p>
<ul>
<li>作者本人实践</li>
<li><a href="https://www.cnblogs.com/shoufeng/p/10562746.html">Elasticsearch如何定制分词器 (自定义分词策略) </a></li>
<li><a href="https://www.cnblogs.com/xiaobaozi-95/p/9328948.html">es的分词器analyzer </a></li>
</ul>
]]></content>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker常用命令介绍</title>
    <url>/2021/09/06/Docker-intro/</url>
    <content><![CDATA[<h1 id="Docker主程序管理">1. Docker主程序管理</h1><h2 id="设置Docker自启动">1.1. 设置Docker自启动</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>

<h2 id="Docker的启动停止重启">1.2. Docker的启动停止重启</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重启Docker服务</span></span><br><span class="line">service docker restart</span><br><span class="line"><span class="comment"># 停止Docker服务</span></span><br><span class="line">service docker stop</span><br><span class="line"><span class="comment"># 启动Docker服务</span></span><br><span class="line">service docker start</span><br></pre></td></tr></table></figure>

<h1 id="Docker镜像管理">2. Docker镜像管理</h1><h2 id="搜索">2.1. 搜索</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search &lt;image&gt;</span><br></pre></td></tr></table></figure>
<p>用于搜索线上镜像仓库中的镜像。会显示出所有名称中带有<image>的镜像</image></p>
<h2 id="拉取镜像">2.2. 拉取镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull &lt;image&gt;</span><br></pre></td></tr></table></figure>

<h2 id="查看本地镜像">2.3. 查看本地镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出本地镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 列出本地镜像（包括历史记录）</span></span><br><span class="line">docker images -a</span><br><span class="line"><span class="comment"># 删除本地镜像</span></span><br><span class="line">docker rmi &lt;image ID&gt;</span><br></pre></td></tr></table></figure>

<h1 id="Docker容器管理">3. Docker容器管理</h1><h2 id="创建容器">3.1. 创建容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]  </span><br><span class="line"> </span><br><span class="line">  -d, --detach=<span class="literal">false</span>         指定容器运行于前台还是后台，默认为<span class="literal">false</span>   </span><br><span class="line">  -i, --interactive=<span class="literal">false</span>   打开STDIN，用于控制台交互  </span><br><span class="line">  -t, --tty=<span class="literal">false</span>            分配tty设备，该可以支持终端登录，默认为<span class="literal">false</span>  </span><br><span class="line">  -u, --user=<span class="string">&quot;&quot;</span>              指定容器的用户  </span><br><span class="line">  -a, --attach=[]            标准输入输出流和错误信息（必须是以非docker run -d启动的容器）</span><br><span class="line">  -w, --workdir=<span class="string">&quot;&quot;</span>           指定容器的工作目录 </span><br><span class="line">  -c, --cpu-shares=0        设置容器CPU权重，在CPU共享场景使用  </span><br><span class="line">  -e, --env=[]               指定环境变量，容器中可以使用该环境变量  </span><br><span class="line">  -m, --memory=<span class="string">&quot;&quot;</span>            指定容器的内存上限  </span><br><span class="line">  -P, --publish-all=<span class="literal">false</span>    指定容器暴露的端口  </span><br><span class="line">  -p, --publish=[]           指定容器暴露的端口 </span><br><span class="line">  -h, --hostname=<span class="string">&quot;&quot;</span>          指定容器的主机名  </span><br><span class="line">  -v, --volume=[]            给容器挂载存储卷，挂载到容器的某个目录  </span><br><span class="line">  --volumes-from=[]          给容器挂载其他容器上的卷，挂载到容器的某个目录</span><br><span class="line">  --cap-add=[]               添加权限，权限清单详见：http://linux.die.net/man/7/capabilities  </span><br><span class="line">  --cap-drop=[]              删除权限，权限清单详见：http://linux.die.net/man/7/capabilities  </span><br><span class="line">  --cidfile=<span class="string">&quot;&quot;</span>               运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法  </span><br><span class="line">  --cpuset=<span class="string">&quot;&quot;</span>                设置容器可以使用哪些CPU，此参数可以用来容器独占CPU  </span><br><span class="line">  --device=[]                添加主机设备给容器，相当于设备直通  </span><br><span class="line">  --dns=[]                   指定容器的dns服务器  </span><br><span class="line">  --dns-search=[]            指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件  </span><br><span class="line">  --entrypoint=<span class="string">&quot;&quot;</span>            覆盖image的入口点  </span><br><span class="line">  --env-file=[]              指定环境变量文件，文件格式为每行一个环境变量  </span><br><span class="line">  --expose=[]                指定容器暴露的端口，即修改镜像的暴露端口  </span><br><span class="line">  --link=[]                  指定容器间的关联，使用其他容器的IP、env等信息  </span><br><span class="line">  --lxc-conf=[]              指定容器的配置文件，只有在指定--exec-driver=lxc时使用  </span><br><span class="line">  --name=<span class="string">&quot;&quot;</span>                  指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字  </span><br><span class="line">  --net=<span class="string">&quot;bridge&quot;</span>             容器网络设置:</span><br><span class="line">                                bridge 使用docker daemon指定的网桥     </span><br><span class="line">                                host     //容器使用主机的网络  </span><br><span class="line">                                container:NAME_or_ID  &gt;//使用其他容器的网路，共享IP和PORT等网络资源  </span><br><span class="line">                                none 容器使用自己的网络（类似--net=bridge），但是不进行配置 </span><br><span class="line">  --privileged=<span class="literal">false</span>         指定容器是否为特权容器，特权容器拥有所有的capabilities  </span><br><span class="line">  --restart=<span class="string">&quot;no&quot;</span>             指定容器停止后的重启策略:</span><br><span class="line">                                no：容器退出时不重启  </span><br><span class="line">                                on-failure：容器故障退出（返回值非零）时重启 </span><br><span class="line">                                always：容器退出时总是重启  </span><br><span class="line">  --rm=<span class="literal">false</span>                 指定容器停止后自动删除容器(不支持以docker run -d启动的容器)  </span><br><span class="line">  --sig-proxy=<span class="literal">true</span>           设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理 </span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Usage:  docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">Run a command in a new container</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --add-host list                  Add a custom host-to-IP mapping (host:ip)</span><br><span class="line">  -a, --attach list                    Attach to STDIN, STDOUT or STDERR</span><br><span class="line">      --blkio-weight uint16            Block IO (relative weight), between 10 and 1000, or 0 to disable (default 0)</span><br><span class="line">      --blkio-weight-device list       Block IO weight (relative device weight) (default [])</span><br><span class="line">      --cap-add list                   Add Linux capabilities</span><br><span class="line">      --cap-drop list                  Drop Linux capabilities</span><br><span class="line">      --cgroup-parent string           Optional parent cgroup for the container</span><br><span class="line">      --cgroupns string                Cgroup namespace to use (host|private)</span><br><span class="line">                                       &#x27;host&#x27;:    Run the container in the Docker host&#x27;s cgroup namespace</span><br><span class="line">                                       &#x27;private&#x27;: Run the container in its own private cgroup namespace</span><br><span class="line">                                       &#x27;&#x27;:        Use the cgroup namespace as configured by the</span><br><span class="line">                                                  default-cgroupns-mode option on the daemon (default)</span><br><span class="line">      --cidfile string                 Write the container ID to the file</span><br><span class="line">      --cpu-period int                 Limit CPU CFS (Completely Fair Scheduler) period</span><br><span class="line">      --cpu-quota int                  Limit CPU CFS (Completely Fair Scheduler) quota</span><br><span class="line">      --cpu-rt-period int              Limit CPU real-time period in microseconds</span><br><span class="line">      --cpu-rt-runtime int             Limit CPU real-time runtime in microseconds</span><br><span class="line">  -c, --cpu-shares int                 CPU shares (relative weight)</span><br><span class="line">      --cpus decimal                   Number of CPUs</span><br><span class="line">      --cpuset-cpus string             CPUs in which to allow execution (0-3, 0,1)</span><br><span class="line">      --cpuset-mems string             MEMs in which to allow execution (0-3, 0,1)</span><br><span class="line">  -d, --detach                         Run container in background and print container ID</span><br><span class="line">      --detach-keys string             Override the key sequence for detaching a container</span><br><span class="line">      --device list                    Add a host device to the container</span><br><span class="line">      --device-cgroup-rule list        Add a rule to the cgroup allowed devices list</span><br><span class="line">      --device-read-bps list           Limit read rate (bytes per second) from a device (default [])</span><br><span class="line">      --device-read-iops list          Limit read rate (IO per second) from a device (default [])</span><br><span class="line">      --device-write-bps list          Limit write rate (bytes per second) to a device (default [])</span><br><span class="line">      --device-write-iops list         Limit write rate (IO per second) to a device (default [])</span><br><span class="line">      --disable-content-trust          Skip image verification (default true)</span><br><span class="line">      --dns list                       Set custom DNS servers</span><br><span class="line">      --dns-option list                Set DNS options</span><br><span class="line">      --dns-search list                Set custom DNS search domains</span><br><span class="line">      --domainname string              Container NIS domain name</span><br><span class="line">      --entrypoint string              Overwrite the default ENTRYPOINT of the image</span><br><span class="line">  -e, --env list                       Set environment variables</span><br><span class="line">      --env-file list                  Read in a file of environment variables</span><br><span class="line">      --expose list                    Expose a port or a range of ports</span><br><span class="line">      --gpus gpu-request               GPU devices to add to the container (&#x27;all&#x27; to pass all GPUs)</span><br><span class="line">      --group-add list                 Add additional groups to join</span><br><span class="line">      --health-cmd string              Command to run to check health</span><br><span class="line">      --health-interval duration       Time between running the check (ms|s|m|h) (default 0s)</span><br><span class="line">      --health-retries int             Consecutive failures needed to report unhealthy</span><br><span class="line">      --health-start-period duration   Start period for the container to initialize before starting health-retries countdown (ms|s|m|h) (default 0s)</span><br><span class="line">      --health-timeout duration        Maximum time to allow one check to run (ms|s|m|h) (default 0s)</span><br><span class="line">      --help                           Print usage</span><br><span class="line">  -h, --hostname string                Container host name</span><br><span class="line">      --init                           Run an init inside the container that forwards signals and reaps processes</span><br><span class="line">  -i, --interactive                    Keep STDIN open even if not attached</span><br><span class="line">      --ip string                      IPv4 address (e.g., 172.30.100.104)</span><br><span class="line">      --ip6 string                     IPv6 address (e.g., 2001:db8::33)</span><br><span class="line">      --ipc string                     IPC mode to use</span><br><span class="line">      --isolation string               Container isolation technology</span><br><span class="line">      --kernel-memory bytes            Kernel memory limit</span><br><span class="line">  -l, --label list                     Set meta data on a container</span><br><span class="line">      --label-file list                Read in a line delimited file of labels</span><br><span class="line">      --link list                      Add link to another container</span><br><span class="line">      --link-local-ip list             Container IPv4/IPv6 link-local addresses</span><br><span class="line">      --log-driver string              Logging driver for the container</span><br><span class="line">      --log-opt list                   Log driver options</span><br><span class="line">      --mac-address string             Container MAC address (e.g., 92:d0:c6:0a:29:33)</span><br><span class="line">  -m, --memory bytes                   Memory limit</span><br><span class="line">      --memory-reservation bytes       Memory soft limit</span><br><span class="line">      --memory-swap bytes              Swap limit equal to memory plus swap: &#x27;-1&#x27; to enable unlimited swap</span><br><span class="line">      --memory-swappiness int          Tune container memory swappiness (0 to 100) (default -1)</span><br><span class="line">      --mount mount                    Attach a filesystem mount to the container</span><br><span class="line">      --name string                    Assign a name to the container</span><br><span class="line">      --network network                Connect a container to a network</span><br><span class="line">      --network-alias list             Add network-scoped alias for the container</span><br><span class="line">      --no-healthcheck                 Disable any container-specified HEALTHCHECK</span><br><span class="line">      --oom-kill-disable               Disable OOM Killer</span><br><span class="line">      --oom-score-adj int              Tune host&#x27;s OOM preferences (-1000 to 1000)</span><br><span class="line">      --pid string                     PID namespace to use</span><br><span class="line">      --pids-limit int                 Tune container pids limit (set -1 for unlimited)</span><br><span class="line">      --platform string                Set platform if server is multi-platform capable</span><br><span class="line">      --privileged                     Give extended privileges to this container</span><br><span class="line">  -p, --publish list                   Publish a container&#x27;s port(s) to the host</span><br><span class="line">  -P, --publish-all                    Publish all exposed ports to random ports</span><br><span class="line">      --pull string                    Pull image before running (&quot;always&quot;|&quot;missing&quot;|&quot;never&quot;) (default &quot;missing&quot;)</span><br><span class="line">      --read-only                      Mount the container&#x27;s root filesystem as read only</span><br><span class="line">      --restart string                 Restart policy to apply when a container exits (default &quot;no&quot;)</span><br><span class="line">      --rm                             Automatically remove the container when it exits</span><br><span class="line">      --runtime string                 Runtime to use for this container</span><br><span class="line">      --security-opt list              Security Options</span><br><span class="line">      --shm-size bytes                 Size of /dev/shm</span><br><span class="line">      --sig-proxy                      Proxy received signals to the process (default true)</span><br><span class="line">      --stop-signal string             Signal to stop a container (default &quot;SIGTERM&quot;)</span><br><span class="line">      --stop-timeout int               Timeout (in seconds) to stop a container</span><br><span class="line">      --storage-opt list               Storage driver options for the container</span><br><span class="line">      --sysctl map                     Sysctl options (default map[])</span><br><span class="line">      --tmpfs list                     Mount a tmpfs directory</span><br><span class="line">  -t, --tty                            Allocate a pseudo-TTY</span><br><span class="line">      --ulimit ulimit                  Ulimit options (default [])</span><br><span class="line">  -u, --user string                    Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;])</span><br><span class="line">      --userns string                  User namespace to use</span><br><span class="line">      --uts string                     UTS namespace to use</span><br><span class="line">  -v, --volume list                    Bind mount a volume</span><br><span class="line">      --volume-driver string           Optional volume driver for the container</span><br><span class="line">      --volumes-from list              Mount volumes from the specified container(s)</span><br><span class="line">  -w, --workdir string                 Working directory inside the container</span><br></pre></td></tr></table></figure>

<h3 id="实例">3.1.1. 实例</h3><p>运行一个spring项目，并替换其中的启动项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -v /home/user/application_job.properties:/home/user/<span class="built_in">local</span>/application.properties -p 8085:8085 -e <span class="string">&quot;APP_OPTS=-Dspring.config.additional-location=/home/user/local/application.properties&quot;</span> -d lbs-automation-job:latest</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li>-v选项：将宿主机的<code>/home/user/application.properties</code>文件映射到容器中的<code>/home/user/local/application.properties</code>文件夹中，从而使容器能加载配置文件</li>
<li>-p选项：将宿主机的8085端口映射到容器的8085端口</li>
<li>-e选项：给容器配置环境变量。这里我们将<code>spring.config.additional-location=/home/user/local/application.properties</code>配置为环境变量，使spring项目加载挂载到容器中的对应配置项</li>
<li>-d选项：指定后台运行</li>
<li>镜像名称：指定容器镜像</li>
</ul>
<h2 id="查看Docker容器">3.2. 查看Docker容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看正在运行的容器</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">CONTAINER ID   IMAGE                                      COMMAND                  CREATED         STATUS         PORTS                                       NAMES</span><br><span class="line">abc37d87cf03   lbs-devops/xp-lbs-automation-case:latest   &quot;sh -c &#x27;java $APP_OP…&quot;   4 minutes ago   Up 4 minutes   0.0.0.0:8082-&gt;8082/tcp, :::8082-&gt;8082/tcp   compassionate_ptolemy</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看所有容器（包括已退出）</span></span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONTAINER ID   IMAGE                                      COMMAND                  CREATED         STATUS                     PORTS                                       NAMES</span><br><span class="line">abc37d87cf03   lbs-devops&#x2F;xp-lbs-automation-case:latest   &quot;sh -c &#39;java $APP_OP…&quot;   5 minutes ago   Up 4 minutes               0.0.0.0:8082-&gt;8082&#x2F;tcp, :::8082-&gt;8082&#x2F;tcp   compassionate_ptolemy</span><br><span class="line">51906f38b230   atxserver2_web                             &quot;bash scripts&#x2F;wait-f…&quot;   6 weeks ago     Exited (255) 3 weeks ago   0.0.0.0:4000-&gt;4000&#x2F;tcp, :::4000-&gt;4000&#x2F;tcp   atxserver2_web_1</span><br></pre></td></tr></table></figure>

<h2 id="容器管理">3.3. 容器管理</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动容器</span></span><br><span class="line">docker start &lt;ContainerId(或者name)&gt;</span><br><span class="line"><span class="comment">#停止容器</span></span><br><span class="line">docker stop &lt;ContainerId(或者name)&gt;</span><br><span class="line"><span class="comment">#重启容器</span></span><br><span class="line">docker restart &lt;ContainerId(或者name)&gt;</span><br><span class="line"><span class="comment">#删除容器</span></span><br><span class="line">docker rm &lt;ContainerId(或者name)&gt;</span><br><span class="line"><span class="comment">#删除所有容器</span></span><br><span class="line">docker rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure>

<h2 id="操作Docker容器">3.4. 操作Docker容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -i &lt;ContainerId&gt; &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure>
<p>在容器中执行command命令，更多用法可以使用<code>exec --help</code>查看</p>
<h2 id="查看容器日志">3.5. 查看容器日志</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接查看</span></span><br><span class="line">docker logs &lt;ContainerId&gt;</span><br><span class="line"><span class="comment"># 查看最后n行</span></span><br><span class="line">docker logs -f -t --tail &lt;行数&gt; &lt;containerId&gt;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Docker与K8s中的ElasticSearch持久化</title>
    <url>/2022/06/13/Elasticsearch-Docker-k8s/</url>
    <content><![CDATA[<p>容器中启动的ElasticSearch实例，如果不配置持久化，就会在重启时丢失数据。借助最近将一个实例迁移到k8s中的机会简单记录一下如何在容器中持久化ElasticSearch实例。同时记录一下ik分词器如何安装到容器中</p>
<h1 id="容器中的es">1. 容器中的es</h1><h2 id="Docker拉取ES">1.1. Docker拉取ES</h2><ol>
<li>搜索镜像：打开 DockerHub 官网 <a href="https://hub.docker.com/%E7%84%B6%E5%90%8E%E6%90%9C%E7%B4%A2">https://hub.docker.com/然后搜索</a> Elasticsearch 镜像</li>
<li>命令<code>docker pull elasticsearch: x.x.x</code>其中x.x.x为需要的版本</li>
</ol>
<h2 id="容器中的es-1">1.2. 容器中的es</h2><p>尝试启动一个es的docker容器，并使用<code>docker --it</code>命令<br>可以看到容器的默认执行目录为<code>/usr/share/elasticsearch</code>。其中有如下文件夹与文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LICENSE.txt  NOTICE.txt  README.textile  bin  config  data  lib  logs  modules  plugins</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>config文件夹为默认配置存放路径</li>
<li>data为数据持久化路径</li>
<li>plugins为插件安装路径</li>
</ul>
<p>因为我们的目标是配置持久化的es，并且安装ik分词。因此这三个目录都需要进行挂载来防止容器重启后数据丢失</p>
<h1 id="k8s中的ES持久化">2. k8s中的ES持久化</h1><h2 id="存储卷与配置">2.1. 存储卷与配置</h2><ol>
<li>先临时启动一个容器，用于配置</li>
<li>创建一个存储卷，挂载并映射到<code>/usr/share/elasticsearch/data</code>，作为数据文件夹持久化用</li>
<li>创建一个存储卷，挂载并映射到<code>/usr/share/elasticsearch/plugins</code>，作为插件文件夹持久化用</li>
<li>创建一个存储卷，挂载并映射到<code>/usr/share/elasticsearch/myconfig</code>，作为配置文件夹持久化用</li>
<li>进入容器中，执行命令<code>cp -r ./config、。 /myconfig</code>将默认的配置项复制到<code>/myconfig</code>中</li>
<li>修改<code>/myconfig</code>文件夹中的各种配置文件，用于es的配置。参考默认的<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/settings.html">ES文档</a></li>
</ol>
<h2 id="启动容器">2.2. 启动容器</h2><p>给容器配置环境变量<code>ES_PATH_CONF=&quot;/usr/share/elasticsearch/myconfig&quot;</code>，容器就会在启动时自动去加载挂载的<code>/myconfig</code>文件夹中的配置文件</p>
<h2 id="安装Ik-分词插件">2.3. 安装Ik-分词插件</h2><ol>
<li>进入容器，来到目录<code>/usr/share/elasticsearch/pulgins</code></li>
<li>创建目录<code>mkdir /usr/share/elasticsearch/plugins/ik</code></li>
<li><code>cd mkdir /usr/share/elasticsearch/plugins/analysis-ik</code></li>
<li><code>wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/vx.x.x/elasticsearch-analysis-ik-x.x.x.zip</code>,将其中的x.x.x替换为需要的版本</li>
<li><code>unzip elasticsearch-analysis-ik-x.x.x.zip</code></li>
<li>删除容器并重启</li>
</ol>
<p>注：这里最好不要用<code>/bin/elasticsearch-plugin install</code>命令进行安装。否则可能会将ik分词器的配置文件安装到默认的<code>/config</code>文件夹中，导致容器重启后配置失效丢失</p>
<h2 id="验证">2.4. 验证</h2><p>按照上面的挂载方式修改完成后，打开<code>http://ipaddress/_cluster/health?pretty</code>查看节点是否都启动成功。打开<code>http://ipaddress/_analyze</code>查看分词器是否配置正确</p>
<h1 id="docker中的es持久化">3. docker中的es持久化</h1><h2 id="方式1">3.1. 方式1</h2><p>可以参考上面的方式，将config文件夹中的文件复制到&#x2F;myconfig中。然后使用如下命令启动。之后参考上面的方式按照ik分词器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name elasticsearch -p 9200:9200  -p 9300:9300 \</span><br><span class="line"> -e ES_PATH_CONF=<span class="string">&quot;/usr/share/elasticsearch/myconfig&quot;</span> \</span><br><span class="line"> -v /home/temp/elasticsearch/myconfig:/usr/share/elasticsearch/myconfig \</span><br><span class="line"> -v /home/temp/elasticsearch/data:/usr/share/elasticsearch/data \</span><br><span class="line"> -v /home/temp/elasticsearch/plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line"> -d elasticsearch:x.x.x</span><br></pre></td></tr></table></figure>

<h2 id="方式2">3.2. 方式2</h2><p>可以直接将本地的配置文件挂载到docker的es中，如下。这样可以减少一个挂载目录。之后参考上面的方式按照ik分词器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name elasticsearch -p 9200:9200  -p 9300:9300 \</span><br><span class="line"> -v /home/temp/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \</span><br><span class="line"> -v /home/temp/elasticsearch/data:/usr/share/elasticsearch/data \</span><br><span class="line"> -v /home/temp/elasticsearch/plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line"> -d elasticsearch:x.x.x</span><br></pre></td></tr></table></figure>

<h2 id="验证-1">3.3. 验证</h2><p>方式同上，略</p>
]]></content>
      <categories>
        <category>ElasticSearch</category>
      </categories>
  </entry>
  <entry>
    <title>hexo多终端同步配置</title>
    <url>/2020/04/02/Hexo-Sync/</url>
    <content><![CDATA[<p>有时，我们在笔记本上编辑了博客，并发布到了网上。但回家后，想用家里的台式进行修改，却发现电脑上没有对应文件，可以说是非常难受。这里，我们可以将整个项目上传到github。这样，每次打开不同电脑，只需要进行简单的git pull命令，就能把文件同步下来，进行多终端无缝操作。</p>
<p>参考资料：</p>
<ul>
<li>使用hexo，如果换了电脑怎么更新博客？:<a href="https://www.zhihu.com/question/21193762">链接</a></li>
<li>hexo教程:基本配置+更换主题+多终端工作+coding page部署分流(2):<a href="http://fangzh.top/2018/2018090715/">链接</a></li>
</ul>
<h1 id="原理">1. 原理</h1><p>首先我们需要知道，我们使用<code>hexo deploy</code>传到github上的仅仅是hexo编译完成的博客页面。因此github上储存的不是源文件，我们无法使用这些文件进行有效的编辑来修改或重新生成博客。因此我们需要想办法将原始文件传到github上。实现方法十分简单，在git中创建一个新分支，将hexo的源文件传到该分支即可</p>
<h1 id="创建并上传分支">2. 创建并上传分支</h1><p>首先，hexo默认deploy的文件存放在这个repo的master分支中，因此我们创建一个新分支。这里命名为hexo分支。然后在该repo的setting中，将hexo分支设为默认分支。这样每次同步时自动同步到hexo分支，而<code>hexo deploy</code>自动部署到master分支，节省操作。<br><img src="/.xyz//../Hexo-Sync/git_branch_setting.png" alt="config2"></p>
<p>在本地，使用git命令将新分支clone到本地。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;username&#x2F;username.github.io</span><br></pre></td></tr></table></figure>

<p>接下来进行一些暴力操作，将新分支文件夹中除了<code>.git</code>文件夹的所有文件删除，将原hexo文件夹的除了<code>.git</code>文件夹的所有文件移动到新分支文件夹。同时，检查并确保<code>.gitignore</code>文件中内容如下。这些文件包含npm安装在本地的插件等，不需要被上传到git。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules&#x2F;</span><br><span class="line">public&#x2F;</span><br><span class="line">.deploy*&#x2F;</span><br></pre></td></tr></table></figure>

<p>注意，如果你之前克隆过theme中的主题文件，那么应该把主题文件中的.git文件夹删掉，因为git不能嵌套上传。建议显示隐藏文件，检查一下，否则上传的时候会出错，导致你的主题文件无法上传，这样你的配置在别的电脑上就用不了了。</p>
<p>最后使用如下命令push分支。可以到github页面检查一下成果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit –m &quot;add branch&quot;</span><br><span class="line">git push </span><br></pre></td></tr></table></figure>

<h1 id="新电脑配置">3. 新电脑配置</h1><p>首先在新电脑上配置环境。安装git，node.js, npm</p>
<ul>
<li>设置git全局邮箱和用户名<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;yourgithubname&quot;</span><br><span class="line">git config --global user.email &quot;yourgithubemail&quot;</span><br></pre></td></tr></table></figure></li>
<li>设置SSH key<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail&quot;</span><br><span class="line">#生成后填到github和coding上（有coding平台的话）</span><br><span class="line">#验证是否成功</span><br><span class="line">ssh -T git@github.com</span><br><span class="line">ssh -T git@git.coding.net #(有coding平台的话)</span><br></pre></td></tr></table></figure></li>
<li>安装hexo</li>
<li>npm install hexo-cli -g</li>
</ul>
<p>在任意文件夹下，clone repo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;username&#x2F;username.github.io</span><br></pre></td></tr></table></figure>
<p>进入文件夹，使用npm安装插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd name.github.io</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>生成hexo，测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>之后就可以正常使用了</p>
<h1 id="使用事项">4. 使用事项</h1><p>每次完成一篇博文，都记得要使用<code>hexo d</code>和<code>git push</code>将两个分支都更新。这样在另一台终端操作时，只需要进行<code>git pull</code>就ok了</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo-VPS</title>
    <url>/2020/09/12/Hexo-VPS/</url>
    <content><![CDATA[<p>最近心血来潮，决定将原本托管在github的hexo静态页面搬运到vps上，这里记录一下如何实现。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://www.xiaoweihuang.me/2018/11/05/deploy-hexo-to-vps/">https://www.xiaoweihuang.me/2018/11/05/deploy-hexo-to-vps/</a></li>
<li><a href="https://www.cnblogs.com/morethink/p/10867173.html">https://www.cnblogs.com/morethink/p/10867173.html</a></li>
</ul>
<h1 id="本地SSH配置">1. 本地SSH配置</h1><p>Hexo部署是通过git来完成的，而git又是基于ssh连接的，所以需要在本地和服务端进行ssh相关配置。</p>
<p>如果之前没有使用git创建过ssh。需要打开git bash, 执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.email &quot;你的邮箱&quot;</span><br><span class="line">$ git config --global user.name &quot;你的用户名&quot;</span><br></pre></td></tr></table></figure>
<p>这里的邮箱和用户名都是服务器用于记录git提交记录的，然后是本地端生成ssh Key：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;你的邮箱&quot; &#x2F;&#x2F; 执行这个命令会提示输入用于保存的密钥名</span><br><span class="line">和口令之类的，都不填</span><br></pre></td></tr></table></figure>
<p>执行完后会在C:\Users\Administrator.ssh目录下生成id_rsa和id_rsa.pub两个文件，其中id_rsa.pub文件里的内容是等会要复制到服务器那里的<br>可以在git bash执行以下命令获取到id_rsa.pub文件里的内容。也可以直接用记事本之类的文本编辑器打开复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat .ssh&#x2F;id_rsa.pub &#x2F;&#x2F; 执行后可以看到公钥内容</span><br></pre></td></tr></table></figure>

<h1 id="VPS服务器配置">2. VPS服务器配置</h1><p>首先我们配置服务器上的SSH key。如果没有ssh，则自行安装。这里不再赘述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 添加hexo用户（注：这里用户名应该可以随意修改，但有人说git用户更好，待调查）</span><br><span class="line">adduser hexo</span><br><span class="line"># 切换到hexo用户</span><br><span class="line">su hexo</span><br><span class="line"># 切换到hexo用户目录</span><br><span class="line">cd &#x2F;home&#x2F;hexo</span><br><span class="line"># 创建.ssh文件夹</span><br><span class="line">mkdir .ssh</span><br><span class="line"># 创建authorized_keys文件并编辑</span><br><span class="line">echo &quot;id_rsa.pub中的内容&quot; &gt; .ssh&#x2F;authorized_keys</span><br><span class="line"># 如果你还没有生成公钥，那么首先在本地电脑中执行 cat ~&#x2F;.ssh&#x2F;id_rsa.pub | pbcopy生成公钥</span><br><span class="line"># 修改相应权限</span><br><span class="line">chmod 600 .ssh&#x2F;authorized_keys</span><br><span class="line">chmod 700 .ssh</span><br></pre></td></tr></table></figure>

<h1 id="配置post-update钩子">3. 配置post-update钩子</h1><p>Git的钩子脚本位于版本库.git&#x2F;hooks目录下，当Git执行特定操作时会调用特定的钩子脚本。当版本库通过git init或者git clone创建时，会在.git&#x2F;hooks目录下创建示例脚本，用户可以参照示例脚本的写法开发适合的钩子脚本。</p>
<p>钩子脚本要设置为可运行，并使用特定的名称。Git提供的示例脚本都带有.sample扩展名，是为了防止被意外运行。如果需要启用相应的钩子脚本，需要对其重命名（去掉.sample扩展名)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post-update</span><br><span class="line">该钩子脚本由远程版本库的git receive-pack命令调用。当从本地版本库完成一个推送之后，即当所有引用都更新完毕后，在远程服务器上该钩子脚本被触发执行。</span><br></pre></td></tr></table></figure>

<p>因此我们需要配置post-update钩子以便可以及时更新我们在VPS上存放Hexo 静态文件的目录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 回到hexo目录</span><br><span class="line">cd &#x2F;home&#x2F;hexo</span><br><span class="line"># 变成hexo用户</span><br><span class="line">su hexo</span><br><span class="line"># 新建blog目录存放hexo静态文件</span><br><span class="line">mkdir &#x2F;home&#x2F;hexo&#x2F;blog</span><br><span class="line"># 使用hexo用户创建git裸仓库，以blog.git为例</span><br><span class="line">git init --bare blog.git</span><br><span class="line"># 进入钩子文件夹hooks</span><br><span class="line">cd blog.git&#x2F;hooks&#x2F;</span><br><span class="line"># 启用post-update</span><br><span class="line">mv post-update.sample post-update</span><br><span class="line"># 添加执行权限</span><br><span class="line">chmod +x post-update</span><br><span class="line"># 配置post-update</span><br><span class="line">vim post-update</span><br></pre></td></tr></table></figure>

<p>注释如下行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec git update-server-info</span><br></pre></td></tr></table></figure>
<p>添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git --work-tree&#x3D;&quot;静态文件VPS存放目录&quot; --git-dir&#x3D;&quot;刚才新建的VPS git地址&quot; checkout -f</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git --work-tree&#x3D;&#x2F;home&#x2F;hexo&#x2F;blog --git-dir&#x3D;&#x2F;home&#x2F;hexo&#x2F;blog.git checkout -f</span><br></pre></td></tr></table></figure>

<p>当然，这里直接放在&#x2F;home目录不太妥当，也可以放在其他文件夹例如<code>/usr/local/static</code>，更符合对于不同用户的权限分离。但是注意，放在非hexo用户的目录下，需要用<code>chmod +777</code>给目录配置权限，否则git hock无法访问</p>
<h1 id="Nginx">4. Nginx</h1><p>nginx作为一个完成度非常高的负载均衡框架，和很多成熟的开源框架一样，大多数功能都可以通过修改配置文件来完成，使用者只需要简单修改一下nginx配置文件，便可以非常轻松的实现比如反向代理，负载均衡这些常用的功能。这里我们仅仅用到最简单的功能，但还是介绍一下比较好</p>
<h2 id="Nginx基本操作">4.1. Nginx基本操作</h2><p>启动nginx：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##使用systemctl</span><br><span class="line">systemctl start nginx.service</span><br><span class="line">#使用service</span><br><span class="line">service nginx start</span><br><span class="line">#或，简单粗暴的直接调用</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure>
<p>停止nginx:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##使用systemctl</span><br><span class="line">systemctl stop nginx.service</span><br><span class="line">#使用service</span><br><span class="line">service nginx stop</span><br><span class="line">#直接强行结束</span><br><span class="line">nginx -s stop</span><br><span class="line">##Nginx在退出前完成已经接受的连接请求。</span><br><span class="line">nginx -s quit</span><br></pre></td></tr></table></figure>
<p>重启nginx：<br>当我们修改了nginx的某些配置，为了使配置生效，我们往往需要重启nginx，同样的，linux下依然有两种方式来重启我们的nginx服务:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##使用systemctl</span><br><span class="line">systemctl restart nginx.service</span><br><span class="line">#使用service</span><br><span class="line">service nginx restart</span><br><span class="line">#使用nginx命令重启</span><br><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>
<p>其他命令：检查配置文件，同时显示配置文件目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure>

<p>要注意，如果不是在本地服务器直接调试。在服务器端的各种修改很可能因为DNS解析等各种原因不能及时更新。重新nginx之后切忌多ctrl+f5刷新几次，血的教训。</p>
<h2 id="Nginx简单配置">4.2. Nginx简单配置</h2><p><code>/etc/nginx/nginx.conf</code>是新的默认配置文件，但server块在最新版本中不在这里，而是放到了<code>/etc/nginx/sites-available</code>中，并在<code>/etc/nginx/sites-enabled</code>中用软连接控制配置。我们这里比较简单，直接修改<code>/etc/nginx/sites-available</code>中的default文件中的server块就行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        # 默认监听80端口</span><br><span class="line">        listen       80 default_server;</span><br><span class="line">        listen       [::]:80 default_server;</span><br><span class="line">        # 修改server_name为自己之前注册好的域名，没有就不用更改</span><br><span class="line">        server_name  xxx.com;</span><br><span class="line">        # 修改网站根目录，在这里存放你的Hexo静态文件，请自行选择或创建目录</span><br><span class="line">        root         &#x2F;home&#x2F;hexo&#x2F;blog;</span><br><span class="line">        # 其他保持不变</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="更新Hexo的deploy方式">5. 更新Hexo的deploy方式</h1><p>找到本地Hexo博客的站点配置文件_config.yml，找到以下内容并修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:XXXX&#x2F;XXXX.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>可以看到这里只能上传到github一种。但我们想同时传到vps和github托管，可以吗？直接这样写就行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:</span><br><span class="line">    github: git@github.com:XXXX&#x2F;XXXX.github.io.git</span><br><span class="line">    vps: hexo@xxx.com:&#x2F;your&#x2F;file&#x2F;path</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>如果你修改了SSH端口，可以使用该方法来访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vps: ssh:&#x2F;&#x2F;hexo@xxx.com:port&#x2F;your&#x2F;file&#x2F;path</span><br></pre></td></tr></table></figure>

<p>之后直接使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p>就能同时上传到VPS和github托管了！</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo更新</title>
    <url>/2021/03/07/Hexo-update/</url>
    <content><![CDATA[<h1 id="Hexo以及Next主题升级">1. Hexo以及Next主题升级</h1><p>最近需要在新电脑上重用旧的hexo工程，并安装Hexo最新版本，遇到一大堆坑，特此记录</p>
<h1 id="安装NodeJS以及Hexo">2. 安装NodeJS以及Hexo</h1><p>这里我选择在windows上使用nvm安装。nodejs版本过高或者过低都会导致hexo渲染错误。通过nvm不断选择调试，我选择用nodejs的12.14.0版本。</p>
<p>随后在git pull下的旧目录中执行这些命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">npm install --save</span><br></pre></td></tr></table></figure>

<h1 id="重新安装Next主题">3. 重新安装Next主题</h1><p>震惊的发现旧版本已经不维护了，新版本移动到了<code>https://github.com/theme-next/hexo-theme-next</code></p>
<p>我因为多次尝试直接升级然后报错，最后选择了直接把<code>thems\next</code>文件夹删除，并重新从github上pull了最新版本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>
<p>然后把旧的<code>_config.yml</code>文件用git compare打开，比对选项的设置。（方法虽然愚蠢、但是有效，起码比在那折腾版本文件一小时做了无用功好，是吧是的😎）</p>
<h1 id="尝试新功能">4. 尝试新功能</h1><h2 id="页面标题自动编号功能">4.1. 页面标题自动编号功能</h2><p>插件来源：参考页面(<a href="https://www.npmjs.com/package/hexo-heading-index">https://www.npmjs.com/package/hexo-heading-index</a>)</p>
<ol>
<li>安装<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-heading-idnex --save</span><br></pre></td></tr></table></figure></li>
<li>在hexo根目录下的<code>_config.yml</code>站点配置文件中，添加如下代码来启用自动编号功能。<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">heading_index:</span></span><br><span class="line"><span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">index_styles:</span> <span class="string">&quot;&#123;1&#125; &#123;1&#125; &#123;1&#125; &#123;1&#125; &#123;1&#125; &#123;1&#125;&quot;</span></span><br><span class="line"><span class="attr">connector:</span> <span class="string">&quot;.&quot;</span></span><br><span class="line"><span class="attr">global_prefix:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">global_suffix:</span> <span class="string">&quot;. &quot;</span></span><br></pre></td></tr></table></figure></li>
<li>注：next主题中，会在左侧侧边栏创建标号。如果与这个插件一起使用，则会重复创建。因此我们先将其关闭。打开next的配置文件<code>_congig.yml</code>，搜索<code>toc</code>将<code>number</code>后面的true改成false，这样左侧栏就不会自动计数了</li>
</ol>
<h2 id="增加访问统计">4.2. 增加访问统计</h2><p>发现Next中已经增加了访问统计，直接在Next的<code>_config.yml</code>中搜索<code>busuanzi_count</code>，启用即可。但是因为Hexo是静态网站，貌似是有问题的，需要再研究一下</p>
<h2 id="站内搜索">4.3. 站内搜索</h2><p>hexo-generator-searchdb插件</p>
<ol>
<li>安装<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></li>
<li>在hexo根目录下的<code>_config.yml</code>站点配置文件中<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line"><span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line"><span class="attr">field:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">format:</span> <span class="string">html</span></span><br><span class="line"><span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure></li>
<li>在themes目录下的<code>_config.yml</code>主题配置文件中<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="结尾">5. 结尾</h1><p>好了，今天的折腾又搞完了。又浪费了一个半小时搞了没用的东西呢🤔</p>
<p>人生不过两万天，能摸一天是一天！</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>Java复健系列(5)：Java多线程</title>
    <url>/2020/10/19/Java-review-5/</url>
    <content><![CDATA[<h1 id="多线程">1. 多线程</h1><ul>
<li><em>程序</em> 是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</li>
<li><em>进程</em>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 </li>
<li><em>线程</em> 与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</li>
</ul>
<p>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p>
<h1 id="进程">2. 进程</h1><h2 id="定义">2.1. 定义</h2><p>狭义定义：进程是计算机中正在运行的程序的实例（an instance of a computer program that is being executed）。</p>
<p>程序本身只是指令的集合，进程才是程序（那些指令）的真正运行。用户下达运行程序的命令后，就会产生进程。同一程序可产生多个进程（一对多关系），以允许同时有多位用户运行同一程序，却不会相互冲突。进程需要一些资源才能完成工作，比如CPU使用时间、存储器、文件以及I&#x2F;O设备，且为依序逐一进行，也就是任何时间内仅能运行一项进程。</p>
<h2 id="基本状态">2.2. 基本状态</h2><p>通常进程有如下5种状态，其中前三种是进程的基本状态。</p>
<ol>
<li>运行状态（执行窗台）：进程正在处理器上运行。在单处理器环境下，每一时刻最多只有一个进程处于运行状态。</li>
<li>就绪状态：进程已处于准备运行的状态，即进程获得了除处理器之外的一切所需资源，一旦得到处理器即可运行。</li>
<li>阻塞状态：又称为等待状态，进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理器）或等待输入&#x2F;输出完成。即使处理器空闲，该进程也不能运行。</li>
<li>创建状态：进程正在被创建，尚未转到就绪状态。</li>
<li>结束状态：进程正从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li>
</ol>
<ul>
<li>当一个就绪状态获得处理机时，其状态由就绪变为执行；</li>
<li>当一个运行进程被剥夺处理机时，如用完系统分给它的时间片、出现更高优先级别的其他进程，其状态由运行变为就绪；</li>
<li>当一个运行进程因某事件受阻时，如所申请资源被占用、启动I&#x2F;O传输未完成，其状态由执行变为阻塞；<br>当所等待事件发生时，如得到申请资源、I&#x2F;O传输完成，其状态由阻塞变为就绪</li>
</ul>
<h2 id="进程与程序的区别">2.3. 进程与程序的区别</h2><ul>
<li>进程是程序及其数据在计算机上的一次运行活动，是一个动态的概念。进程的运行实体是程序、离开程序的进程没有存在的意义。从静态角度看，进程是由程序、数据和进程控制块（PCB）三部分组成的。而程序时一组有序的指令集合，是一种静态的概念。</li>
<li>进程是程序的一次执行过程，它是动态地创建和消亡的，具有一定的生命期，是暂时存在的；而程序则是一组代码的集合，它是永久存在的，可长期保存。</li>
<li>一个进程可以执行一个或几个程序，一个程序也可以构成多个进程。进程可创建进程，而程序不可能形成新的程序。</li>
</ul>
<h1 id="线程">3. 线程</h1><p>线程，有时被称为轻量级进程（Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程ID、当前指令指针（PC）、寄存器集合和堆栈（stack）组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的资源。</p>
<p>线程共享的进程环境包括：进程代码段、进程的共有数据（如全局变量，利用这些共享的数据，线程很容易的实现相互之间的通信）、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。</p>
<p>线程拥有这许多共性的同时，还拥有自己的个性。有了这些个性，线程才能够实现并发性。这些个性包括：</p>
<ul>
<li>线程ID：每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标识线程；</li>
<li>寄存器的值：由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上时，必须将原有线程的寄存器集合的状态进行保存，以便将来该线程在被重新切换时能得以恢复。</li>
<li>线程的堆栈（Stack）：堆栈是保证线程独立运行所必须的。线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数堆栈，使得函数调用可以正常执行，不受其他线程的影响。在一个进程的线程共享堆区（heap）。</li>
<li>错误返回码</li>
<li>线程的信号屏蔽码</li>
<li>线程的优先级</li>
</ul>
<p>一个线程可以创建和撤销另一个线程，同一进程的多个线程之间可以并发执行。由于县城之间的相互制约，致使线程在运行中呈现间断性。</p>
<p>线程也有就绪、阻塞和运行三种基本状态。每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。</p>
<p>线程是程序中一个单一的顺序控制流程。在单个程序中同时运行多个线程完成不同的工作，称为多线程。</p>
<p>引入线程后，进程的内涵发生了变化，进程只作为除CPU以外系统资源的分配单元，线程则作为处理器的分配单元。在同一进程中，线程的切换不会引起进程的切换，但从一个进程中的线程切换到另一个进程中的线程时，将会引起进程的切换。</p>
<h2 id="线程的基本状态">3.1. 线程的基本状态</h2><table>
<thead>
<tr>
<th>状态名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NEW</td>
<td>初始状态，线程被构建，但还没有调用start()方法</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>运行状态，Java线程将操作系统中的就绪与运行两种状态都称作“运行中”</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>阻塞状态，表示线程阻塞于锁</td>
</tr>
<tr>
<td>WAITING</td>
<td>等待状态，表示线程进入等待状态，当前线程需要等待其他线程做出特定动作（通知或中断）</td>
</tr>
<tr>
<td>TIME_WAITING</td>
<td>超时等待状态，该状态不等于WAITING，可以在指定时间自动返回</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>终止状态，当前线程已经执行完毕</td>
</tr>
</tbody></table>
<p>线程状态变迁如下所示</p>
<p><img src="/.xyz//process%20state.png" alt="线程状态"></p>
<h2 id="进程与线程的区别">3.2. 进程与线程的区别</h2><ul>
<li>调度：在传统操作系统中，拥有资源和独立调度的基本单位都是进程。引入线程后，线程是独立调度的基本单位，进程是拥有资源的基本单位。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行的线程切换，则会引起进程切换。</li>
<li>拥有资源：不论是传统的还是引入线程的操作系统，进程都是拥有资源的基本单位，线程不拥有资源（也有一点必不可少的资源），但线程可以共享其隶属进程的系统资源。</li>
<li>并发性：在引入线程的操作系统中，不仅进程可以并发执行，而且同一进程内的多个线程也可以并发执行，从而使操作系统具有具有更好的并发性，大大提高了系统的吞吐量。</li>
<li>系统开销：创建和撤销进程时，系统都要为之分配或回收资源，如内存空间、I&#x2F;O设备等等，因此操作系统所付出的开销远大于创建或撤销线程的开销。类似地，在进程切换时，涉及当前执行进程CPU环境的保存以及新调度的进程CPU环境的设置；而线程切换时只需保存和设置少量寄存器内容，因此开销很小。另外，由于同一进程内的多个线程共享进程的地址空间，因此这些线程之间的同步与通信比较容易实现，甚至无需操作系统的干预。</li>
<li>地址空间和其他资源（如打开的文件）：进程的地址空间之间相互独立，同一进程的各线程间共享进程的资源，某进程内的线程对于其他进程不可见。</li>
<li>通信方面：进程间通信需要借助操作系统，而线程间可以直接读、写进程数据段（如全局变量）来进行通信。</li>
</ul>
<h1 id="进程通信与同步">4. 进程通信与同步</h1><p>多个进程可以共享系统中的各种资源，但其中许多资源一次为能为一个进程使用，我们把一次仅允许一个进程使用的资源成为临界资源。许多物理设备都属于临界资源，如打印机等。</p>
<p>对临界资源的访问，必须互斥的进行，在每个进程中，访问临界资源的那段代码成为临界区（Critical Section）。</p>
<p>进程通信与同步有如下一些目的。</p>
<ul>
<li>数据传输</li>
<li>共享数据</li>
<li>通知数据</li>
<li>资源共享</li>
<li>进程控制</li>
</ul>
<p>Linux进程间通信的几种主要手段简介：</p>
<ul>
<li><p>管道（Pipe）及有名管道（named Pipe）</p>
</li>
<li><p>信号（Signal）</p>
</li>
<li><p>Message（消息队列）</p>
</li>
<li><p>共享内存（Shared Memory）</p>
</li>
<li><p>信号量</p>
</li>
<li><p>套接口</p>
</li>
<li><p>Linux线程间通信：互斥体（互斥量）、信号量、条件变量</p>
</li>
<li><p>Windows进程间通信：管道、共享内存、消息队列、信号量、socket</p>
</li>
<li><p>windows线程间通信：临界区（Critical Section）、互斥量（Mutex）、信号量（信号灯）（Semaphore）、事件（Event）。</p>
</li>
</ul>
<h1 id="调度算法">5. 调度算法</h1><p>调度的基本准则包括CPU利用率、系统吞吐量、周转时间、等待时间、响应时间等。</p>
<ul>
<li>系统吞吐量：表示单位时间内CPU完成作业的数量</li>
<li>周转时间：作业完成时刻减去作业到达的时刻</li>
<li>等待时间：进程处于等处理器状态的时间之和，等待时间越长，用户满意度越低。</li>
<li>响应时间：从用户提交请求到系统首次产生响应所用的时间。</li>
</ul>
<p>典型的调度算法包括：</p>
<ul>
<li>实时系统中：FIFO(First Input First Output，先进先出算法)，SJF(Shortest Job First，最短作业优先算法)，SRTF(Shortest Remaining Time First，最短剩余时间优先算法）。</li>
<li>交互式系统中：RR(Round Robin，时间片轮转算法)，HPF(Highest Priority First，最高优先级算法)，多级队列，最短进程优先，保证调度，彩票调度，公平分享调度。</li>
</ul>
<h1 id="死锁">6. 死锁</h1><p>所谓死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。现实生活中简单的例子：交通阻塞，两股相向而行的车流都想通过已被对方占用的道路，结果双方都不能前进。</p>
<p>死锁产生的原因：系统资源的竞争、进程推进顺序非法</p>
<p>死锁产生的必要条件：产生死锁必须同时满足以下四个条件，只要其中任一条件不满足，死锁就不会发生。</p>
<ul>
<li>互斥条件：进程要求对所分配的资源进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待；</li>
<li>不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他资源强行夺走，即只能由获得该资源的进程自己来释放。</li>
<li>请求和保持条件：又称为部分分配条件。进程每次申请它所需要的一部分资源，在等待新资源的同时，进程继续占有已分配到的资源。</li>
<li>循环等待条件：存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。即存在一个处于等待状态的进程集合{P1,P2,….Pn}其中Pi等待的资源被Pi+1(i&#x3D;0,1,2,…n−1)占有，Pn等待资源被P0占有。</li>
</ul>
<p>死锁处理：</p>
<ul>
<li>预防死锁：设置某些限制条件，破坏产生死锁的四个必要条件中的一个或几个</li>
<li>避免死锁：在资源的动态分配过程中，用某种方法防止系统进入不安全状态。银行家算法是著名的死锁避免算法。</li>
<li>死锁的检测及解除：无需采取任何限制性措施，允许进程在运行过程中发生死锁，通过系统的检测机制及时地检测出死锁的发生，然后采取某种措施解除死锁。死锁可利用资源分配图来描述。死锁的解除主要方法：资源剥夺法、撤销进程法、进程回退法</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Manjaro 配置方法个人记录</title>
    <url>/2019/11/09/ManjaroConfig/</url>
    <content><![CDATA[<p>Manjaro是一个目前广泛是使用的Arch Linux发行版，在各种方面都十分优秀。其最大优势在在于丰富的官方Wiki给出各种组件的介绍与问题解决办法，各种问题都可以轻松解决。其他优势网上有更相近描述。这里不再赘述。Manjaro的官方提供使用不同启动器的多种版本，有XFCE，KDE，GNOME等。还有使用国人操作系统桌面的Deepin桌面。其中，XFCE较轻便，但功能不够丰富。GNOME桌面十分华丽，但响应速度上没有优势。而Deepin桌面是类macos桌面，界面十分优秀，也比较符合国人操作习惯。但在我个人的电脑上出现了许多问题，如触摸板灵敏度无法调节到比较顺手的程度，Wifi断连等问题。因此个人最后选择了KDE桌面，在响应速度和操作上都有不错的表现。</p>
<h1 id="系统安装">1. 系统安装</h1><p>这一步类似其他操作系统，直接从官方下载操作系统ISO文件并写入U盘进行安装即可。Manjaro的设置界面非常直观，基本不需要过多介绍。这里我跳过不是重点的这部分。记得把\boot\efi挂到efi分区就行。同时我这里选择安装english-us系统，后期再在系统中添加中文字体。</p>
<h1 id="Pacman的使用">2. Pacman的使用</h1><p>pacman软件包管理器是 Arch Linux 的一大亮点。它将一个简单的二进制包格式和易用的构建系统结合了起来(参见makepkg和ABS)。不管软件包是来自官方的 Arch 库还是用户自己创建，pacman 都能方便地管理。pacman 通过和主服务器同步软件包列表来进行系统更新。这种服务器&#x2F;客户端模式可以使用一条命令就下载或安装软件包，同时安装必需的依赖包。更具体的操作可以查阅Arch Linux官方Wiki。</p>
<h2 id="用法">2.1. 用法</h2><h3 id="安装软件包">2.1.1. 安装软件包</h3><p>安装或者升级单个软件包，或者一列软件包（包含依赖包），使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pacman -S package_name1 package_name2 ...</span><br></pre></td></tr></table></figure>
<p>安装本地安装包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pacman -U file_name</span><br></pre></td></tr></table></figure>
<h3 id="删除软件包">2.1.2. 删除软件包</h3><p>删除单个软件包，保留其全部已经安装的依赖关系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pacman -R package_name</span><br></pre></td></tr></table></figure>
<p>删除指定软件包，及其所有没有被其他已安装软件包使用的依赖关系：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pacman -Rs package_name</span><br></pre></td></tr></table></figure>
<h3 id="升级系统">2.1.3. 升级系统</h3><p>一个 pacman 命令就可以升级整个系统。花费的时间取决于系统有多老。这个命令会同步非本地(local)软件仓库并升级系统的软件包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pacman -Syu</span><br></pre></td></tr></table></figure>
<p>升级内核</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pacman -Syyuu</span><br></pre></td></tr></table></figure>
<h3 id="查询软件包">2.1.4. 查询软件包</h3><p>要查询已安装的软件包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pacman -Qs string1 string2 ...</span><br></pre></td></tr></table></figure>
<h3 id="删除多余">2.1.5. 删除多余</h3><p>要罗列所有明确安装而且不被其它包依赖的软件包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pacman -Qet</span><br></pre></td></tr></table></figure>
<h3 id="清理缓存">2.1.6. 清理缓存</h3><p>pacman 将下载的软件包保存在 &#x2F;var&#x2F;cache&#x2F;pacman&#x2F;pkg&#x2F; 并且不会自动移除旧的和未安装版本的软件包，因此需要手动清理，以免该文件夹过于庞大。</p>
<p>使用内建选项即可清除未安装软件包的缓存：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pacman -Sc</span><br></pre></td></tr></table></figure>
<p>pacman-contrib 提供的 paccache 命令默认会删除近3个版本前的软件包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">paccache -r</span><br></pre></td></tr></table></figure>

<h1 id="系统升级">3. 系统升级</h1><p>使用该命令升级系统。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pacman -Syu</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pacman -Syyuu</span><br></pre></td></tr></table></figure>

<h1 id="添加archlinuxcn源">4. 添加archlinuxcn源</h1><p>打开&#x2F;etc&#x2F;pacman.conf，在底部添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[archlinuxcn]</span><br><span class="line">SigLevel &#x3D; Optional</span><br><span class="line">Server &#x3D; http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;archlinuxcn&#x2F;$arch</span><br></pre></td></tr></table></figure>
<p>Server可以自己测速选择别的服务器。这里SigLevel为默认的Optional，需要签名认证，因此使用如下命令更新签名。最后更新源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S archlinuxcn-keyring</span><br><span class="line">sudo pacman -Syy</span><br></pre></td></tr></table></figure>

<h1 id="软件配置">5. 软件配置</h1><h2 id="AUR相关配置">5.1. AUR相关配置</h2><p>Manjaro的软件源包含的软件非常丰富，安装也非常简单，官方源里无法找到软件，也可以在AUR里搜索。这里我们安装yay来获取aur软件包。注：yaurt已经过时，不建议安装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pacman -S yay</span><br></pre></td></tr></table></figure>
<p>用法与pacman类似。注：使用yay时，不需要sudo权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yay -Ss &lt;关键字&gt;	#搜索含有关键字的软件</span><br><span class="line">yay -S &lt;软件名&gt;	#安装软件</span><br><span class="line">yaourt &lt;关键字&gt; #搜索软件包</span><br></pre></td></tr></table></figure>
<h2 id="Vim及文本编辑">5.2. Vim及文本编辑</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S vim</span><br><span class="line">sudo pacman -S gedit</span><br></pre></td></tr></table></figure>

<h2 id="中文输入法">5.3. 中文输入法</h2><p>我们使用fcitx框架来配置输入法。这里我们选用google拼音，也可以自行选择其他。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S fcitx-im</span><br><span class="line">sudo pacman -S fcitx-configtool</span><br><span class="line">sudo pacman -S fcitx-googlepinyin</span><br></pre></td></tr></table></figure>
<p>之后按照官方文档，在‘~&#x2F;.pam_environment’中，加入以下内容，并重启使环境变量生效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GTK_IM_MODULE&#x3D;fcitx</span><br><span class="line">QT_IM_MODULE&#x3D;fcitx</span><br><span class="line">XMODIFIERS&#x3D;@im&#x3D;fcitx</span><br></pre></td></tr></table></figure>
<p>之后系统会自动启动fcitx，在输入法中选择添加输入法，选择显示所有输入法，将google拼音加切换输入法（注：第一个输入法需设置为键盘格式）</p>
<h2 id="Chrome">5.4. Chrome</h2><p>安装Chrome或chromium</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S google-chrome</span><br><span class="line">sudo pacman -S chromium</span><br></pre></td></tr></table></figure>

<h2 id="QQ">5.5. QQ</h2><p>使用如下命令可直接安装deepin移植的tim</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S deepin.com.qq.office</span><br></pre></td></tr></table></figure>
<p>注意，KDE版直接安装无法启动。需要先安装gnome-settings-daemon，然后在settings-&gt;start up and shutdown中添加&#x2F;usr&#x2F;lib&#x2F;gsd-xsettings设置为自动启动。重启系统即可使用。</p>
<h2 id="微信">5.6. 微信</h2><p>微信的源没有直接加入pacman库，在<a href="https://aur.archlinux.org/packages/deepin-wine-wechat/">https://aur.archlinux.org/packages/deepin-wine-wechat/</a> 下载source code。使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -U #下载的包名</span><br></pre></td></tr></table></figure>
<p>直接安装后无法使用。需要在&#x2F;opt&#x2F;deepinwine&#x2F;apps&#x2F;Deepin-WeChat&#x2F;run.sh 中，将WINE_CMD属性改为：WINE_CMD&#x3D;”deepin-wine”，用来调用deepin-wine桌面。此时能够正常启动，但大约1分钟后会闪退。参照<a href="https://github.com/countstarlight/deepin-wine-wechat-arch/issues/32">https://github.com/countstarlight/deepin-wine-wechat-arch/issues/32</a>。因为新版微信的小程序员会导致闪退，使用空文件替换~&#x2F;.deepinwine&#x2F;Deepin-WeChat&#x2F;drive_c&#x2F;Program Files&#x2F;Tecent&#x2F;WeChat&#x2F;WeChatApp.exe，之后即可正常使用微信</p>
<h2 id="PDF">5.7. PDF</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yay -S foxitreader</span><br><span class="line">yay -S evince</span><br></pre></td></tr></table></figure>

<h3 id="ZSH">5.7.1. ZSH</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S zsh</span><br><span class="line">sudo pacman -S oh-my-zsh-git</span><br><span class="line">cp &#x2F;usr&#x2F;share&#x2F;oh-my-zsh&#x2F;zshrc ~&#x2F;.zshrc #ohmyzsh配置文件</span><br><span class="line">chsh -s &#x2F;bin&#x2F;zsh #替换默认shell</span><br></pre></td></tr></table></figure>
<h3 id="网易云音乐">5.7.2. 网易云音乐</h3><p>直接可用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S netease-cloud-music</span><br></pre></td></tr></table></figure>

<p>至此，manjaro使用环境基本完成。进一步配置请期待后文</p>
]]></content>
      <categories>
        <category>ArchLinux</category>
      </categories>
  </entry>
  <entry>
    <title>Openwrt升级后密码错误</title>
    <url>/2022/05/21/Openwrt-error-passwd/</url>
    <content><![CDATA[<p>事情的起因：使用Openwrt系统一年后，突发奇想需要升级系统。于是重新刷了基于Lean的Openwrt固件，并导入了之前备份的配置。然而出现了问题，无法使用密码登录。</p>
<h1 id="现象">1. 现象</h1><ol>
<li>导入配置后，ip地址等设置都变为了我备份配置中的配置项。功能正常</li>
<li>使用ssh，可以远程登录到后台，并执行各种命令行操作</li>
<li>使用ip地址能够登录到管理页面，但无法使用之前配置的密码登录页面</li>
</ol>
<p>根据1与2确认系统正常，备份的配置项正常。但3表示肯定出现了什么问题。期间进行了各种重装、复位、格式化等操作，均无法使其正常工作</p>
<h1 id="原因">2. 原因</h1><p>参考资料:<a href="https://www.right.com.cn/forum/thread-6188175-1-1.html"></a>和<a href="https://www.bilibili.com/read/cv14768081/"></a>。按照这两位探路先行者的说法，是更新后的rpcd多了几行代码，导致旧密码无法使用。</p>
<h1 id="修复">3. 修复</h1><ol>
<li>使用ssh登录</li>
<li>找到<code>/etc/config/rpcd</code>，使用vim编辑这个文件。<code>vim /etc/config/rpcd</code></li>
<li>最后重启软路由</li>
<li>成功，可以使用密码正常登录web管理界面啦</li>
</ol>
<p>又水了一篇文章，真开心</p>
]]></content>
      <categories>
        <category>Openwrt</category>
      </categories>
  </entry>
  <entry>
    <title>WSL2相关配置（更新）</title>
    <url>/2023/01/27/WSL2-config/</url>
    <content><![CDATA[<p>本文是对WSL2相关配置的更新与补充</p>
<h1 id="WSL官方配置教程">1. WSL官方配置教程</h1><p>参考<a href="https://learn.microsoft.com/zh-cn/windows/wsl/install">微软官方配置教程</a><br>以下以wsl开头的命令建议都使用Windows PowerShell运行</p>
<h2 id="Windows版本">1.1. Windows版本</h2><p>建议Windows版本都更新到22H2以上</p>
<h2 id="启用WSL子系统功能">1.2. 启用WSL子系统功能</h2><ul>
<li>打开”启用或关闭Windos功能”</li>
<li>勾选”适用于Linux的Windows子系统”</li>
<li>重启电脑完成安装</li>
</ul>
<h2 id="Windows10更新内核">1.3. Windows10更新内核</h2><p>参考<a href="https://learn.microsoft.com/zh-cn/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package">旧版 WSL 的手动安装步骤</a>。windows10的wsl子系统可能需要更新内核才能使用WSL2，Windows11 22h2以后的版本则没有这个问题</p>
<p>因此，windows 10 电脑需要下载并安装<a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">适用于 x64 计算机的 WSL2 Linux 内核更新包</a></p>
<h2 id="WSL2设为默认版本">1.4. WSL2设为默认版本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --set-default-version 2</span><br></pre></td></tr></table></figure>

<h2 id="安装Linux分发">1.5. 安装Linux分发</h2><p>查看可用版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl -l -o</span><br></pre></td></tr></table></figure>

<p>下载安装 <code>Ubuntu-22.04</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --install -d Ubuntu-22.04</span><br></pre></td></tr></table></figure>

<h2 id="检查版本">1.6. 检查版本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl -l -v</span><br></pre></td></tr></table></figure>
<p>确保安装的wsl的version为2，则成功安装了基于wsl2的Ubuntu-22.04</p>
<h1 id="配置">2. 配置</h1><h2 id="Windows-Terminal相关配置">2.1. Windows Terminal相关配置</h2><p>目前最新版的Windows Terminal已经支持自动配置wsl到Windows Terminal中</p>
<p>如为老版本的Windows Terminal，则需要自行配置setting.json，具体可参考老版本说明</p>
<h2 id="Ubuntu替换国内镜像源">2.2. Ubuntu替换国内镜像源</h2><p>需要修改WSL子系统的<code>/ect/apt/sources.list</code>，可以在WSL的命令行中使用VIM进行编辑，也可以在Windows资源管理器中直接打开该文件进行修改</p>
<ol>
<li>修改前进行备份</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<p>替换为清华镜像源，参考<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">Ubuntu 镜像使用帮助</a></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># 预发布软件源，不建议启用</span><br><span class="line"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>更新</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>

<h2 id="配置oh-my-zsh">2.3. 配置oh-my-zsh</h2><h3 id="安装ZSH">2.3.1. 安装ZSH</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install zsh</span><br><span class="line">$ zsh --version</span><br><span class="line">zsh 5.8 (x86_64-ubuntu-linux-gnu)</span><br></pre></td></tr></table></figure>

<h3 id="安装oh-my-zsh">2.3.2. 安装oh-my-zsh</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置主题">2.3.3. 配置主题</h3><p>需要编辑.zshrc文件，然后使用source刷新</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.zshrc</span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>
<p>例如我喜欢dst或者ys主题，修改<code>ZSH_THEME=&quot;dst&quot;</code>或者<code>ZSH_THEME=&quot;dst&quot;</code>即可</p>
<h3 id="配置插件">2.3.4. 配置插件</h3><p>我喜欢使用的插件有：</p>
<ul>
<li>zsh-autosuggestions</li>
<li>zsh-syntax-highlighting</li>
</ul>
<p>下载：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>

<p>在zshrc中配置，将其中的plugins行改为</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">plugins=(git zsh-autosuggestions zsh-syntax-highlighting)</span><br></pre></td></tr></table></figure>

<p>更新配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.zshrc</span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>

<h2 id="宿主机上控制WSL中的Docker">2.4. 宿主机上控制WSL中的Docker</h2><p>目前的Docker DeskTop直接提供了该功能，直接安装后会自动接管WSL中的docker。因此在配置完毕WSL2后直接下载windows版本即可。参考(<a href="https://www.docker.com/products/docker-desktop/">https://www.docker.com/products/docker-desktop/</a>)</p>
]]></content>
  </entry>
  <entry>
    <title>Redis作为消息队列的几种方法</title>
    <url>/2023/09/03/Redis-as-MQ/</url>
    <content><![CDATA[<h1 id="本文来源参考">1. 本文来源参考</h1><p><a href="https://javakeeper.starfish.ink/data-management/Redis/Redis-MQ.html">Redis 消息队列的三种方案</a><br><a href="https://juejin.cn/post/7094272373930590245">redis消息队列，你敢不敢用？</a></p>
<h1 id="为什么使用Redis作为消息队列">2. 为什么使用Redis作为消息队列</h1><p>当前使用较多的 消息队列 有 RabbitMQ、RocketMQ、ActiveMQ、Kafka、ZeroMQ、MetaMQ 等，而部分数据库 如 Redis、MySQL 以及 phxsql ，如果非要使用的话，其实也可实现消息队列的功能。</p>
<p>那为什么要使用Redis作为消息队列？<br>在一些简单的业务场景中，仅需要简单功能，使用重量级可能不需要重量级的 MQ 组件(相比 Redis 来说，Kafka 和 RabbitMQ 都算是重量级的消息队列)</p>
<p>优势：</p>
<ul>
<li>方便：目前很多项目开发已引入 redis。因此，运维、学习成本等较低</li>
<li>轻量级：开箱即用，也可以自己做一层简单封装</li>
<li>多样性：可根据需求选择底层队列结构</li>
</ul>
<p>同样的，以下几种Redis作为消息队列的做法也存在各自的缺点。接下来会具体情况具体分析</p>
<h1 id="回顾消息队列">3. 回顾消息队列</h1><p>我们使用的消息队列，一般有如下特点：</p>
<ol>
<li>三个角色：生产者、消费者、消息处理中心</li>
<li>异步处理模式：生产者 将消息发送到一条 虚拟的通道(消息队列)上，而无须等待响应。消费者 则 订阅 或是 监听 该通道，取出消息。两者互不干扰，甚至都不需要同时在线，也就是我们说的 松耦合</li>
<li>对可靠性的需求</li>
</ol>
<p>其中，对可靠性的需求，可能有如下三点：</p>
<ul>
<li>需求一：消息保序<br>  需要确保按照生产者发送消息的顺序</li>
<li>需求二：不重复消费<br>  有时会因为网络堵塞出现消息重传的情况，这种情况下，不能重复消费重复信息</li>
<li>需求三：消息可靠性保证<br>  因为故障或宕机重启后，可以重新读取未完成的消息</li>
</ul>
<p>因此，如果使用Redis作为消息队列，我们也部分或全部需要满足这些特点或需求</p>
<h1 id="基于List实现消息队列">4. 基于List实现消息队列</h1><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部(左边)或者尾部(右边)。</p>
<p>所以常用来做异步队列使用。将需要延后处理的任务结构体序列化成字符串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理。</p>
<h2 id="相关List常用命令">4.1. 相关List常用命令</h2><ul>
<li>LPUSH|RPUSH|LPOP|RPOP:将元素左插入、右插入、左弹出、右弹出等</li>
<li>BLPOP|BRPOP:弹出元素，如不存在则等待</li>
<li>BRPOPLPUSH|RPOPLPUSH: 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</li>
</ul>
<h2 id="基于简单List的消息队列">4.2. 基于简单List的消息队列</h2><p>组合使用</p>
<ul>
<li>LPUSH、RPOP 左进右出</li>
<li>RPUSH、LPOP 右进左出</li>
</ul>
<p>具体逻辑：</p>
<ol>
<li>生产者使用LPUSH命令将消息一次写入List</li>
<li>消费者使用RPOP命令从LIST另一端取出，进行消费</li>
</ol>
<p>Java代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">redisTemplate.opsForList().leftPush(redisKey, value);</span><br><span class="line"></span><br><span class="line">redisTemplate.opsForList().rightPop(redisKey, value);</span><br></pre></td></tr></table></figure>

<p><img src="/.xyz//redis-rpop.jpg" alt="基于队列消费"></p>
<p>优势：</p>
<ol>
<li>因为Redis单线程的特点。在消费数据时，同一个消息必定不会被多个consumer消费</li>
<li>简单易实现</li>
</ol>
<h3 id="存在问题与解决方法">4.2.1. 存在问题与解决方法</h3><p>如何实现消息队列可靠性的三个需求？</p>
<h4 id="性能风险">4.2.1.1. 性能风险</h4><p>消费者如果想要及时的处理数据，就要在程序中写个类似 while(true) 这样的逻辑，或者使用sleep(1000)，不停的去调用 RPOP 或 LPOP 命令，这就会给消费者程序带来些不必要的性能损失。</p>
<p>解决方案：<br>使用BLPOP、BRPOP等阻塞式命令<br>客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据。这种方式就节省了不必要的 CPU 开销。如果将超时时间设置为 0 时，即可无限等待，直到弹出消息</p>
<p>使用：</p>
<ul>
<li>LPUSH、BRPOP 左进右阻塞出</li>
<li>RPUSH、BLPOP 右进左阻塞出</li>
</ul>
<h4 id="消息有序性问题">4.2.1.2. 消息有序性问题</h4><ul>
<li>在单个消费者情况下，消息必定有序</li>
<li>在多个消费者情况下同时读取同一个队列时，可能无法保证消息有序，需要特殊处理。可以考虑用下文的消息中添加全局唯一ID的做法解决</li>
</ul>
<h4 id="消息重复问题">4.2.1.3. 消息重复问题</h4><p>假设生产者因为网络或其他原因，在队列中多次发送同一个消息。为解决这个问题。需要：</p>
<ul>
<li>每条消息需要全局唯一性ID；</li>
<li>消费者需要记录处理过消息的ID;</li>
<li>消息的全局唯一ID需要生产者在发送消息前自动生成</li>
</ul>
<h4 id="消息多播问题">4.2.1.4. 消息多播问题</h4><p>基于List的消息队列，完全无法扩展支持多消费者阅读同一消息功能</p>
<h2 id="基于ACK机制的可靠队列">4.3. 基于ACK机制的可靠队列</h2><p>在基于普通队列的方式中，List队列的消息一旦被发送，便从队列中被删除。如果由于网络等各种原因，消费者没有正确处理消息，那么这条消息对应的数据很有可能丢失。</p>
<p>为了保证消息可靠性，需要使用确认机制的的消息队列。在Redis中，我们可以使用BRPOPLPUSH|RPOPLPUSH命令，每次都在获取消息的同时将消息复制到另一个list中（作为备份），这个过程是原子的。</p>
<p>使用:</p>
<ul>
<li>LPUSH、RPOPLPUSH</li>
<li>RPUSH、LPOPRPUSH</li>
</ul>
<p>具体逻辑：</p>
<ol>
<li>生产者使用RPUSH命令将消息写入list</li>
<li>消费者尝试取出所有在list_backup中的消息</li>
<li>如不存在list_backup，则临时将当前list中所有消息放入list_backup中，再获取</li>
</ol>
<p><img src="/.xyz//redis-rpoplpush.jpg" alt="基于备份队列"></p>
<h3 id="一种伪代码的实现">4.3.1. 一种伪代码的实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    redis.lpush(o);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 取出一个元素, 并存储备份队列</span></span><br><span class="line">    Object o = redis.brpoplpush(<span class="string">&quot;source_queue&quot;</span>, <span class="string">&quot;destination_backup_queue&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ACK </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">commit</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 从备份队列中删除</span></span><br><span class="line">    <span class="comment">// 当然这里删除操作复杂度为 O(n)，其中 n 为备份队列元素个数</span></span><br><span class="line">    jedis.lrem(<span class="string">&quot;destination_backup_queue&quot;</span>, message)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 故障恢复</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverFromCrash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 1. 取出所有未 ACK 的 message</span></span><br><span class="line">   List&lt;String&gt; messages = redis.lrange(<span class="string">&quot;destination_backup_queue&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">   <span class="comment">// 2. 遍历 messages</span></span><br><span class="line">   foreach o in messages &#123;</span><br><span class="line">       <span class="comment">// 3. 重新入队</span></span><br><span class="line">       <span class="keyword">this</span>.schedule(o);</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="另一种批量实现">4.3.2. 另一种批量实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRedisSyncInfoList</span><span class="params">(List&lt;RedisSyncInfo&gt; redisSyncInfoList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (redisSyncInfoList == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String redisKey = RedisKeyConstant.SYNC_LIST_KEY.getRedisKey();</span><br><span class="line">    List&lt;String&gt; valueList = redisSyncInfoList.stream().map(JacksonUtils::toJsonStrByJackson).collect(Collectors.toList());</span><br><span class="line">    redisTemplate.opsForList().leftPushAll(redisKey, valueList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取队列中的所有redisSyncInfo</span></span><br><span class="line"><span class="comment"> * 1. 如果备份队列不存在，则移动所有当前队列值到备份队列中</span></span><br><span class="line"><span class="comment"> * 2. 获取队列中的所有redisSyncInfo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> List&lt;RedisSyncInfo&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;RedisSyncInfo&gt; <span class="title">getRedisSyncInfoList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String redisKey = RedisKeyConstant.SYNC_LIST_KEY.getRedisKey();</span><br><span class="line">    String backUpRedisKey = RedisKeyConstant.SYNC_LIST_BACKUP_KEY.getRedisKey();</span><br><span class="line">    <span class="keyword">if</span> (!Boolean.TRUE.equals(redisTemplate.hasKey(backUpRedisKey))) &#123;</span><br><span class="line">        String element = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            element = redisTemplate.opsForList().rightPopAndLeftPush(redisKey, backUpRedisKey);</span><br><span class="line">        &#125; <span class="keyword">while</span> (element != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; values = redisTemplate.opsForList().range(backUpRedisKey, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(values)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> values.stream().map(value -&gt; JacksonUtils.convertToObject(value, RedisSyncInfo.class)).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 成功获取后，删除备份队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ackGetRedisSyncInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String backUpRedisKey = RedisKeyConstant.SYNC_LIST_BACKUP_KEY.getRedisKey();</span><br><span class="line">    redisTemplate.delete(backUpRedisKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于zset的延时消息队列">4.4. 基于zset的延时消息队列</h2><p>在日常开发中，可能经常遇到需要延时队列来处理的场景。这种场景，可以考虑使用 redis 的 zset 来实现。</p>
<p>zset 是一个有序的结构。我们可以利用zset结构中的score参数来控制延时。每次取第一个元素来判断能否处理，如果第一个元素都不能处理，说明之后的元素都没有到执行时间。</p>
<p>和list 类似，zset也需要一个备份队列来保证消息的可靠性。将消息先存入备份队列，再从原队列中删除消息，才算是取出了消息；当客户端提交了 ACK 之后，再从备份队列中删除消息</p>
<h3 id="一种伪代码实现">4.4.1. 一种伪代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 取第一个元素</span></span><br><span class="line">    Object o = jedis.zrangeWithScores(queueName, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 2. 然后和当前时间比，是否已到了处理时间</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span> || o.getScheduledAt() &gt; nowTime) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 做一些逻辑判断</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 这里为了安全起，先拿到一个元素，放入备份队列之后再从原队列中删除</span></span><br><span class="line">    <span class="comment">// 3. 先放入备份队列</span></span><br><span class="line">    jedis.hset(<span class="string">&quot;backup&quot;</span>, key, o.getContent());</span><br><span class="line">    <span class="comment">// 4. 在从 zset 中删除</span></span><br><span class="line">    jedis.zrem(queueName, o.getContent())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ACK</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">commit</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 从备份队列中删除</span></span><br><span class="line">    <span class="comment">// 时间复杂度 O(1)</span></span><br><span class="line">    jedis.hdel(<span class="string">&quot;backup&quot;</span>, key)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 故障恢复</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverFromCrash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 1. 取出所有未 ACK 的 key</span></span><br><span class="line">   List&lt;String&gt; keys = redis.hkeys(keyName);</span><br><span class="line">   <span class="comment">// 2. 遍历 keys</span></span><br><span class="line">   foreach key in keys &#123;</span><br><span class="line">       <span class="comment">// 3.重新拿到这条消息</span></span><br><span class="line">       Object o = redis.hget(keyName, key);    </span><br><span class="line">       <span class="comment">// 4. 重新入队</span></span><br><span class="line">       <span class="keyword">this</span>.schedule(o);</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消息的有序性？zset 结构本身是按照 score 有序的，因此从消息投递先后来看便是无序；你可以根据 score 参数值的大小来控制消息在队列的先后顺序<br>重复消息处理和消息可靠性保障与 list 结构实现的队列类似</p>
<h3 id="可靠性">4.4.2. 可靠性</h3><p>如何实现消息队列可靠性的三个需求？</p>
<ol>
<li><p>消息的有序性<br>zset 结构本身是按照 score 有序的，因此从消息投递先后来看便是无序；你可以根据 score 参数值的大小来控制消息在队列的先后顺序</p>
</li>
<li><p>重复消息处理<br> 与 list 结构实现的队列类似</p>
</li>
<li><p>消息可靠性保障<br> 与 list 结构实现的队列类似</p>
</li>
</ol>
<p>同样，zset的队列也完全无法扩展支持多消费者阅读同一消息功能</p>
<h2 id="基于发布订阅模式的消息队列">4.5. 基于发布订阅模式的消息队列</h2><p>可以在Redis中使用Pub&#x2F;Sub模块来支持消息多播，即发布&#x2F;订阅模式(publish&#x2F;subscribe)，它是一种消息通信模式：发布者(pub)发送消息，订阅者(sub)接收消息。</p>
<p>发布者会将的消息发布到一个chanel（通道）中而不是发送给指定的订阅者，发布者也不知道可能有哪些订阅者。</p>
<p>订阅者可以订阅一个或多个channel，只接收来自订阅的channel的消息，并且不知道有哪些（如果有）发布者，这种模式实现了消息发布者和订阅者的解耦。</p>
<p>Pub&#x2F;Sub 与键空间无关，消息不会被持久化，与数据库也无关，在db10上发布，将可以被 db1 上的订阅者听到。如果我们需要某种范围的范围，那么只能在设置的channel名字上做区分。</p>
<h3 id="严重缺陷">4.5.1. 严重缺陷</h3><p>使用Redispublish发布的消息在Redis系统中不能持久化，因此，必须先执行订阅，再等待消息发布。如果先发布了消息，那么该消息由于没有订阅者，消息将被直接丢弃。</p>
<p>消息只管发送，不管接收，也没有ACK机制，无法保证消息的消费成功。如果某个消费者中途加入进来，或者挂掉重启，那么这之前丢失的消息也不能再次消费。</p>
<p>以上的缺点导致Redis的Pub&#x2F;Sub模式就像个玩具，在生产环境中完全无法使用，非常尴尬。最终Redis的作者也不建议使用该方式作为消息队列。这里就不展开讲了。</p>
<h2 id="基于Streams的消息队列解决方案">4.6. 基于Streams的消息队列解决方案</h2><p>list 和 zset 实现的队列不能很好支持多消费者的场景。Redis 从 5.0 版本开始提供的 Streams 数据类型，是为 redis 设计的消息队列，能支持多消费组的场景。</p>
<p>Streams 支持的操作：</p>
<ul>
<li>XADD：插入消息，保证有序，可以自动生成全局唯一 ID；</li>
<li>XLEN：查询stream队列长度</li>
<li>XRANGE：返回范围数据</li>
<li>XREAD：用于读取消息，可以按 ID 读取数据，也可一次读取多个数据；</li>
<li>XGROUP：用于创建、销毁、管理消费组（类似于kafka消费组的概念）</li>
<li>XREADGROUP：按消费组+消费者形式读取消息；消息队列中的消息一旦被消费组里的一个消费者读取了，就不能再被该消费组内的其他消费者读取了。</li>
<li>XPENDING 和 XACK：XPENDING 命令可以用来查询每个消费组内所有消费者已读取但尚未确认的消息，而 XACK 命令用于向消息队列确认消息处理已完成。</li>
</ul>
<p>Streams底层：像是个仅追加内容的消息链表，把所有加入的消息都串起来，每个消息都有一个唯一的 ID 和对应的内容。并且消息是持久化的。</p>
<p>每个 Stream 都有唯一的名称，它就是 Redis 的 key，在我们首次使用 xadd 指令追加消息时自动创建。</p>
<p>Redis中Stream作为消息队列的功能十分完善，基本满足了现代消息队列的需求，可堪大用。</p>
<h1 id="总结">5. 总结</h1><p>常用的redis消息队列解决方案：</p>
<ul>
<li>redis list结构</li>
<li>zset权重延迟队列</li>
<li>publish\subscribe模式</li>
<li>stream多消费队列</li>
</ul>
<p>其中:</p>
<ol>
<li>基于list与zset的方案较简单，但不支持多播。在复杂需求中可能无法实现</li>
<li>publish\subscribe模式不支持持久化。在生产环境万一崩溃可能产生很大问题，redis作者自己最后也不推荐该模式</li>
<li>Streams 是 Redis 5.0 专门针对消息队列场景设计的数据类型。Redis 是 5.0 及 5.0 以后的版本，可以优先考虑把 Streams 用作消息队列了。</li>
</ol>
<p>总的来说，Redis作为消息队列有方便、轻量级、实现方式多等优点。但不正确的使用Redis作为消息队列，可能产生消息挤压或导致消息数据丢失。因此，redis 队列可以考虑在非核心业务或在需要快速实现的业务中使用。先衡量场景与需求、合适的技术方案才是最好的！</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>个人VPS服务器防护指南</title>
    <url>/2021/01/30/VPS-protect/</url>
    <content><![CDATA[<h1 id="服务器（VPS）防护简易指南">1. 服务器（VPS）防护简易指南</h1><p>初次自己搭服务器的同学，不久以后一般会发现自己的<code>/var/log/</code>文件夹下充满了各种各样的访问错误日志。这是因为网上充斥了各种各样的SSH攻击。直接暴力破解你的SSH密码。我曾经在一个月内有过被同一个IP连接4000多次的记录。所以出来搭服务器的同学们要学会保护自己的服务器啊。接下来就以centos为例记录一下我是如何保护我的服务器的。用其他发行版的同学可以参考。<br>主要思路就是改变SSH的登陆端口，开启防火墙，以及利用DenyHosts自动分析拦截的组合，达成防护效果。</p>
<p>参考来源：[链接][<a href="https://segmentfault.com/a/1190000021752790]">https://segmentfault.com/a/1190000021752790]</a></p>
<h1 id="查看攻击记录">2. 查看攻击记录</h1><p>大部分linux发行版都会把ssh连接的log放在<code>/var/log/</code>文件夹下。centos是secure文件，ubuntu是auth.log文件。通过查阅这些文件以及简单的使用grep等命令，我们可以知道谁在攻击（虽然这并没有什么卵用，除非你想一个个把他们拉黑名单）。</p>
<h2 id="我们可以通过如下命令查看被攻击的次数">2.1. 我们可以通过如下命令查看被攻击的次数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &quot;Failed password&quot; &#x2F;var&#x2F;log&#x2F;secure | wc -l</span><br></pre></td></tr></table></figure>

<h2 id="查看所有认证成功">2.2. 查看所有认证成功</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &quot;password&quot; &#x2F;var&#x2F;log&#x2F;secure | grep -v Failed | grep -v Invalid</span><br></pre></td></tr></table></figure>
<p>只有自己的ip，说明最近没有别人登录成功过。</p>
<h2 id="统计攻击者ip">2.3. 统计攻击者ip</h2><p>利用awk统计SSH连接记录与次数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk &#39;&#123;if($6&#x3D;&#x3D;&quot;Failed&quot;&amp;&amp;$7&#x3D;&#x3D;&quot;password&quot;)&#123;if($9&#x3D;&#x3D;&quot;invalid&quot;)&#123;ips[$13]++;users[$11]++&#125;else&#123;users[$9]++;</span><br><span class="line">ips[$11]++&#125;&#125;&#125;END&#123;for(ip in ips)&#123;print ip, ips[ip]&#125;&#125;&#39; secure* | sort -k2 -rn | head</span><br></pre></td></tr></table></figure>
<p>显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">67.5.7.148 133</span><br><span class="line">170.106.153.18 66</span><br><span class="line">64.227.115.46 56</span><br><span class="line">174.138.5.184 56</span><br><span class="line">54.38.65.215 54</span><br><span class="line">159.65.41.159 51</span><br><span class="line">152.136.133.109 46</span><br><span class="line">210.212.172.182 27</span><br><span class="line">186.146.76.6 27</span><br><span class="line">124.207.221.66 26</span><br></pre></td></tr></table></figure>

<h2 id="查看攻击者尝试用户名">2.4. 查看攻击者尝试用户名</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk &#39;&#123;if($6&#x3D;&#x3D;&quot;Failed&quot;&amp;&amp;$7&#x3D;&#x3D;&quot;password&quot;)&#123;if($9&#x3D;&#x3D;&quot;invalid&quot;)&#123;ips[$13]++;users[$11]++&#125;else&#123;users[$9]++;</span><br><span class="line">ips[$11]++&#125;&#125;&#125;END&#123;for(user in users)&#123;print user, users[user]&#125;&#125;&#39; secure* | sort -k2 -rn | headawk &#39;&#123;if($6&#x3D;&#x3D;&quot;Failed&quot;&amp;&amp;$7&#x3D;&#x3D;&quot;</span><br><span class="line">password&quot;)&#123;if($9&#x3D;&#x3D;&quot;invalid&quot;)&#123;ips[$13]++;users[$11]++&#125;else&#123;users[$9]++;ips[$11]++&#125;&#125;&#125;END&#123;for(user in users)&#123;print user, u</span><br><span class="line">sers[user]&#125;&#125;&#39; secure* | sort -k2 -rn | head</span><br></pre></td></tr></table></figure>
<p>可以看到尝试的一般是root或者admin的组合</p>
<h1 id="配置SSH登陆">3. 配置SSH登陆</h1><p>SSH的配置文件在<code>/etc/ssh/ssh_config</code>。首先，记得把本地生成的SSHkey放到<code>/当前用户~目录/.ssh/</code>的authorized_keys中，使自己的SSH公钥存放在服务器端。然后，对该配置文件进行修改。</p>
<ul>
<li>找到 Port,修改为其他你想使用的接口</li>
<li>找到 PasswordAuthentication, 设置为no。使SSH不能使用密码登陆</li>
<li>找到 PubkeyAuthentication，确保为yes。使SSH能直接通过key验证登陆</li>
</ul>
<p>然后重启SSH服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></table></figure>
<p>在本地通过<code>ssh -p 新端口 ipaddress</code>便可以直接连接到新端口了。</p>
<p>注：如果发现自己配置不对，怎么都连不上，无法修改配置，不要慌张。可以到VPS供应商提供的web版console接口中，一般能绕过防火墙和SSH配置直接登录。</p>
<h1 id="配置服务器防火墙">4. 配置服务器防火墙</h1><p>根据我们服务器的实际用途，通常我们只需要使几个部分端口便能够完成所有服务。剩余的开放端口极其容易被后台程序用于后面连接。因此推荐使用防火墙禁用其他端口。不同linux发行版的防火墙用法不同，我这里以我目前用的centos7的firewall为例。你应该根据自己情况选用适当的防火墙，如果VPS自带防火墙，使用VPS提供的自带防火墙也是不错的选择。</p>
<h2 id="firewall简单使用教程">4.1. firewall简单使用教程</h2><p>注意：centos7中的防火墙为firewall，是centos6中iptable的包装版。如果发现自己机器没有附带，使用<code>yum install firewalld</code>安装。</p>
<p>firewall功能十分强大，平常的使用分为临时与永久。另外还可以将配置区域设定为public,home,work等。这里不涉及这些设置，毕竟我们只需要默认的public一个配置。就简单写一下端口控制相关命令</p>
<p>注：直接开启防火墙很可能直接把你的SSH挤掉线，请尽量改好list再开启或使用vps提供的web console操作。</p>
<h3 id="查看状态">4.1.1. 查看状态</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure>

<h3 id="查看版本">4.1.2. 查看版本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --version</span><br></pre></td></tr></table></figure>

<h3 id="启动和停止">4.1.3. 启动和停止</h3><ol>
<li><p>启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start firewalld</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart firewalld</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="查看防火墙规则">4.1.4. 查看防火墙规则</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure>

<h3 id="端口控制">4.1.5. 端口控制</h3><h4 id="查看所有端口">4.1.5.1. 查看所有端口</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure>

<h4 id="添加端口">4.1.5.2. 添加端口</h4><p>如果不加–permanent则只临时添加，重启后失效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-port&#x3D;2888&#x2F;tcp --permanent  </span><br></pre></td></tr></table></figure>

<h4 id="删除端口">4.1.5.3. 删除端口</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --remove-port&#x3D;2888&#x2F;tcp --permanent</span><br></pre></td></tr></table></figure>

<h2 id="端口选择">4.2. 端口选择</h2><p>我的服务器只需要web服务，以及SSH控制。所以我只留了80，443和刚才设置的SSH端口。杜绝了其他一切连接。</p>
<h1 id="DenyHosts">5. DenyHosts</h1><p>如果你非常不幸，换了端口，加了防火墙，还是有无聊的家伙在用SSH暴力破解你的新端口。那你可以考虑安装DenyHosts这个软件。DenyHosts是基于Python的一个程序，它会分析SSHD的日志文件（&#x2F;var&#x2F;log&#x2F;secure等），发现同一IP在进行多次SSH密码尝试失败时就会记录该IP到&#x2F;etc&#x2F;hosts.deny文件，从而达到自动屏蔽该IP的目的。</p>
<h2 id="DenyHosts安装">5.1. DenyHosts安装</h2><h3 id="下载DenyHosts安装包。">5.1.1. 下载DenyHosts安装包。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;imcat.in&#x2F;down&#x2F;DenyHosts-2.10.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="解压DenyHosts安装包">5.1.2. 解压DenyHosts安装包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@mylnx04 ~]# tar -zxvf DenyHosts-2.10.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="开始DenyHosts的安装">5.1.3. 开始DenyHosts的安装</h3><p>安装DenyHosts前必须安装Python，当然现在绝大部分Linux主机应该都默认安装了Python。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd DenyHosts-2.10&#x2F;</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>
<h2 id="DenyHosts配置">5.2. DenyHosts配置</h2><p>复制配置文件denyhosts.cfg</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp &#x2F;usr&#x2F;share&#x2F;denyhosts&#x2F;denyhosts.cfg-dist &#x2F;usr&#x2F;share&#x2F;denyhosts&#x2F;denyhosts.cfg</span><br></pre></td></tr></table></figure>
<p>设置&#x2F;usr&#x2F;share&#x2F;denyhosts&#x2F;denyhosts.cfg相关参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PURGE_DENY </span><br><span class="line"> </span><br><span class="line">多久清除屏蔽的IP的记录。</span><br><span class="line"> </span><br><span class="line">########################################################################</span><br><span class="line">#</span><br><span class="line"># PURGE_DENY: removed HOSTS_DENY entries that are older than this time</span><br><span class="line">#             when DenyHosts is invoked with the --purge flag</span><br><span class="line">#</span><br><span class="line">#      format is: i[dhwmy]</span><br><span class="line">#      Where &#39;i&#39; is an integer (eg. 7) </span><br><span class="line">#            &#39;m&#39; &#x3D; minutes    #分钟</span><br><span class="line">#            &#39;h&#39; &#x3D; hours      #小时</span><br><span class="line">#            &#39;d&#39; &#x3D; days       #天</span><br><span class="line">#            &#39;w&#39; &#x3D; weeks      #周</span><br><span class="line">#            &#39;y&#39; &#x3D; years      #年</span><br><span class="line">#</span><br><span class="line"># never purge:</span><br><span class="line">PURGE_DENY &#x3D;              #表示所有条目永远不删除（这里才是实际的设置）</span><br><span class="line">#</span><br><span class="line"># purge entries older than 1 week</span><br><span class="line">#PURGE_DENY &#x3D; 1w        #表示删除记录超过一周的条目</span><br><span class="line">#</span><br><span class="line"># purge entries older than 5 days</span><br><span class="line">#PURGE_DENY &#x3D; 5d        #表示删除记录超过5天的条目</span><br><span class="line">#######################################################################</span><br><span class="line"> </span><br><span class="line">PURGE_THRESHOLD</span><br><span class="line"> </span><br><span class="line">定义某个host最多被清除几次。 超过PURGE_THRESHOLD值就不会被清理了。</span><br><span class="line">#######################################################################</span><br><span class="line">#</span><br><span class="line"># PURGE_THRESHOLD: defines the maximum times a host will be purged.  </span><br><span class="line"># Once this value has been exceeded then this host will not be purged. </span><br><span class="line"># Setting this parameter to 0 (the default) disables this feature.</span><br><span class="line">#</span><br><span class="line"># default: a denied host can be purged&#x2F;re-added indefinitely</span><br><span class="line">#PURGE_THRESHOLD &#x3D; 0</span><br><span class="line">#</span><br><span class="line"># a denied host will be purged at most 2 times. </span><br><span class="line">#PURGE_THRESHOLD &#x3D; 2 </span><br><span class="line">#</span><br><span class="line">#######################################################################</span><br><span class="line"> </span><br><span class="line">BLOCK_SERVICE   表示阻止的服务名。</span><br><span class="line"> </span><br><span class="line">    默认为sshd，也可以设置FTP、SMPT等。</span><br><span class="line"> </span><br><span class="line">#######################################################################</span><br><span class="line">#</span><br><span class="line"># BLOCK_SERVICE: the service name that should be blocked in HOSTS_DENY</span><br><span class="line"># </span><br><span class="line"># man 5 hosts_access for details</span><br><span class="line">#</span><br><span class="line"># eg.   sshd: 127.0.0.1  # will block sshd logins from 127.0.0.1</span><br><span class="line">#</span><br><span class="line"># To block all services for the offending host:</span><br><span class="line">#BLOCK_SERVICE &#x3D; ALL</span><br><span class="line"># To block only sshd:</span><br><span class="line">BLOCK_SERVICE  &#x3D; sshd   #禁止的服务名，当然DenyHost不仅仅用于SSH服务，还可用于SMTP等等。</span><br><span class="line"># To only record the offending host and nothing else (if using</span><br><span class="line"># an auxilary file to list the hosts).  Refer to: </span><br><span class="line"># http:&#x2F;&#x2F;denyhosts.sourceforge.net&#x2F;faq.html#aux</span><br><span class="line">#BLOCK_SERVICE &#x3D;    </span><br><span class="line">#</span><br><span class="line">#######################################################################</span><br><span class="line"> </span><br><span class="line">DENY_THRESHOLD_INVALID </span><br><span class="line"> </span><br><span class="line">允许无效用户登录失败的次数</span><br><span class="line"> </span><br><span class="line">#######################################################################</span><br><span class="line">#</span><br><span class="line"># DENY_THRESHOLD_INVALID: block each host after the number of failed login </span><br><span class="line"># attempts has exceeded this value.  This value applies to invalid</span><br><span class="line"># user login attempts (eg. non-existent user accounts)</span><br><span class="line">#</span><br><span class="line">DENY_THRESHOLD_INVALID &#x3D; 1  #允许无效用户登录失败的次数</span><br><span class="line">#</span><br><span class="line">#######################################################################</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">DENY_THRESHOLD_VALID</span><br><span class="line"> </span><br><span class="line">    允许有效（普通用户）用户登陆失败的次数</span><br><span class="line">#######################################################################</span><br><span class="line">#</span><br><span class="line"># DENY_THRESHOLD_VALID: block each host after the number of failed </span><br><span class="line"># login attempts has exceeded this value.  This value applies to valid</span><br><span class="line"># user login attempts (eg. user accounts that exist in &#x2F;etc&#x2F;passwd) except</span><br><span class="line"># for the &quot;root&quot; user</span><br><span class="line">#</span><br><span class="line">DENY_THRESHOLD_VALID &#x3D; 5 #允许普通用户登陆失败的次数</span><br><span class="line">#</span><br><span class="line">#######################################################################</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">DENY_THRESHOLD_ROOT</span><br><span class="line"> </span><br><span class="line">允许root登录失败的次数。</span><br><span class="line"> </span><br><span class="line">#######################################################################</span><br><span class="line">#</span><br><span class="line"># DENY_THRESHOLD_ROOT: block each host after the number of failed </span><br><span class="line"># login attempts has exceeded this value.  This value applies to </span><br><span class="line"># &quot;root&quot; user login attempts only.</span><br><span class="line">#</span><br><span class="line">DENY_THRESHOLD_ROOT &#x3D; 1  #允许root登陆失败的次数</span><br><span class="line">#</span><br><span class="line">#######################################################################</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">DENY_THRESHOLD_RESTRICTED 设定DenyHost 写入到该资料夹</span><br><span class="line">#######################################################################</span><br><span class="line">#</span><br><span class="line"># DENY_THRESHOLD_RESTRICTED: block each host after the number of failed </span><br><span class="line"># login attempts has exceeded this value.  This value applies to </span><br><span class="line"># usernames that appear in the WORK_DIR&#x2F;restricted-usernames file only.</span><br><span class="line">#</span><br><span class="line">DENY_THRESHOLD_RESTRICTED &#x3D; 1</span><br><span class="line">#</span><br><span class="line">#######################################################################</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">DAEMON_PURGE</span><br><span class="line"> </span><br><span class="line">表示DenyHosts在守护进程模式下运行的频率，运行清除机制清除HOSTS_DENY中的过期的记录</span><br><span class="line">如果PURGE_DENY为空，这没有任何效果。</span><br><span class="line">#######################################################################</span><br><span class="line">#</span><br><span class="line"># DAEMON_PURGE: How often should DenyHosts, when run in daemon mode,</span><br><span class="line"># run the purge mechanism to expire old entries in HOSTS_DENY</span><br><span class="line"># This has no effect if PURGE_DENY is blank.</span><br><span class="line">#</span><br><span class="line">DAEMON_PURGE &#x3D; 1h</span><br><span class="line">#</span><br><span class="line">#######################################################################</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="设置DenyHost启动">5.2.1. 设置DenyHost启动</h3><p>启动或重启DenyHosts服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#service denyhosts restart</span><br></pre></td></tr></table></figure>

<h1 id="总结">6. 总结</h1><p>对于一般的个人服务器用户来说，改变SSH端口加防火墙的策略就能隔绝大部分攻击。攻击者一般不愿意从65536个端口中猜测你的新端口，基本上杜绝了收到攻击。DenyHost一般是无法改变端口后的补救措施，还会损失部分连接性能，一般只建议懒人使用。对于公司的大型正式服务器，一般需要设置仅限堡垒机和跳板机或者仅限内网访问，杜绝一切连接可能。</p>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title>WSL2相关配置</title>
    <url>/2021/03/04/WSl-config/</url>
    <content><![CDATA[<h1 id="WSL配置">1. WSL配置</h1><p>参考<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-win10">微软官方配置教程</a><br>以下的bash命令都需要用管理员身份打开PowerShell运行</p>
<h2 id="Windows版本">1.1. Windows版本</h2><p>确保windows版本大于1903.18362</p>
<h2 id="启用WSL子系统功能">1.2. 启用WSL子系统功能</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart</span><br></pre></td></tr></table></figure>

<h2 id="启用虚拟机功能">1.3. 启用虚拟机功能</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></table></figure>

<h2 id="下载Linux内核包">1.4. 下载Linux内核包</h2><p><a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">适用于 x64 计算机的 WSL2 Linux 内核更新包</a></p>
<h2 id="WSL2设为默认版本">1.5. WSL2设为默认版本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --set-default-version 2</span><br></pre></td></tr></table></figure>
<h2 id="安装Linux分发">1.6. 安装Linux分发</h2><p>打开Microsoft Store并选择Linux分发版，根据默认版本会直接下载运行</p>
<h2 id="查看版本">1.7. 查看版本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl -s -v</span><br></pre></td></tr></table></figure>

<h2 id="启动">1.8. 启动</h2><p>启动后自动打开cmd窗口，设置用户名和密码</p>
<h1 id="配置">2. 配置</h1><h2 id="Windows-Terminal">2.1. Windows Terminal</h2><p>在PowerShell中输入如下命令，获取一个guid</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">new-guid</span><br></pre></td></tr></table></figure>
<p>直接在Windows Terminal的setting.profile.list中加入如下配置，就可以把wsl加入配置中</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;guid&quot;</span>: <span class="string">&quot;&#123;新获取的guid&#125;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hidden&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Ubuntu&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;source&quot;</span>: <span class="string">&quot;Windows.Terminal.Wsl&quot;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="默认启动路径">2.2. 默认启动路径</h2><p>在Windows Terminal的Ubuntu配置中加一句</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;startingDirectory&quot;: &quot;//wsl$/Ubuntu/home/&lt;yourname&gt;/&quot;</span><br></pre></td></tr></table></figure>

<h2 id="Ubuntu替换清华源">2.3. Ubuntu替换清华源</h2><ol>
<li><p>首先需要使用root用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo -i </span><br></pre></td></tr></table></figure>
</li>
<li><p>进行原来源的备份</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp /etc/apt/sources.list /etc/apt/sources.list.bak </span><br></pre></td></tr></table></figure>
</li>
<li><p>清空source.list</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;&#x27;</span> &gt; /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
</li>
<li><p>进行源列表的修改<br>复制并添加源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/apt/sources.list </span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="oh-my-zsh配置">2.4. oh-my-zsh配置</h2><ol>
<li><p>安装ZSH</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install zsh</span><br><span class="line">$ zsh --version</span><br><span class="line">zsh 5.8 (x86_64-ubuntu-linux-gnu)</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装oh-my-zsh</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置主题<br>需要编辑.zshrc文件，然后使用source刷新</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.zshrc</span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>
<p>我喜欢dst主题，修改<code>ZSH_THEME=&quot;dst&quot;</code>即可</p>
</li>
</ol>
<h2 id="git-status错误">2.5. git status错误</h2><p>git在wsl下读取windows中的repo会出现所有文件都modified的错误，是因为linux与windows的文件结尾不同导致的。使用如下命令解决</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global core.autocrlf <span class="literal">true</span></span><br><span class="line">git config --global core.filemode <span class="literal">false</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Java复健系列(2)：Java的类与对象</title>
    <url>/2020/10/18/Java-review-2/</url>
    <content><![CDATA[<h1 id="类的定义">1. 类的定义</h1><p>对示例的说明：</p>
<ul>
<li>public 是类的修饰符，表明该类是公共类，可以被其他类访问。修饰符将在下节讲解。</li>
<li>class 是定义类的关键字。</li>
<li>Dog 是类名称。</li>
<li>name、age是类的成员变量，也叫属性；bark()、hungry() 是类中的函数，也叫方法。</li>
</ul>
<p>一个类可以包含以下类型变量：</p>
<ul>
<li>局部变量：在方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li>
<li>成员变量：成员变量是定义在类中、方法体之外的变量。这种变量在创建对象的时候实例化（分配内存）。成员变量可以被类中的方法和特定类的语句访问。</li>
<li>类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。static 也是修饰符的一种，将在下节讲解。</li>
</ul>
<h2 id="构造方法">1.1. 构造方法</h2><ul>
<li><p>在类实例化的过程中自动执行的方法叫做构造方法，它不需要你手动调用。构造方法可以在类实例化的过程中做一些初始化的工作。</p>
</li>
<li><p>构造方法的名称必须与类的名称相同，并且没有返回值。</p>
</li>
<li><p>每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认的构造方法。</p>
</li>
<li><p>构造方法不能被显示调用。</p>
</li>
<li><p>构造方法不能有返回值，因为没有变量来接收返回值。</p>
</li>
<li><p>构造方法前可以添加修饰符</p>
</li>
</ul>
<p>特性：</p>
<ul>
<li>名字与类名相同。</li>
<li>没有返回值，但不能用 void 声明构造函数。</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ul>
<h2 id="在-Java-中定义一个不做事且没有参数的构造方法的作用">1.2. 在 Java 中定义一个不做事且没有参数的构造方法的作用</h2><p>Java 程序在执行子类的构造方法之前，如果没有用 super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super()来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p>
<h2 id="创建对象">1.3. 创建对象</h2><p>对象是类的一个实例，创建对象的过程也叫类的实例化。对象是以类为模板来创建的。</p>
<p>在Java中，使用new关键字来创建对象，一般有以下三个步骤：</p>
<ul>
<li>声明：声明一个对象，包括对象名称和对象类型。</li>
<li>实例化：使用关键字new来创建一个对象。</li>
<li>初始化：使用new创建对象时，会调用构造方法初始化对象。</li>
</ul>
<h2 id="对象实例与对象引用有何不同">1.4. 对象实例与对象引用有何不同?</h2><p>对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p>
<h2 id="成员变量与局部变量的区别有哪些？">1.5. 成员变量与局部变量的区别有哪些？</h2><ol>
<li>从语法形式上看:成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li>
<li>从变量在内存中的存储方式来看:如果成员变量是使用static修饰的，那么这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li>
<li>从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li>
<li>成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li>
</ol>
<h1 id="访问修饰符">2. 访问修饰符</h1><table>
<thead>
<tr>
<th>修饰符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>公有，对所有类可见</td>
</tr>
<tr>
<td>protected</td>
<td>受保护的，对同一包内类和所有子类可见</td>
</tr>
<tr>
<td>private</td>
<td>私有的，同一类内可见</td>
</tr>
<tr>
<td>默认</td>
<td>同一包内可见，默认无修饰符</td>
</tr>
</tbody></table>
<p>protected and private 不能修饰类和接口</p>
<h2 id="public">2.1. public</h2><p>由于类的继承性，类所有的public方法和变量都能被其子类继承。</p>
<h2 id="protected">2.2. protected</h2><p>基类的 protected 成员是包内可见的，并且对子类可见；<br>若子类与基类不在同一包中，那么在子类中，子类实例可以访问其从基类继承而来的protected方法，而不能访问基类实例的protected方法。</p>
<h2 id="private">2.3. private</h2><p>private变量通过get&#x2F;set函数访问</p>
<h2 id="默认的：不使用任何关键字">2.4. 默认的：不使用任何关键字</h2><p>不使用任何修饰符声明的属性和方法，对同一个包内的类是可见的。接口里的变量都隐式声明为public static final，而接口里的方法默认情况下访问权限为public。</p>
<h2 id="关键字的继承">2.5. 关键字的继承</h2><ul>
<li>父类中声明为public的方法在子类中也必须为public。</li>
<li>父类中声明为protected的方法在子类中要么声明为protected，要么声明为public。不能声明为private。</li>
<li>父类中默认修饰符声明的方法，能够在子类中声明为private。</li>
<li>父类中声明为private的方法，不能够被继承。</li>
</ul>
<h1 id="作用域">3. 作用域</h1><ul>
<li>类级变量：又称全局级变量或静态变量，需要使用static关键字修饰，你可以与 C&#x2F;C++ 中的 static 变量对比学习。类级变量在类定义后就已经存在，占用内存空间，可以通过类名来访问，不需要实例化。</li>
<li>对象实例级变量：就是成员变量，实例化后才会分配内存空间，才能访问。</li>
<li>方法级变量：就是在方法内部定义的变量，就是局部变量。</li>
<li>块级变量：就是定义在一个块内部的变量，变量的生存周期就是这个块，出了这个块就消失了，比如 if、for 语句的块。块是指由大括号包围的代码，例如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">int age &#x3D; 3;</span><br><span class="line">    String name &#x3D; &quot;www.yq1012.com&quot;;</span><br><span class="line">    &#x2F;&#x2F; 正确，在块内部可以访问 age 和 name 变量</span><br><span class="line">    System.out.println( name + &quot;已经&quot; + age + &quot;岁了&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 错误，在块外部无法访问 age 和 name 变量</span><br><span class="line">System.out.println( name + &quot;已经&quot; + age + &quot;岁了&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>说明</p>
<ul>
<li>方法内部除了能访问方法级的变量，还可以访问类级和实例级的变量。</li>
<li>块内部能够访问类级、实例级变量，如果块被包含在方法内部，它还可以访问方法级的变量。</li>
<li>方法级和块级的变量必须被显示地初始化，否则不能访问。</li>
</ul>
<h2 id="This">3.1. This</h2><p>this 关键字用来表示当前对象本身，或当前类的一个实例，通过 this 可以调用本对象的所有方法和属性。this 只有在类实例化后才有意义。</p>
<h3 id="使用this区分同名变量">3.1.1. 使用this区分同名变量</h3><p>成员变量与方法内部的变量重名时，希望在方法内部调用成员变量，这时候只能使用this。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">	public String name;</span><br><span class="line">    public int age;</span><br><span class="line">    &#x2F;&#x2F;构造方法</span><br><span class="line">    public Demo()&#123;</span><br><span class="line">        this(&quot;程序员&quot;, 3);</span><br><span class="line">    &#125;</span><br><span class="line">    public Demo(String name, int age)&#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="作为方法名来初始化对象">3.1.2. 作为方法名来初始化对象</h3><ul>
<li>在构造方法中调用另一个构造方法，调用动作必须置于最起始的位置。</li>
<li>不能在构造方法以外的任何方法内调用构造方法。</li>
<li>在一个构造方法内只能调用一个构造方法。</li>
</ul>
<h3 id="作为参数传递">3.1.3. 作为参数传递</h3><p>需要在某些完全分离的类中调用一个方法，并将当前对象的一个引用作为参数传递时。</p>
<h2 id="成员变量与局部变量的区别有哪些？-1">3.2. 成员变量与局部变量的区别有哪些？</h2><ol>
<li>从语法形式上看:成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li>
<li>从变量在内存中的存储方式来看:如果成员变量是使用static修饰的，那么这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li>
<li>从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li>
<li>成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），</li>
</ol>
<h1 id="方法重载">4. 方法重载</h1><p>在Java中，同一个类中的多个方法可以有相同的名字，只要它们的参数列表不同就可以，这被称为方法重载(method overloading)。参数列表又叫参数签名，包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同。</p>
<p>重载是面向对象的一个基本特性。方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错，这叫做重载分辨。</p>
<ul>
<li>参数列表不同包括：个数不同、类型不同和顺序不同。</li>
<li>仅仅参数变量名称不同是不可以的。</li>
<li>跟成员方法一样，构造方法也可以重载。</li>
<li>声明为final的方法不能被重载。</li>
<li>声明为static的方法不能被重载，但是能够被再次声明。</li>
</ul>
<h1 id="类创建时的基本运行顺序">5. 类创建时的基本运行顺序</h1><ul>
<li>main</li>
<li>class init</li>
<li>class 构造函数</li>
<li>new 完成，继续main</li>
<li>执行完毕</li>
</ul>
<h1 id="声明规则">6. 声明规则</h1><ul>
<li>一个源文件中只能有一个public类。</li>
<li>一个源文件可以有多个非public类。</li>
<li>源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java。</li>
<li>如果一个类定义在某个包中，那么package语句应该在源文件的首行。</li>
<li>如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。</li>
<li>import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</li>
<li>类有若干种访问级别，并且类也分不同的类型：抽象类和final类等。这些将在后续章节介绍。</li>
<li>除了上面提到的几种类型，Java还有一些特殊的类，如内部类、匿名类。</li>
</ul>
<h1 id="其他">7. 其他</h1><h2 id="StringBuilder与StringBuffer">7.1. StringBuilder与StringBuffer</h2><p>简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，private final char value[]，所以 String 对象是不可变的。在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 private final byte[] value;</p>
<p>而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串char[]value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p>
<p>线程安全性：String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p>性能：每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<ol>
<li>操作少量的数据: 适用 String</li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder</li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</li>
</ol>
<h2 id="Object类">7.2. Object类</h2><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final native Class&lt;?&gt; getClass()&#x2F;&#x2F;native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span><br><span class="line"></span><br><span class="line">public native int hashCode() &#x2F;&#x2F;native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。</span><br><span class="line">public boolean equals(Object obj)&#x2F;&#x2F;用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span><br><span class="line"></span><br><span class="line">protected native Object clone() throws CloneNotSupportedException&#x2F;&#x2F;naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() !&#x3D; x 为true，x.clone().getClass() &#x3D;&#x3D; x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span><br><span class="line"></span><br><span class="line">public String toString()&#x2F;&#x2F;返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</span><br><span class="line"></span><br><span class="line">public final native void notify()&#x2F;&#x2F;native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span><br><span class="line"></span><br><span class="line">public final native void notifyAll()&#x2F;&#x2F;native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span><br><span class="line"></span><br><span class="line">public final native void wait(long timeout) throws InterruptedException&#x2F;&#x2F;native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span><br><span class="line"></span><br><span class="line">public final void wait(long timeout, int nanos) throws InterruptedException&#x2F;&#x2F;多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span><br><span class="line"></span><br><span class="line">public final void wait() throws InterruptedException&#x2F;&#x2F;跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span><br><span class="line"></span><br><span class="line">protected void finalize() throws Throwable &#123; &#125;&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="BigDecimal">7.3. BigDecimal</h2><h3 id="BigDecimal-的用处">7.3.1. BigDecimal 的用处</h3><p>《阿里巴巴Java开发手册》中提到：<strong>浮点数之间的等值判断，基本数据类型不能用&#x3D;&#x3D;来比较，包装数据类型不能用 equals 来判断。</strong> 具体原理和浮点数的编码方式有关，这里就不多提了，我们下面直接上实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> a = <span class="number">1.0f</span> - <span class="number">0.9f</span>;</span><br><span class="line"><span class="keyword">float</span> b = <span class="number">0.9f</span> - <span class="number">0.8f</span>;</span><br><span class="line">System.out.println(a);<span class="comment">// 0.100000024</span></span><br><span class="line">System.out.println(b);<span class="comment">// 0.099999964</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>具有基本数学知识的我们很清楚的知道输出并不是我们想要的结果（<strong>精度丢失</strong>），我们如何解决这个问题呢？一种很常用的方法是：<strong>使用使用 BigDecimal 来定义浮点数的值，再进行浮点数的运算操作。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal a = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">BigDecimal c = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line">BigDecimal x = a.subtract(b); </span><br><span class="line">BigDecimal y = b.subtract(c); </span><br><span class="line"></span><br><span class="line">System.out.println(x); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(y); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(Objects.equals(x, y)); <span class="comment">/* true */</span></span><br></pre></td></tr></table></figure>

<h3 id="BigDecimal-的大小比较">7.3.2. BigDecimal 的大小比较</h3><p><code>a.compareTo(b)</code> : 返回 -1 表示 <code>a</code> 小于 <code>b</code>，0 表示 <code>a</code> 等于 <code>b</code> ， 1表示 <code>a</code> 大于 <code>b</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal a = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">System.out.println(a.compareTo(b));<span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="BigDecimal-保留几位小数">7.3.3. BigDecimal 保留几位小数</h3><p>通过 <code>setScale</code>方法设置保留几位小数以及保留规则。保留规则有挺多种，不需要记，IDEA会提示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal m = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.255433&quot;</span>);</span><br><span class="line">BigDecimal n = m.setScale(<span class="number">3</span>,BigDecimal.ROUND_HALF_DOWN);</span><br><span class="line">System.out.println(n);<span class="comment">// 1.255</span></span><br></pre></td></tr></table></figure>

<h3 id="BigDecimal-的使用注意事项">7.3.4. BigDecimal 的使用注意事项</h3><p>注意：我们在使用BigDecimal时，为了防止精度丢失，推荐使用它的 <strong>BigDecimal(String)</strong> 构造方法来创建对象。</p>
<h3 id="总结">7.3.5. 总结</h3><p>BigDecimal 主要用来操作（大）浮点数，BigInteger 主要用来操作大整数（超过 long 类型）。</p>
<p>BigDecimal 的实现利用到了 BigInteger, 所不同的是 BigDecimal 加入了小数位的概念</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java复健系列(3)：Java的面向对象</title>
    <url>/2020/10/18/Java-review-3/</url>
    <content><![CDATA[<h1 id="面向对象三大特征">1. 面向对象三大特征</h1><h2 id="封装">1.1. 封装</h2><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。</p>
<h2 id="继承">1.2. 继承</h2><p>不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<ul>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
</ul>
<h2 id="多态">1.3. 多态</h2><p>多态，顾名思义，表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例。</p>
<ul>
<li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li>
<li>对象类型不可变，引用类型可变；</li>
<li>方法具有多态性，属性不具有多态性；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
<h1 id="继承-1">2. 继承</h1><h2 id="继承-2">2.1. 继承</h2><p>关键字 extend</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class People&#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    int height;</span><br><span class="line">   </span><br><span class="line">    void say()&#123;</span><br><span class="line">        System.out.println(&quot;我的名字是 &quot; + name + &quot;，年龄是 &quot; + age + &quot;，身高是 &quot; + height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Teacher extends People&#123;</span><br><span class="line">    String school;  &#x2F;&#x2F; 所在学校</span><br><span class="line">    String subject;  &#x2F;&#x2F; 学科</span><br><span class="line">    int seniority;  &#x2F;&#x2F; 教龄</span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F; 覆盖 People 类中的 say() 方法</span><br><span class="line">    void say()&#123;</span><br><span class="line">        System.out.println(&quot;我叫&quot; + name + &quot;，在&quot; + school + &quot;教&quot; + subject + &quot;，有&quot; + seniority + &quot;年教龄&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    void lecturing()&#123;</span><br><span class="line">        System.out.println(&quot;我已经&quot; + age + &quot;岁了，依然站在讲台上讲课&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>子类可以覆盖父类的方法。</li>
<li>子类可以继承父类除private以为的所有的成员。</li>
<li>构造方法不能被继承。</li>
</ul>
<p>单继承性：Java 允许一个类仅能继承一个其它类，即一个类只能有一个父类，这个限制被称做单继承性。后面将会学到接口(interface)的概念，接口允许多继承。</p>
<h2 id="super-关键字">2.2. super 关键字</h2><p>super 用来表示父类。super 可以用在子类中，通过点号(.)来获取父类的成员变量和方法。super 也可以用在子类的子类中，Java 能自动向上层类追溯。父类行为被调用，就好象该行为是本类的行为一样，而且调用行为不必发生在父类中，它能自动向上层类追溯。<br>super 关键字的功能：</p>
<ul>
<li>调用父类中声明为 private 的变量。</li>
<li>点取已经覆盖了的方法。</li>
<li>作为方法名表示父类构造方法。</li>
</ul>
<p>Java 具有追溯性，会一直向上找，直到找到该方法为止。通过 super 调用父类的private隐藏变量，必须要在父类中声明 getter 方法，因为声明为 private 的数据成员对子类是不可见的。</p>
<p>最后注意 super 与 this 的区别：super 不是一个对象的引用，不能将 super 赋值给另一个对象变量，它只是一个指示编译器调用父类方法的特殊关键字。</p>
<h3 id="调用父类方法">2.2.1. 调用父类方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Animal&#123;</span><br><span class="line">    String name;</span><br><span class="line">    public Animal(String name)&#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line">    int age;</span><br><span class="line">    public Dog(String name, int age)&#123;</span><br><span class="line">        super(name);</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在构造方法中调用另一个构造方法，调用动作必须置于最起始的位置。</li>
<li>不能在构造方法以外的任何方法内调用构造方法。</li>
<li>在一个构造方法内只能调用一个构造方法。</li>
</ul>
<p>如果编写一个构造方法，既没有调用 super() 也没有调用 this()，编译器会自动插入一个调用到父类构造方法中，而且不带参数。</p>
<h2 id="重写和重载">2.3. 重写和重载</h2><h3 id="重写（Override）">2.3.1. 重写（Override）</h3><p>在类继承中，子类可以修改从父类继承来的方法，也就是说子类能创建一个与父类方法有不同功能的方法，但具有相同的名称、返回值类型、参数列表。如果在新类中定义一个方法，其名称、返回值类型和参数列表正好与父类中的相同，那么，新方法被称做重写旧方法。参数列表又叫参数签名，包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同。被覆盖的方法在子类中只能通过super调用。</p>
<p>注意：重写不会删除父类中的方法，而是对子类的实例隐藏，暂时不使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">    String name;</span><br><span class="line">    public Animal(String name)&#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public void say()&#123;</span><br><span class="line">        System.out.println(&quot;我是一只小动物，我的名字叫&quot; + name + &quot;，我会发出叫声&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line">    &#x2F;&#x2F; 构造方法不能被继承，通过super()调用</span><br><span class="line">    public Dog(String name)&#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 覆盖say() 方法</span><br><span class="line">    public void say()&#123;</span><br><span class="line">        System.out.println(&quot;我是一只小狗，我的名字叫&quot; + name + &quot;，我会发出汪的叫声&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原则：</p>
<ul>
<li>覆盖方法的返回类型、方法名称、参数列表必须与原方法的相同。</li>
<li>覆盖方法不能比原方法访问性差（即访问权限不允许缩小）。</li>
<li>覆盖方法不能比原方法抛出更多的异常。</li>
<li>被覆盖的方法不能是final类型，因为final修饰的方法是无法覆盖的。</li>
<li>被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。</li>
<li>被覆盖的方法不能为static。如果父类中的方法为静态的，而子类中的方法不是静态的，但是两个方法除了这一点外其他都满足覆盖条件，那么会发生编译错误；反之亦然。即使父类和子类中的方法都是静态的，并且满足覆盖条件，但是仍然不会发生覆盖，因为静态方法是在编译的时候把静态方法和类的引用类型进行匹配。</li>
</ul>
<h3 id="重载Overload">2.3.2. 重载Overload</h3><p>前面已经对Java方法重载进行了说明，这里再强调一下，Java父类和子类中的方法都会参与重载，例如，父类中有一个方法是 func(){ … }，子类中有一个方法是 func(int i){ … }，就构成了方法的重载。</p>
<p>覆盖和重载的不同：</p>
<p>方法覆盖要求参数列表必须一致，而方法重载要求参数列表必须不一致。<br>方法覆盖要求返回类型必须一致，方法重载对此没有要求。<br>方法覆盖只能用于子类覆盖父类的方法，方法重载用于同一个类中的所有方法（包括从父类中继承而来的方法）。<br>方法覆盖对方法的访问权限和抛出的异常有特殊的要求，而方法重载在这方面没有任何限制。<br>父类的一个方法只能被子类覆盖一次，而一个方法可以在所有的类中可以被重载多次</p>
<h2 id="重写与重载之间的区别">2.4. 重写与重载之间的区别</h2><table>
<thead>
<tr>
<th>区别点</th>
<th>重载方法</th>
<th>重写方法</th>
</tr>
</thead>
<tbody><tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可以修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>异常</td>
<td>可以修改</td>
<td>可以减少或删除，一定不能抛出新的或者更广的异常</td>
</tr>
<tr>
<td>访问</td>
<td>可以修改</td>
<td>一定不能做更严格的限制（可以降低限制）</td>
</tr>
</tbody></table>
<h1 id="多态-1">3. 多态</h1><p>必要条件</p>
<ul>
<li>继承</li>
<li>重写</li>
<li>父类引用指向子类对象<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Animal obj &#x3D; new Animal();</span><br><span class="line">        obj.cry();</span><br><span class="line">        obj &#x3D; new Cat();</span><br><span class="line">        obj.cry();</span><br><span class="line">        obj &#x3D; new Dog();</span><br><span class="line">        obj.cry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Animal&#123;</span><br><span class="line">    &#x2F;&#x2F; 动物的叫声</span><br><span class="line">    public void cry()&#123;</span><br><span class="line">        System.out.println(&quot;不叫&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line">class Cat extends Animal&#123;</span><br><span class="line">    &#x2F;&#x2F; 猫的叫声</span><br><span class="line">    public void cry()&#123;</span><br><span class="line">        System.out.println(&quot;喵&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line">    &#x2F;&#x2F; 狗的叫声</span><br><span class="line">    public void cry()&#123;</span><br><span class="line">        System.out.println(&quot;汪&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>多态的一个好处是：当子类比较多时，也不需要定义多个变量，可以只定义一个父类类型的变量来引用不同子类的实例</p>
<h2 id="动态绑定">3.1. 动态绑定</h2><p>Java调用方法详细流程</p>
<ul>
<li>编译器查看对象声明类型和方法名。一一列举所有类中名为func的方法和其父类中访问属性为 public 且名为func的方法。这样，编译器就获得了所有可能被调用的候选方法列表。</li>
<li>检查调用方法时提供的参数签名。重载解析（overloading resolution）。编译器自动选举对应参数签名的函数。如果没有匹配，则编译错误</li>
<li>如果方法的修饰符是private、static、final（static和final将在后续讲解），或者是构造方法，那么编译器将可以准确地知道应该调用哪个方法，我们将这种调用方式 称为静态绑定(static binding)。</li>
<li>当程序运行，并且釆用动态绑定调用方法时，JVM一定会调用与 obj 所引用对象的实际类型最合适的那个类的方法。</li>
</ul>
<p>每次调用方法都要进行搜索，时间开销相当大，因此，JVM预先为每个类创建了一个方法表(method lable)，其中列出了所有方法的名称、参数签名和所属的类。这样一来，在真正调用方法的时候，虚拟机仅查找这个表就行了。</p>
<h2 id="instanceof-运算符">3.2. instanceof 运算符</h2><p>多态性带来了一个问题，就是如何判断一个变量所实际引用的对象的类型 。 C++使用runtime-type information(RTTI)，Java 使用 instanceof 操作符。instanceof 运算符用来判断一个变量所引用的对象的实际类型，注意是它引用的对象的类型，不是变量的类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">variable instanceof classname</span><br></pre></td></tr></table></figure>
<p>如果变量引用的是当前类或它的子类的实例，instanceof 返回 true，否则返回 false。</p>
<h2 id="多态对象的类型转换">3.3. 多态对象的类型转换</h2><p>我们将子类向父类转换称为“向上转型”，将父类向子类转换称为“向下转型”。很多时候，我们会将变量定义为父类的类型，却引用子类的对象，这个过程就是向上转型。程序运行时通过动态绑定来实现对子类方法的调用，也就是多态性。然而有些时候为了完成某些父类没有的功能，我们需要将向上转型后的子类对象再转成子类，调用子类的方法，这就是向下转型。<br>注意：不能直接将父类的对象强制转换为子类类型，只能将向上转型后的子类对象再次转换为子类类型。也就是说，子类对象必须向上转型后，才能再向下转型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Demo &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        SuperClass superObj &#x3D; new SuperClass();</span><br><span class="line">        SonClass sonObj &#x3D; new SonClass();</span><br><span class="line">        &#x2F;&#x2F; 下面的代码运行时会抛出异常，不能将父类对象直接转换为子类类型</span><br><span class="line">        &#x2F;&#x2F; SonClass sonObj2 &#x3D; (SonClass)superObj;</span><br><span class="line">        &#x2F;&#x2F; 先向上转型，再向下转型</span><br><span class="line">        superObj &#x3D; sonObj;</span><br><span class="line">        SonClass sonObj1 &#x3D; (SonClass)superObj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class SuperClass&#123; &#125;</span><br><span class="line">class SonClass extends SuperClass&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>因为向下转型存在风险，所以在接收到父类的一个引用时，请务必使用 instanceof 运算符来判断该对象是否是你所要的子类。</p>
<h1 id="内部类">4. 内部类</h1><p>在 Java 中，允许在一个类（或方法、语句块）的内部定义另一个类，称为内部类(Inner Class)，有时也称为嵌套类(Nested Class)。</p>
<p>内部类和外层封装它的类之间存在逻辑上的所属关系，一般只用在定义它的类或语句块之内，实现一些没有通用意义的功能逻辑，在外部引用它时必须给出完整的名称。</p>
<p>使用内部类的主要原因有：</p>
<ul>
<li>内部类可以访问外部类中的数据，包括私有的数据。</li>
<li>内部类可以对同一个包中的其他类隐藏起来。</li>
<li>当想要定义一个回调函数且不想编写大量代码时，使用匿名(anonymous)内部类比较便捷。</li>
<li>减少类的命名冲突。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    private int size;</span><br><span class="line">    public class Inner &#123;</span><br><span class="line">        private int counter &#x3D; 10;</span><br><span class="line">        public void doStuff() &#123;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Demo outer &#x3D; new Demo();</span><br><span class="line">        Inner inner &#x3D; outer.new Inner();</span><br><span class="line">        inner.doStuff();</span><br><span class="line">        System.out.println(outer.size);</span><br><span class="line">        System.out.println(inner.counter);</span><br><span class="line">        &#x2F;&#x2F; 编译错误，外部类不能访问内部类的变量</span><br><span class="line">&#x2F;&#x2F;        System.out.println(counter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译，会生成两个 <code>.class </code>文件：<code>Outer.class</code> 和 <code>Outer$Inner.class</code>。也就是说，内部类会被编译成独立的字节码文件。内部类是一种编译器现象，与虚拟机无关。编译器将会把内部类翻译成用<code>$</code>符号分隔外部类名与内部类名的常规类文件，而虚拟机则对此一无所知。</p>
<p>注意：必须先有外部类的对象才能生成内部类的对象，因为内部类有时需要访问外部类中的成员变量，成员变量必须实例化才有意义。</p>
<p>内部类是 Java 1.1 的新增特性，有些程序员认为这是一个值得称赞的进步，但是内部类的语法很复杂，严重破坏了良好的代码结构， 违背了Java要比C++更加简单的设计理念。</p>
<h2 id="内部类的分类">4.1. 内部类的分类</h2><p>内部类可以是静态(static)的，可以使用 public、protected 和 private 访问控制符，而外部类只能使用 public，或者默认。</p>
<p>在外部类内部直接定义（不在方法内部或代码块内部）的类就是成员式内部类，它可以直接使用外部类的所有变量和方法，即使是 private 的。外部类要想访问内部类的成员变量和方法，则需要通过内部类的对象来获取。</p>
<h1 id="抽象类">5. 抽象类</h1><p>在自上而下的继承层次结构中，位于上层的类更具有通用性，甚至可能更加抽象。从某种角度看，祖先类更加通用，它只包含一些最基本的成员，人们只将它作为派生其他类的基类，而不会用来创建对象。甚至，你可以只给出方法的定义而不实现，由子类根据具体需求来具体实现。这种只给出方法定义而不具体实现的方法被称为抽象方法，抽象方法是没有方法体的，在代码的表达上就是没有“{}”。包含一个或多个抽象方法的类也必须被声明为抽象类。</p>
<p>抽象类除了包含抽象方法外，还可以包含具体的变量和具体的方法。类即使不包含抽象方法，也可以被声明为抽象类，防止被实例化。抽象类不能被实例化，抽象方法必须在子类中被实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import static java.lang.System.*;</span><br><span class="line">public  class Demo&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Teacher t &#x3D; new Teacher();</span><br><span class="line">        t.setName(&quot;王明&quot;);</span><br><span class="line">        t.work();</span><br><span class="line">       </span><br><span class="line">        Driver d &#x3D; new Driver();</span><br><span class="line">        d.setName(&quot;小陈&quot;);</span><br><span class="line">        d.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 定义一个抽象类</span><br><span class="line">abstract class People&#123;</span><br><span class="line">    private String name;  &#x2F;&#x2F; 实例变量</span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F; 共有的 setter 和 getter 方法</span><br><span class="line">    public void setName(String name)&#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F; 抽象方法</span><br><span class="line">    public abstract void work();</span><br><span class="line">&#125;</span><br><span class="line">class Teacher extends People&#123;</span><br><span class="line">    &#x2F;&#x2F; 必须实现该方法</span><br><span class="line">    public void work()&#123;</span><br><span class="line">        out.println(&quot;我的名字叫&quot; + this.getName() + &quot;，我正在讲课，请大家不要东张西望...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Driver extends People&#123;</span><br><span class="line">    &#x2F;&#x2F; 必须实现该方法</span><br><span class="line">    public void work()&#123;</span><br><span class="line">        out.println(&quot;我的名字叫&quot; + this.getName() + &quot;，我正在开车，不能接听电话...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于抽象类的几点说明：</p>
<ul>
<li>抽象类不能直接使用，必须用子类去实现抽象类，然后使用其子类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例，也就是可以使用抽象类来充当形参，实际实现类作为实参，这是多态的应用。</li>
<li>不能有抽象构造方法或抽象静态方法。</li>
</ul>
<p>在下列情况下，一个类将成为抽象类：</p>
<ul>
<li>当一个类的一个或多个方法是抽象方法时；</li>
<li>当类是一个抽象类的子类，并且不能为任何抽象方法提供任何实现细节或方法主体时；</li>
<li>当一个类实现一个接口，并且不能为任何抽象方法提供实现细节或方法主体时；</li>
</ul>
<p>注意：这里说的是这些情况下一个类将成为抽象类，没有说抽象类一定会有这些情况。一个典型的错误：抽象类一定包含抽象方法。 但是反过来说“包含抽象方法的类一定是抽象类”就是正确的。事实上，抽象类可以是一个完全正常实现的类</p>
<h1 id="接口">6. 接口</h1><h2 id="接口的概念">6.1. 接口的概念</h2><p>在抽象类中，可以包含一个或多个抽象方法；但在接口(interface)中，所有的方法必须都是抽象的，不能有方法体，它比抽象类更加“抽象”。</p>
<p>接口使用 interface 关键字来声明，可以看做是一种特殊的抽象类，可以指定一个类必须做什么，而不是规定它如何去做。</p>
<p>现实中也有很多接口的实例，比如说串口电脑硬盘，Serial ATA委员会指定了Serial ATA 2.0规范，这种规范就是接口。Serial ATA委员会不负责生产硬盘，只是指定通用的规范。</p>
<p>希捷、日立、三星等生产厂家会按照规范生产符合接口的硬盘，这些硬盘就可以实现通用化，如果正在用一块160G日立的串口硬盘，现在要升级了，可以购买一块320G的希捷串口硬盘，安装上去就可以继续使用了。</p>
<p>下面的代码可以模拟Serial ATA委员会定义以下串口硬盘接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Demo&#123;</span><br><span class="line">    &#x2F;&#x2F;连接线的数量</span><br><span class="line">    public static final int CONNECT_LINE&#x3D;4;</span><br><span class="line">    &#x2F;&#x2F;写数据</span><br><span class="line">    public void writeData(String data);</span><br><span class="line">    &#x2F;&#x2F;读数据</span><br><span class="line">    public String readData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：接口中声明的成员变量默认都是 public static final 的，必须显式地初始化。因而在常量声明时可以省略这些修饰符。</p>
<p>接口是若干常量和抽象方法的集合，目前看来和抽象类差不多。确实如此，接口本就是从抽象类中演化而来的，因而除特别规定，接口享有和类同样的“待遇”。比如，源程序中可以定义多个类或接口，但最多只能有一个public 的类或接口，如果有则源文件必须取和public的类和接口相同的名字。和类的继承格式一样，接口之间也可以继承，子接口可以继承父接口中的常量和抽象方法并添加新的抽象方法等。</p>
<p>接口特性：</p>
<ol>
<li>接口中只能定义抽象方法，这些方法默认为 public abstract 的，因而在声明方法时可以省略这些修饰符。试图在接口中定义实例变量、非抽象的实例方法及静态方法，都是非法的。例如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface SataHdd&#123;</span><br><span class="line">    &#x2F;&#x2F;连接线的数量</span><br><span class="line">    public int connectLine; &#x2F;&#x2F;编译出错，connectLine被看做静态常量，必须显式初始化</span><br><span class="line">    &#x2F;&#x2F;写数据</span><br><span class="line">    protected void writeData(String data); &#x2F;&#x2F;编译出错，必须是public类型</span><br><span class="line">    &#x2F;&#x2F;读数据</span><br><span class="line">    public static String readData()&#123; &#x2F;&#x2F;编译出错，接口中不能包含静态方法</span><br><span class="line">        return &quot;数据&quot;; &#x2F;&#x2F;编译出错，接口中只能包含抽象方法，</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>接口没有构造方法，不能初始化</li>
<li>一个接口不实现另一个接口，但可以继承多个其他接口。接口的多继承特点弥补了类的单继承。例如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;串行硬盘接口</span><br><span class="line">public interface SataHdd extends A,B&#123;</span><br><span class="line">    &#x2F;&#x2F; 连接线的数量</span><br><span class="line">    public static final int CONNECT_LINE &#x3D; 4;</span><br><span class="line">    &#x2F;&#x2F; 写数据</span><br><span class="line">    public void writeData(String data);</span><br><span class="line">    &#x2F;&#x2F; 读数据</span><br><span class="line">    public String readData();</span><br><span class="line">&#125;</span><br><span class="line">interface A&#123;</span><br><span class="line">    public void a();</span><br><span class="line">&#125;</span><br><span class="line">interface B&#123;</span><br><span class="line">    public void b();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="why-接口">6.2. why 接口</h2><p>大型项目开发中，可能需要从继承链的中间插入一个类，让它的子类具备某些功能而不影响它们的父类。例如 A -&gt; B -&gt; C -&gt; D -&gt; E，A 是祖先类，如果需要为C、D、E类添加某些通用的功能，最简单的方法是让C类再继承另外一个类。但是问题来了，Java 是一种单继承的语言，不能再让C继承另外一个父类了，只到移动到继承链的最顶端，让A再继承一个父类。这样一来，对C、D、E类的修改，影响到了整个继承链，不具备可插入性的设计。</p>
<p>接口是可插入性的保证。在一个继承链中的任何一个类都可以实现一个接口，这个接口会影响到此类的所有子类，但不会影响到此类的任何父类。此类将不得不实现这个接口所规定的方法，而子类可以从此类自动继承这些方法，这时候，这些子类具有了可插入性。</p>
<p>我们关心的不是哪一个具体的类，而是这个类是否实现了我们需要的接口。</p>
<p>接口提供了关联以及方法调用上的可插入性，软件系统的规模越大，生命周期越长，接口使得软件系统的灵活性和可扩展性，可插入性方面得到保证。</p>
<p>接口在面向对象的 Java 程序设计中占有举足轻重的地位。事实上在设计阶段最重要的任务之一就是设计出各部分的接口，然后通过接口的组合，形成程序的基本框架结构。</p>
<h2 id="接口的使用">6.3. 接口的使用</h2><p>接口的使用与类的使用有些不同。在需要使用类的地方，会直接使用new关键字来构建一个类的实例，但接口不可以这样使用，因为接口不能直接使用 new 关键字来构建实例。</p>
<p>接口必须通过类来实现(implements)它的抽象方法，然后再实例化类。类实现接口的关键字为implements。</p>
<p>如果一个类不能实现该接口的所有抽象方法，那么这个类必须被定义为抽象方法。</p>
<p>不允许创建接口的实例，但允许定义接口类型的引用变量，该变量指向了实现接口的类的实例。</p>
<p>一个类只能继承一个父类，但却可以实现多个接口。</p>
<p>实现接口的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 class 类名 extends 父类 implements 多个接口(逗号分隔) &#123;</span><br><span class="line">实现方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import static java.lang.System.*;</span><br><span class="line">public class Demo&#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">      SataHdd sh1&#x3D;new SeagateHdd(); &#x2F;&#x2F;初始化希捷硬盘</span><br><span class="line">      SataHdd sh2&#x3D;new SamsungHdd(); &#x2F;&#x2F;初始化三星硬盘</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;串行硬盘接口</span><br><span class="line">interface SataHdd&#123;</span><br><span class="line">    &#x2F;&#x2F;连接线的数量</span><br><span class="line">    public static final int CONNECT_LINE&#x3D;4;</span><br><span class="line">    &#x2F;&#x2F;写数据</span><br><span class="line">    public void writeData(String data);</span><br><span class="line">    &#x2F;&#x2F;读数据</span><br><span class="line">    public String readData();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 维修硬盘接口</span><br><span class="line">interface fixHdd&#123;</span><br><span class="line">    &#x2F;&#x2F; 维修地址</span><br><span class="line">    String address &#x3D; &quot;北京市海淀区&quot;;</span><br><span class="line">    &#x2F;&#x2F; 开始维修</span><br><span class="line">    boolean doFix();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;捷硬盘</span><br><span class="line">class SeagateHdd implements SataHdd, fixHdd&#123;</span><br><span class="line">    &#x2F;&#x2F;希捷硬盘读取数据</span><br><span class="line">    public String readData()&#123;</span><br><span class="line">        return &quot;数据&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;希捷硬盘写入数据</span><br><span class="line">    public void writeData(String data) &#123;</span><br><span class="line">        out.println(&quot;写入成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 维修希捷硬盘</span><br><span class="line">    public boolean doFix()&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;三星硬盘</span><br><span class="line">class SamsungHdd implements SataHdd&#123;</span><br><span class="line">    &#x2F;&#x2F;三星硬盘读取数据</span><br><span class="line">    public String readData()&#123;</span><br><span class="line">        return &quot;数据&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;三星硬盘写入数据</span><br><span class="line">    public void writeData(String data)&#123;</span><br><span class="line">        out.println(&quot;写入成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;某劣质硬盘，不能写数据</span><br><span class="line">abstract class XXHdd implements SataHdd&#123;</span><br><span class="line">    &#x2F;&#x2F;硬盘读取数据</span><br><span class="line">    public String readData() &#123;</span><br><span class="line">        return &quot;数据&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口作为类使用">6.4. 接口作为类使用</h2><p>接口作为引用类型来使用，任何实现该接口的类的实例都可以存储在该接口类型的变量中，通过这些变量可以访问类中所实现的接口中的方法，Java 运行时系统会动态地确定应该使用哪个类中的方法，实际上是调用相应的实现类的方法。下面例子中可以看到接口可以作为一个类型来使用，把接口作为方法的参数和返回类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Demo&#123;</span><br><span class="line">    public void test1(A a) &#123;</span><br><span class="line">        a.doSth();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Demo d &#x3D; new Demo();</span><br><span class="line">        A a &#x3D; new B();</span><br><span class="line">        d.test1(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface A &#123;</span><br><span class="line">    public int doSth();</span><br><span class="line">&#125;</span><br><span class="line">class B implements A &#123;</span><br><span class="line">    public int doSth() &#123;</span><br><span class="line">        System.out.println(&quot;now in B&quot;);</span><br><span class="line">        return 123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="接口与抽象类">7. 接口与抽象类</h1><p>类是对象的模板，抽象类和接口可以看做是具体的类的模板。</p>
<p>由于从某种角度讲，接口是一种特殊的抽象类，它们的渊源颇深，有很大的相似之处，所以在选择使用谁的问题上很容易迷糊。</p>
<p>相同点：</p>
<ul>
<li>都代表类树形结构的抽象层。在使用引用变量时，尽量使用类结构的抽象层，使方法的定义和实现分离，这样做对于代码有松散耦合的好处。</li>
<li>都不能被实例化。</li>
<li>都能包含抽象方法。抽象方法用来描述系统提供哪些功能，而不必关心具体的实现。</li>
</ul>
<p>区别</p>
<ol>
<li>抽象类可以为部分方法提供实现，避免了在子类中重复实现这些方法，提高了代码的可重用性，这是抽象类的优势；而接口中只能包含抽象方法，不能包含任何实现。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class A&#123;</span><br><span class="line">    public abstract void method1();</span><br><span class="line">    public void method2()&#123;</span><br><span class="line">        &#x2F;&#x2F;A method2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class B extends A&#123;</span><br><span class="line">    public void method1()&#123;</span><br><span class="line">        &#x2F;&#x2F;B method1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class C extends A&#123;</span><br><span class="line">    public void method1()&#123;</span><br><span class="line">        &#x2F;&#x2F;C method1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>抽象类A有两个子类B、C，由于A中有方法method2的实现，子类B、C中不需要重写method2方法，我们就说A为子类提供了公共的功能，或A约束了子类的行为。method2就是代码可重用的例子。A 并没有定义 method1的实现，也就是说B、C 可以根据自己的特点实现method1方法，这又体现了松散耦合的特性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface A&#123;</span><br><span class="line">    public void method1();</span><br><span class="line">    public void method2();</span><br><span class="line">&#125;</span><br><span class="line">public class B implements A&#123;</span><br><span class="line">    public void method1()&#123;</span><br><span class="line">        &#x2F;&#x2F;B method1</span><br><span class="line">    &#125;</span><br><span class="line">    public void method2()&#123;</span><br><span class="line">        &#x2F;&#x2F;B method2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class C implements A&#123;</span><br><span class="line">    public void method1()&#123;</span><br><span class="line">        &#x2F;&#x2F;C method1</span><br><span class="line">    &#125;</span><br><span class="line">    public void method2()&#123;</span><br><span class="line">        &#x2F;&#x2F;C method2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口A无法为实现类B、C提供公共的功能，也就是说A无法约束B、C的行为。B、C可以自由地发挥自己的特点现实 method1和 method2方法，接口A毫无掌控能力。</p>
<ol start="2">
<li>一个类只能继承一个直接的父类（可能是抽象类），但一个类可以实现多个接口，这个就是接口的优势。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface A&#123;</span><br><span class="line">    public void method2();</span><br><span class="line">&#125;</span><br><span class="line">interface B&#123;</span><br><span class="line">    public void method1();</span><br><span class="line">&#125;</span><br><span class="line">class C implements A,B&#123;</span><br><span class="line">    public void method1()&#123;</span><br><span class="line">        &#x2F;&#x2F;C method1</span><br><span class="line">    &#125;</span><br><span class="line">    public void method2()&#123;</span><br><span class="line">        &#x2F;&#x2F;C method2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;可以如此灵活的使用C，并且C还有机会进行扩展，实现其他接口</span><br><span class="line">A a&#x3D;new C();</span><br><span class="line">B b&#x3D;new C();</span><br><span class="line">abstract class A&#123;</span><br><span class="line">    public abstract void method1();</span><br><span class="line">&#125;</span><br><span class="line">abstract class B extends A&#123;</span><br><span class="line">    public abstract void method2();</span><br><span class="line">&#125;</span><br><span class="line">class C extends B&#123;</span><br><span class="line">    public void method1()&#123;</span><br><span class="line">        &#x2F;&#x2F;C method1</span><br><span class="line">    &#125;</span><br><span class="line">    public void method2() &#123;</span><br><span class="line">        &#x2F;&#x2F;C method2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>综上所述，接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：</p>
<ul>
<li>行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。</li>
<li>选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。</li>
</ul>
<p>接口和抽象类的区别是什么？</p>
<ul>
<li>接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。</li>
<li>接口中除了 static、final 变量，不能有其他变量，而抽象类中则不一定。</li>
<li>一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过 extends 关键字扩展多个接口。</li>
<li>接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用 private 关键字修饰！）。</li>
<li>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li>
</ul>
<p>总结一下 jdk7~jdk9 Java 中接口概念的变化：</p>
<ul>
<li>在 jdk 7 或更早版本中，接口里面只能有常量变量和抽象方法。这些接口方法必须由选择实现接口的类实现。</li>
<li>jdk8 的时候接口可以有默认方法和静态方法功能。</li>
<li>Jdk 9 在接口中引入了私有方法和私有静态方法。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java复健系列(4)：Java中的异常处理</title>
    <url>/2020/10/19/Java-review-4/</url>
    <content><![CDATA[<h1 id="异常处理">1. 异常处理</h1><p>Java异常是一个描述在代码段中发生的异常（也就是出错）情况的对象。当异常情况发生，一个代表该异常的对象被创建并且在导致该错误的方法中被抛出（throw）。该方法可以选择自己处理异常或传递该异常。两种情况下，该异常被捕获（catch）并处理。异常可能是由Java运行时系统产生，或者是由你的手工代码产生。被Java抛出的异常与违反语言规范或超出Java执行环境限制的基本错误有关。手工编码产生的异常基本上用于报告方法调用程序的出错状况。</p>
<p>Java异常处理通过5个关键字控制：try、catch、throw、throws和 finally。下面讲述它们如何工作的。程序声明了你想要的异常监控包含在一个try块中。如果在try块中发生异常，它被抛出。你的代码可以捕捉这个异常（用catch）并且用某种合理的方法处理该异常。系统产生的异常被Java运行时系统自动抛出。手动抛出一个异常，用关键字throw。任何被抛出方法的异常都必须通过throws子句定义。任何在方法返回前绝对被执行的代码被放置在finally块中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    &#x2F;&#x2F; block of code to monitor for errors</span><br><span class="line">&#125;</span><br><span class="line">catch (ExceptionType1 exOb) &#123;</span><br><span class="line">    &#x2F;&#x2F; exception handler for ExceptionType1</span><br><span class="line">&#125;</span><br><span class="line">catch (ExceptionType2 exOb) &#123;</span><br><span class="line">    &#x2F;&#x2F; exception handler for ExceptionType2</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">finally &#123;</span><br><span class="line">    &#x2F;&#x2F; block of code to be executed before try block ends</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="异常类型">2. 异常类型</h1><p>所有异常类型都是内置类Throwable的子类。因此，Throwable在异常类层次结构的顶层。紧接着Throwable下面的是两个把异常分成两个不同分支的子类。一个分支是Exception。该类用于用户程序可能捕捉的异常情况。它也是你可以用来创建你自己用户异常类型子类的类。在Exception分支中有一个重要子类RuntimeException。该类型的异常自动为你所编写的程序定义并且包括被零除和非法数组索引这样的错误。</p>
<p>另一类分支由Error作为顶层，Error定义了在通常环境下不希望被程序捕获的异常。Error类型的异常用于Java运行时系统来显示与运行时系统本身有关的错误。堆栈溢出是这种错误的一例。本章将不讨论关于Error类型的异常处理，因为它们通常是灾难性的致命错误，不是你的程序可以控制的。</p>
<ul>
<li>Throwable<ul>
<li>Error 系统错误</li>
<li>Exception 用户错误</li>
</ul>
</li>
</ul>
<p>如果我们没有提供任何我们自己的异常处理程序，所以异常被Java运行时系统的默认处理程序捕获。任何不是被你程序捕获的异常最终都会被该默认处理程序处理。默认处理程序显示一个描述异常的字符串，打印异常发生处的堆栈轨迹并且终止程序。</p>
<h1 id="try-and-catch">3. try and catch</h1><p>尽管由Java运行时系统提供的默认异常处理程序对于调试是很有用的，但通常你希望自己处理异常。这样做有两个好处。第一，它允许你修正错误。第二，它防止程序自动终止。</p>
<p>一个try和它的catch语句形成了一个单元。catch子句的范围限制于try语句前面所定义的语句。一个catch语句不能捕获另一个try声明所引发的异常（除非是嵌套的try语句情况）。</p>
<p>被try保护的语句声明必须在一个大括号之内（也就是说，它们必须在一个块中）。你不能单独使用try。</p>
<p>构造catch子句的目的是解决异常情况并且像错误没有发生一样继续运行。例如，下面的程序中，每一个for循环的反复得到两个随机整数。这两个整数分别被对方除，结果用来除12345。最后的结果存在a中。如果一个除法操作导致被零除错误，它将被捕获，a的值设为零，程序继续运行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Handle an exception and move on.</span><br><span class="line">import java.util.Random;</span><br><span class="line">class Demo &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        int a&#x3D;0, b&#x3D;0, c&#x3D;0;</span><br><span class="line">        Random r &#x3D; new Random();</span><br><span class="line">        for(int i&#x3D;0; i&lt;30; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                b &#x3D; r.nextInt();</span><br><span class="line">                c &#x3D; r.nextInt();</span><br><span class="line">                a &#x3D; 12345 &#x2F; (b&#x2F;c);</span><br><span class="line">            &#125; catch (ArithmeticException e) &#123;</span><br><span class="line">                System.out.println(&quot;Division by zero.&quot;);</span><br><span class="line">                a &#x3D; 0; &#x2F;&#x2F; set a to zero and continue</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;a: &quot; + a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Throwable重载toString( )方法（由Object定义），所以它返回一个包含异常描述的字符串。你可以通过在println( )中传给异常一个参数来显示该异常的描述。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(&quot;Exception: &quot; + e);</span><br></pre></td></tr></table></figure>

<h1 id="多重catch">4. 多重catch</h1><p>某些情况，由单个代码段可能引起多个异常。处理这种情况，你可以定义两个或更多的catch子句，每个子句捕获一种类型的异常。当异常被引发时，每一个catch子句被依次检查，第一个匹配异常类型的子句执行。当一个catch语句执行以后，其他的子句被旁路，执行从try&#x2F;catch块以后的代码开始继续。如下代码中，如果a为0，则触发第一个异常，a为1则触发第二个异常。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Demo &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int a &#x3D; args.length;</span><br><span class="line">            System.out.println(&quot;a &#x3D; &quot; + a);</span><br><span class="line">            int b &#x3D; 42 &#x2F; a;</span><br><span class="line">            int c[] &#x3D; &#123; 1 &#125;;</span><br><span class="line">            c[42] &#x3D; 99;</span><br><span class="line">        &#125; catch(ArithmeticException e) &#123;</span><br><span class="line">            System.out.println(&quot;Divide by 0: &quot; + e);</span><br><span class="line">        &#125; catch(ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(&quot;Array index oob: &quot; + e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;After try&#x2F;catch blocks.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你用多catch语句时，记住异常子类必须在它们任何父类之前使用是很重要的。这是因为运用父类的catch语句将捕获该类型及其所有子类类型的异常。这样，如果子类在父类后面，子类将永远不会到达。而且，Java编译器中不能到达的代码是一个错误。编译器会在编译时提醒你相关内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;This program contains an error.</span><br><span class="line">&#x2F;&#x2F;A subclass must come before its superclass in a series of catch statements. If not,unreachable code will be created and acompile-time error will result.</span><br><span class="line">&#x2F;&#x2F;*&#x2F;</span><br><span class="line">class Demo &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int a &#x3D; 0;</span><br><span class="line">            int b &#x3D; 42 &#x2F; a;</span><br><span class="line">        &#125; catch(Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;Generic Exception catch.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;* This catch is never reached because</span><br><span class="line">        ArithmeticException is a subclass of Exception. *&#x2F;</span><br><span class="line">        catch(ArithmeticException e) &#123; &#x2F;&#x2F; ERROR - unreachable</span><br><span class="line">            System.out.println(&quot;This is never reached.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，一旦某个catch捕获到匹配的异常类型，将进入异常处理代码。一经处理结束，就意味着整个try-catch语句结束。其他的catch子句不再有匹配和捕获异常类型的机会。</p>
<h1 id="try嵌套">5. try嵌套</h1><p>Try语句可以被嵌套。也就是说，一个try语句可以在另一个try块内部。每次进入try语句，异常的前后关系都会被推入堆栈。如果一个内部的try语句不含特殊异常的catch处理程序，堆栈将弹出，下一个try语句的catch处理程序将检查是否与之匹配。这个过程将继续直到一个catch语句匹配成功，或者是直到所有的嵌套try语句被检查耗尽。如果没有catch语句匹配，Java的运行时系统将处理这个异常。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;An example of nested try statements.</span><br><span class="line">class Demo &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int a &#x3D; args.length;</span><br><span class="line">            &#x2F;* If no command-line args are present,the following statement will generate a divide-by-zero exception. *&#x2F;</span><br><span class="line">            int b &#x3D; 42 &#x2F; a;</span><br><span class="line">            System.out.println(&quot;a &#x3D; &quot; + a);</span><br><span class="line">            try &#123; &#x2F;&#x2F; nested try block</span><br><span class="line">                &#x2F;* If one command-line arg is used,then a divide-by-zero exception will be generated by the following code. *&#x2F;</span><br><span class="line">                if(a&#x3D;&#x3D;1) a &#x3D; a&#x2F;(a-a); &#x2F;&#x2F; division by zero</span><br><span class="line">                &#x2F;* If two command-line args are used,then generate an out-of-bounds exception. *&#x2F;</span><br><span class="line">                if(a&#x3D;&#x3D;2) &#123;</span><br><span class="line">                    int c[] &#x3D; &#123; 1 &#125;;</span><br><span class="line">                    c[42] &#x3D; 99; &#x2F;&#x2F; generate an out-of-bounds exception</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch(ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">                System.out.println(&quot;Array index out-of-bounds: &quot; + e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch(ArithmeticException e) &#123;</span><br><span class="line">            System.out.println(&quot;Divide by 0: &quot; + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当有方法调用时，try语句的嵌套可以很隐蔽的发生。例如，你可以把对方法的调用放在一个try块中。在该方法内部，有另一个try语句。这种情况下，方法内部的try仍然是嵌套在外部调用该方法的try块中的。</p>
<h1 id="Throw">6. Throw</h1><p>我们可以用throw抛出异常，语法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">throw ThrowableInstance;</span><br></pre></td></tr></table></figure>
<p>这里的ThrowableInstance一定是Throwable类类型或者Throwable子类类型的一个对象。简单的数据类型，例如int，char,以及非Throwable类，例如String或Object，不能用作异常。有两种方法可以获取Throwable对象：在catch子句中使用参数或者使用new操作符创建。</p>
<p>程序执行完throw语句之后立即停止；throw后面的任何语句不被执行，最邻近的try块用来检查它是否含有一个与异常类型匹配的catch语句。如果发现了匹配的块，控制转向该语句；如果没有发现，次包围的try块来检查，以此类推。如果没有发现匹配的catch块，默认异常处理程序中断程序的执行并且打印堆栈轨迹。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TestThrow&#123;</span><br><span class="line">    static void proc()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            throw new NullPointerException(&quot;demo&quot;);</span><br><span class="line">        &#125;catch(NullPointerException e)&#123;</span><br><span class="line">            System.out.println(&quot;Caught inside proc&quot;);</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String [] args)&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            proc();</span><br><span class="line">        &#125;catch(NullPointerException e)&#123;</span><br><span class="line">            System.out.println(&quot;Recaught: &quot;+e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Throws">7. Throws</h1><p>如果一个方法可以导致一个异常但不处理它，它必须指定这种行为以使方法的调用者可以保护它们自己而不发生异常。做到这点你可以在方法声明中包含一个throws子句。一个 throws 子句列举了一个方法可能抛出的所有异常类型。这对于除Error或RuntimeException及它们子类以外类型的所有异常是必要的。一个方法可以抛出的所有其他类型的异常必须在throws子句中声明。如果不这样做，将会导致编译错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type method-name(parameter-list) throws exception-list&#123;</span><br><span class="line">    &#x2F;&#x2F; body of method</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Demo &#123;</span><br><span class="line">    static void throwOne() throws IllegalAccessException &#123;</span><br><span class="line">      System.out.println(&quot;Inside throwOne.&quot;);</span><br><span class="line">      throw new IllegalAccessException(&quot;demo&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   public static void main(String args[]) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         throwOne();</span><br><span class="line">      &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">         System.out.println(&quot;Caught &quot; + e);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Finally">8. Finally</h1><p>如果一个方法打开一个文件项并关闭，然后退出，你不希望关闭文件的代码被异常处理机制旁路。finally关键字为处理这种意外而设计。finally创建一个代码块。该代码块在一个try&#x2F;catch 块完成之后另一个try&#x2F;catch出现之前执行。<em>finally块无论有没有异常抛出都会执行。</em>如果异常被抛出，finally甚至是在没有与该异常相匹配的catch子句情况下也将执行。一个方法将从一个try&#x2F;catch块返回到调用程序的任何时候，经过一个未捕获的异常或者是一个明确的返回语句，finally子句在方法返回之前仍将执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Demonstrate finally.</span><br><span class="line">class Demo &#123;</span><br><span class="line">    &#x2F;&#x2F; Through an exception out of the method.</span><br><span class="line">    static void procA() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">           System.out.println(&quot;inside procA&quot;);</span><br><span class="line">           throw new RuntimeException(&quot;demo&quot;);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">           System.out.println(&quot;procA&#39;s finally&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Return from within a try block.</span><br><span class="line">    static void procB() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">           System.out.println(&quot;inside procB&quot;);</span><br><span class="line">           return;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">           System.out.println(&quot;procB&#39;s finally&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Execute a try block normally.</span><br><span class="line">    static void procC() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">           System.out.println(&quot;inside procC&quot;);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">           System.out.println(&quot;procC&#39;s finally&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">          procA();</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">          System.out.println(&quot;Exception caught&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       procB();</span><br><span class="line">       procC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inside procA</span><br><span class="line">procA’s finally</span><br><span class="line">Exception caught</span><br><span class="line">inside procB</span><br><span class="line">procB’s finally</span><br><span class="line">inside procC</span><br><span class="line">procC’s finally</span><br></pre></td></tr></table></figure>

<h1 id="内置异常">9. 内置异常</h1><p>在标准包java.lang中，Java定义了若干个异常类。这些异常一般是标准类RuntimeException的子类。因为java.lang实际上被所有的Java程序引入，多数从RuntimeException派生的异常都自动可用。而且，它们不需要被包含在任何方法的throws列表中。Java语言中，这被叫做未经检查的异常（unchecked exceptions ）。因为编译器不检查它来看一个方法是否处理或抛出了这些异常。java.lang中定义的未经检查的异常列于表10-1。表10-2列出了由 java.lang定义的必须在方法的throws列表中包括的异常，如果这些方法能产生其中的某个异常但是不能自己处理它。这些叫做受检查的异常（checked exceptions）。<br>unchecked exceptions</p>
<table>
<thead>
<tr>
<th>异常</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ArithmeticException</td>
<td>算术错误，如被0除</td>
</tr>
<tr>
<td>ArrayIndexOutOfBoundsException</td>
<td>数组下标出界</td>
</tr>
<tr>
<td>ArrayStoreException</td>
<td>数组元素赋值类型不兼容</td>
</tr>
<tr>
<td>ClassCastException</td>
<td>非法强制转换类型</td>
</tr>
<tr>
<td>IllegalArgumentException</td>
<td>调用方法的参数非法</td>
</tr>
<tr>
<td>IllegalMonitorStateException</td>
<td>非法监控操作，如等待一个未锁定线程</td>
</tr>
<tr>
<td>IllegalStateException</td>
<td>环境或应用状态不正确</td>
</tr>
<tr>
<td>IllegalThreadStateException</td>
<td>请求操作与当前线程状态不兼容</td>
</tr>
<tr>
<td>IndexOutOfBoundsException</td>
<td>某些类型索引越界</td>
</tr>
<tr>
<td>NullPointerException</td>
<td>非法使用空引用</td>
</tr>
<tr>
<td>NumberFormatException</td>
<td>字符串到数字格式非法转换</td>
</tr>
<tr>
<td>SecurityException</td>
<td>试图违反安全性</td>
</tr>
<tr>
<td>StringIndexOutOfBounds</td>
<td>试图在字符串边界之外索引</td>
</tr>
<tr>
<td>UnsupportedOperationException</td>
<td>遇到不支持的操作</td>
</tr>
</tbody></table>
<p>checked exceptions</p>
<table>
<thead>
<tr>
<th>异常</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ClassNotFoundException</td>
<td>找不到类</td>
</tr>
<tr>
<td>CloneNotSupportedException</td>
<td>试图克隆一个不能实现Cloneable接口的对象</td>
</tr>
<tr>
<td>IllegalAccessException</td>
<td>对一个类的访问被拒绝</td>
</tr>
<tr>
<td>InstantiationException</td>
<td>试图创建一个抽象类或者抽象接口的对象</td>
</tr>
<tr>
<td>InterruptedException</td>
<td>一个线程被另一个线程中断</td>
</tr>
<tr>
<td>NoSuchFieldException</td>
<td>请求的字段不存在</td>
</tr>
<tr>
<td>NoSuchMethodException</td>
<td>请求的方法不存在</td>
</tr>
</tbody></table>
<h1 id="创建自定义异常子类">10. 创建自定义异常子类</h1><p>尽管Java的内置异常处理大多数常见错误，你也许希望建立你自己的异常类型来处理你所应用的特殊情况。这是非常简单的：只要定义Exception的一个子类就可以了（Exception当然是Throwable的一个子类）。你的子类不需要实际执行什么——它们在类型系统中的存在允许你把它们当成异常使用。Exception类自己没有定义任何方法。当然，它继承了Throwable提供的一些方法。因此，所有异常，包括你创建的，都可以获得Throwable定义的方法。这些方法显示在表10-3中。你还可以在你创建的异常类中覆盖一个或多个这样的方法。<br>方法|描述<br>Throwable fillInStackTrace( )|返回一个包含完整堆栈轨迹的Throwable对象，该对象可能被再次引发。<br>String getLocalizedMessage( )|返回一个异常的局部描述<br>String getMessage( )|返回一个异常的描述<br>void printStackTrace( )|显示堆栈轨迹<br>void printStackTrace(PrintStreamstream)|把堆栈轨迹送到指定的流<br>void printStackTrace(PrintWriterstream)|把堆栈轨迹送到指定的流<br>String toString( )|返回一个包含异常描述的String对象。当输出一个Throwable对象时，该方法被println( )调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;This program creates a custom exception type.</span><br><span class="line">class MyException extends Exception &#123;</span><br><span class="line">    private int detail;</span><br><span class="line">    MyException(int a) &#123;</span><br><span class="line">        detail &#x3D; a;</span><br><span class="line">    &#125;</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;MyException[&quot; + detail + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ExceptionDemo &#123;</span><br><span class="line">    static void compute(int a) throws MyException &#123;</span><br><span class="line">        System.out.println(&quot;Called compute(&quot; + a + &quot;)&quot;);</span><br><span class="line">        if(a &gt; 10)</span><br><span class="line">            throw new MyException(a);</span><br><span class="line">        System.out.println(&quot;Normal exit&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            compute(1);</span><br><span class="line">            compute(20);</span><br><span class="line">        &#125; catch (MyException e) &#123;</span><br><span class="line">            System.out.println(&quot;Caught &quot; + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该例题定义了Exception的一个子类MyException。该子类非常简单：它只含有一个构造函数和一个重载的显示异常值的toString( )方法。ExceptionDemo类定义了一个compute( )方法。该方法抛出一个MyException对象。当compute( )的整型参数比10大时该异常被引发。</p>
<h1 id="断言">11. 断言</h1><p>断言用于证明和测试程序的假设，比如“这里的值大于 5”。<br>断言可以在运行时从代码中完全删除，所以对代码的运行速度没有影响。</p>
<p>断言有两种方法：</p>
<ul>
<li>一种是 assert&lt;&lt;布尔表达式&gt;&gt; ；</li>
<li>另一种是 assert&lt;&lt;布尔表达式&gt;&gt; ：&lt;&lt;细节描述&gt;&gt;。</li>
</ul>
<p>如果布尔表达式的值为false ， 将抛出AssertionError 异常；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int x &#x3D; 11;</span><br><span class="line">        System.out.println(&quot;Testing assertion that x &#x3D;&#x3D; 10&quot;);</span><br><span class="line">        assert x &#x3D;&#x3D; 10 : &quot;Our assertion failed&quot;;</span><br><span class="line">        System.out.println(&quot;Test passed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序运行使用断言功能也需要使用额外的参数（并且需要一个数字的命令行参数），例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -ea Demo</span><br></pre></td></tr></table></figure>

<p>断言功能使得程序运行时抛出断言错误，注意是错误， 这意味着程序发生严重错误并且将强制退出。断言使用 boolean 值，如果其值不为 true 则 抛出 AssertionError 并终止程序的运行。</p>
<p>断言推荐使用方法。用于验证方法中的内部逻辑，包括：</p>
<ul>
<li>内在不变式</li>
<li>控制流程不变式</li>
<li>后置条件和类不变式</li>
</ul>
<p>运行时要屏蔽断言，可以用如下方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java –disableassertions 或 java –da 类名</span><br></pre></td></tr></table></figure>
<p>运行时要允许断言，可以用如下方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java –enableassertions 或 java –ea类名</span><br></pre></td></tr></table></figure>

<h1 id="异常链">12. 异常链</h1><p>异常链顾名思义就是将异常发生的原因一个传一个串起来，即把底层的异常信息传给上层，这样逐层抛出。 Java API文档中给出了一个简单的模型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;   </span><br><span class="line">    lowLevelOp();   </span><br><span class="line">&#125; catch (LowLevelException le) &#123;   </span><br><span class="line">    throw (HighLevelException) new HighLevelException().initCause(le);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当程序捕获到了一个底层异常，在处理部分选择了继续抛出一个更高级别的新异常给此方法的调用者。 这样异常的原因就会逐层传递。这样，位于高层的异常递归调用getCause()方法，就可以遍历各层的异常原因。 这就是Java异常链的原理。异常链的实际应用很少，发生异常时候逐层上抛不是个好注意， 上层拿到这些异常又能奈之何？而且异常逐层上抛会消耗大量资源， 因为要保存一个完整的异常链信息.</p>
<h1 id="深入理解">13. 深入理解</h1><p><img src="/.xyz//../Pictures/java%20exception.jpg" alt="Java Exception"></p>
<p>异常指不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。Java通 过API中Throwable类的众多子类描述各种不同的异常。因而，Java异常都是对象，是Throwable子类的实例，描述了出现在一段编码中的 错误条件。当条件生成时，错误将引发异常。</p>
<h2 id="Exception-and-Error">13.1. Exception and Error</h2><p>Throwable： 有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p>
<ol>
<li>Error（错误）:是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。</li>
<li>Exception（异常）:是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。RuntimeException 类及其子类表示“JVM 常用操作”引发的错误。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常NullPointerException、ArithmeticException和 ArrayIndexOutOfBoundException。</li>
</ol>
<p>简单的说，异常能被处理，错误无法处理</p>
<h2 id="Checked-Exception-and-Unchecked-exceptions">13.2. Checked Exception and Unchecked exceptions</h2><p>Java的异常(包括Exception和Error)分为可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）。</p>
<ol>
<li>Checked Exception 可查异常（编译器要求必须处置的异常）：正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。 除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</li>
<li>Unchecked exceptions 不可查异常(编译器不要求强制处置的异常): 包括运行时异常（RuntimeException与其子类）和错误（Error）。</li>
</ol>
<h2 id="运行时异常和非运行时异常">13.3. 运行时异常和非运行时异常</h2><ol>
<li>运行时异常：都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</li>
<li>非运行时异常 （编译异常）：是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</li>
</ol>
<h2 id="异常处理机制">13.4. 异常处理机制</h2><p>Java异常处理机制中具体包括：抛出异常和捕获异常</p>
<ul>
<li><p>抛出异常：当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。</p>
</li>
<li><p>捕获异常：在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适 的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适 的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。</p>
</li>
<li><p>由于运行时异常的不可查性，为了更合理、更容易地实现应用程序，Java规定，运行时异常将由Java运行时系统自动抛出，允许应用程序忽略运行时异常。</p>
</li>
<li><p>对于方法运行中可能出现的Error，当运行方法不欲捕捉时，Java允许该方法不做任何抛出声明。因为，大多数Error异常属于永远不能被允许发生的状况，也属于合理的应用程序不该捕捉的异常。</p>
</li>
<li><p>对于所有的可查异常，Java规定：一个方法必须捕捉，或者声明抛出方法之外。也就是说，当一个方法选择不捕捉可查异常时，它必须声明将抛出异常。</p>
</li>
</ul>
<p>Java规定，对于可查异常必须捕捉、或者声明抛出。允许忽略不可查的RuntimeException和Error。</p>
<p><img src="/.xyz//../Pictures/java%20exception2.jpg" alt="Java Exception"></p>
<h1 id="面试问题">14. 面试问题</h1><ol>
<li><p>try{} 里有一个 return 语句，那么紧跟在这个 try 后的 finally{} 里的 code 会不会被执行，什么时候被执行，在 return 前还是后?<br>答案：会执行，在方法返回调用者前执行。注意：在finally中改变返回值的做法是不好的，因为如果存在finally代码块，try中的return语句不会立马返回调用者，而是记录下返回值待finally代码块执行完毕之后再向调用者返回其值，然后如果在finally中修改了返回值，就会返回修改后的值。显然，在finally中返回或者修改返回值会对程序造成很大的困扰，C#中直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java中也可以通过提升编译器的语法检查级别来产生警告或错误，Eclipse中可以在如图所示的地方进行设置，强烈建议将此项设置为编译错误。</p>
</li>
<li><p>Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？<br>答：Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是Throwable类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；try用来指定一块预防所有异常的程序；catch子句紧跟在try块后面，用来指定你想要捕获的异常的类型；throw语句用来明确地抛出一个异常；throws用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；finally为确保一段代码不管发生什么异常状况都要被执行；try语句可以嵌套，每当遇到一个try语句，异常的结构就会被放入异常栈中，直到所有的try语句都完成。如果下一级的try语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的try语句或者最终将异常抛给JVM。</p>
</li>
<li><p>运行时异常与受检异常有何异同？<br>异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，在Effective Java中对异常的使用给出了以下指导原则：</p>
</li>
</ol>
<ul>
<li>不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常） </li>
<li>对可以恢复的情况使用受检异常，对编程错误使用运行时异常 </li>
<li>避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生） </li>
<li>优先使用标准的异常 </li>
<li>每个方法抛出的异常都要有文档 </li>
<li>保持异常的原子性 </li>
<li>不要在catch中忽略掉捕获到的异常</li>
</ul>
<ol>
<li>列出一些你常见的运行时异常？</li>
</ol>
<ul>
<li>ArithmeticException（算术异常） </li>
<li>ClassCastException （类转换异常） </li>
<li>IllegalArgumentException （非法参数异常） </li>
<li>IndexOutOfBoundsException （下标越界异常） </li>
<li>NullPointerException （空指针异常） </li>
<li>SecurityException （安全异常）</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java与Spring中的线程池</title>
    <url>/2022/01/30/Java-spring-thread-pool/</url>
    <content><![CDATA[<h1 id="Runnable-与-Callable">1. Runnable 与 Callable</h1><h2 id="Runable">1.1. Runable</h2><p>Thread接受Runnable类型，并且允许接受Runnable构造线程。线程启动后会自动调用Runnable中的run方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题：Runnable接口的run方法只能执行，没有返回值。如果任务需要读取多线程任务的返回值，则非常不方便</p>
<h2 id="Callable">1.2. Callable</h2><p>定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SomeThing&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Callable接口是一个泛型接口，可以返回指定类型的结果。但如何接受指定类型的结果？</p>
<p>ExecutorService.submit()方法，可以看到，它返回了一个Future类型，一个Future类型的实例代表一个未来能获取结果的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">3</span>); </span><br><span class="line"><span class="comment">// 定义任务:</span></span><br><span class="line">Callable&lt;String&gt; task = <span class="keyword">new</span> Task();</span><br><span class="line"><span class="comment">// 提交任务并获得Future:</span></span><br><span class="line">Future&lt;String&gt; future = executor.submit(task);</span><br><span class="line"><span class="comment">// 等待线程执行完毕（非必须）</span></span><br><span class="line">Thread.sleep(<span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 从Future获取异步执行返回的结果:</span></span><br><span class="line">String result = future.get(); <span class="comment">// 可能阻塞</span></span><br></pre></td></tr></table></figure>

<p>当我们在线程池中提交Callable任务后，会得到一个<code>Future&lt;T&gt;</code>对象。之后，在主线程等待子线程执行完毕，然后再通过<code>Future.get()</code>获取子线程的输出结果。</p>
<h2 id="Future使用方法">1.3. Future使用方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//阻塞等待，获取结果</span></span><br><span class="line">Future.get();</span><br><span class="line"><span class="comment">//阻塞等待，获取结果。并设置了超时时间</span></span><br><span class="line"><span class="comment">//如果超时依然未获取，则抛出TimeoutException</span></span><br><span class="line">Future.get(<span class="keyword">long</span> timeout, TimeUnit unit);</span><br><span class="line"><span class="comment">//取消当前Future对应的线程执行的任务</span></span><br><span class="line">Future.cancel(<span class="keyword">boolean</span> mayInterruptIfRunning);</span><br><span class="line"><span class="comment">//判断Future对应的线程执行的任务是否完成（注：cancel也算入完成）</span></span><br><span class="line">Future.isDone();</span><br><span class="line"><span class="comment">//判断Future对应的线程执行的任务是否在完成前被取消</span></span><br><span class="line">Future.isCalcelled();</span><br></pre></td></tr></table></figure>

<h1 id="线程池">2. 线程池</h1><p>我们通常将Future与线程池结合使用。将task提交到线程池中，再等待线程执行完毕后，获取Future的结果。这里不详细介绍java的线程池，直接介绍Spring中的线程池</p>
<h2 id="java中的ThreadPoolExecutor">2.1. java中的ThreadPoolExecutor</h2><p>构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span></span></span><br><span class="line"><span class="function">  </span></span><br></pre></td></tr></table></figure>
<p>java中的ThreadPoolExecutor，可用的参数有：</p>
<ul>
<li>corePoolSize: 核心线程数量。决定了添加的任务是开辟新的线程去执行，还是放到workQueue任务队列中去；</li>
<li>maximumPoolSize：最大线程数量。决定线程池最大线程数量</li>
<li>keepAliveTime：当线程池中空闲线程数量超过corePoolSize时，多余的线程会在多长时间内被销毁；</li>
<li>unit：keepAliveTime的时间单位</li>
<li>workQueue：任务队列。被添加到线程池中，但仍在等待执行的任务</li>
<li>threadFactory：线程工程，用于线程创建</li>
<li>rejectedExecutionHandler：任务数量过多时，拒绝任务的策略</li>
</ul>
<h3 id="队列">2.1.1. 队列</h3><p>通过workQueue中传入队列的不同，ThreadPoolExecutor可以有不同的工作模式</p>
<p>队列可以分为：</p>
<ul>
<li>直接提交队列SynchronousQueue：提交的任务不会被保存，总是会马上提交执行，超过maxPoolSize上限则直接拒绝。</li>
<li>有界任务队列ArrayBlockingQueue：超过poolCoreSize的任务会被储存在队列中等待执行。超过队列上线后超过maxPoolSize则拒绝</li>
<li>无界任务队列LinkedBlockingQueue：超过poolCoreSize的任务会被储存在队列中等待执行。队列无上线（任务永远会被暂存在队列中）</li>
<li>优先任务队列PriorityBlockingQueue：放入队列中的任务按照优先级重排序（相当于特殊的无界队列）</li>
</ul>
<h3 id="拒绝策略">2.1.2. 拒绝策略</h3><p>ThreadPoolExecutor自带的拒绝策略如下：</p>
<ol>
<li>AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作；</li>
<li>CallerRunsPolicy策略：如果线程池的线程数量达到上限，该策略会把任务队列中的任务放在调用者线程当中运行；</li>
<li>DiscardOledestPolicy策略：该策略会丢弃任务队列中最老的一个任务，也就是当前任务队列中最先被添加进去的，马上要被执行的那个任务，并尝试再次提交；</li>
<li>DiscardPolicy策略：该策略会默默丢弃超过上限的任务，不予任何处理。当然使用此策略，业务场景中需允许任务的丢失；</li>
</ol>
<h2 id="spring自带线程池ThreadPoolTaskExecutor">2.2. spring自带线程池ThreadPoolTaskExecutor</h2><p>Spring异步线程池的接口类是TaskExecutor，本质其本质是对java.util.concurrent.ThreadPoolExecutor的包装。</p>
<p>配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">taskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        <span class="comment">//最大线程数</span></span><br><span class="line">        executor.setMaxPoolSize(maxPoolSize);</span><br><span class="line">        <span class="comment">//核心线程数</span></span><br><span class="line">        executor.setCorePoolSize(corePoolSize);</span><br><span class="line">        <span class="comment">//任务队列的大小</span></span><br><span class="line">        executor.setQueueCapacity(queueCapacity);</span><br><span class="line">        <span class="comment">//线程前缀名</span></span><br><span class="line">        executor.setThreadNamePrefix(namePrefix);</span><br><span class="line">        <span class="comment">//线程存活时间</span></span><br><span class="line">        executor.setKeepAliveSeconds(keepAliveSeconds);</span><br><span class="line">        <span class="comment">//拒绝策略</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        <span class="comment">//线程初始化</span></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，其使用方法与java自带的ThreadPoolExecutor非常类似。但用户不再需要通过管理复杂的队列来管理线程池的调度方式。</p>
<h2 id="线程调度策略">2.3. 线程调度策略</h2><p>spring自带线程池ThreadPoolTaskExecutor的调度策略综合了java中的ThreadPoolExecutor使用不同队列时的不同调度方式。通过改变<code>corePoolSize</code>、<code>maxPoolSize</code>、<code>queueCapacity</code>即可改变调度方式。我们来重新理解一下几个改变</p>
<ol>
<li>corePoolSize<br>线程池的基本大小，即在没有任务需要执行的时候线程池的大小，并且只有在工作队列满了的情况下才会创建超出这个数量的线程。</li>
<li>maximumPoolSize<br>线程池中允许的最大线程数</li>
<li>poolSize:<br>线程池中当前线程的数量</li>
<li>queueCapacity<br>等待队列大小</li>
</ol>
<p>查看源码（基于jdk8）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">         * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">         * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">         * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">         * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">         * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">         * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">         * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">         * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">         * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">         * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">         * and so reject the task.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>很明显，处理流程为：</p>
<ol>
<li>如果当前线程数量没有达到核心线程数量<code>poolSize&lt;corePoolSize</code>，无论是否有空闲线程，都新增一个线程处理提交新的任务</li>
<li>如当前线程数量大于核心线程数量<code>poolSize&gt;=corePoolSize</code>，并且任务队列未满，则将任务加入队列中等待</li>
<li>如果当前线程数量对等于核心线程数量<code>poolSize&gt;=corePoolSize</code>，并且任务队列满时，<br>3.1. 如果当前线程数量小于最大线程数量<code>poolSize&lt;maximumPoolSize</code>，那么新增线程处理任务<br>3.2. 如果当前线程数量等于最大线程数量<code>poolSize=maximumPoolSize</code>，那么执行拒绝策略拒绝任务</li>
</ol>
<h1 id="Spring中的-Async">3. Spring中的@Async</h1><p>注：本文源码基于spring boot 1.5.12。 高版本的Async逻辑有所不同，但使用的依然是没有上限的线程池</p>
<h2 id="Async的使用方法">3.1. Async的使用方法</h2><p>首先在application上标注<code>@EnableAsync</code>启用async</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在方法上标注<code>@Async</code>，被标注的方法即变为异步方法。在类上标注<code>@Async</code>则被标注的类中所有方法都会变为异步方法</p>
<p>建议将异步方法的返回值设为<code>void</code>或<code>Future&lt;T&gt;</code>。否则难以获取返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAsync</span><span class="params">(Object inputObj)</span></span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">useAsync</span><span class="params">(Object inputObj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;something&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">asyncClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="为什么阿里编程规范不建议使用-Async">3.2. 为什么阿里编程规范不建议使用@Async</h2><p>我们来看看Async的源码<br>@EnableAsync源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(AsyncConfigurationSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAsync &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支持用户自定义注解，扫描用户标注的@Async</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Indicate the &#x27;async&#x27; annotation type to be detected at either class</span></span><br><span class="line"><span class="comment">	 * or method level.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;By default, both Spring&#x27;s @&#123;<span class="doctag">@link</span> Async&#125; annotation and the EJB 3.1</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@code</span> <span class="doctag">@javax</span>.ejb.Asynchronous&#125; annotation will be detected.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;This attribute exists so that developers can provide their own</span></span><br><span class="line"><span class="comment">	 * custom annotation type to indicate that a method (or all methods of</span></span><br><span class="line"><span class="comment">	 * a given class) should be invoked asynchronously.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Class&lt;? extends Annotation&gt; annotation() <span class="keyword">default</span> Annotation.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标明是否需要创建CGLIB子代理</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Indicate whether subclass-based (CGLIB) proxies are to be created as opposed</span></span><br><span class="line"><span class="comment">	 * to standard Java interface-based proxies.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;&lt;strong&gt;Applicable only if the &#123;<span class="doctag">@link</span> #mode&#125; is set to &#123;<span class="doctag">@link</span> AdviceMode#PROXY&#125;&lt;/strong&gt;.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;The default is &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Note that setting this attribute to &#123;<span class="doctag">@code</span> true&#125; will affect &lt;em&gt;all&lt;/em&gt;</span></span><br><span class="line"><span class="comment">	 * Spring-managed beans requiring proxying, not just those marked with &#123;<span class="doctag">@code</span> <span class="doctag">@Async</span>&#125;.</span></span><br><span class="line"><span class="comment">	 * For example, other beans marked with Spring&#x27;s &#123;<span class="doctag">@code</span> <span class="doctag">@Transactional</span>&#125; annotation</span></span><br><span class="line"><span class="comment">	 * will be upgraded to subclass proxying at the same time. This approach has no</span></span><br><span class="line"><span class="comment">	 * negative impact in practice unless one is explicitly expecting one type of proxy</span></span><br><span class="line"><span class="comment">	 * vs. another &amp;mdash; for example, in tests.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标明异步通知将会如何实现，默认PROXY</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Indicate how async advice should be applied.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;&lt;b&gt;The default is &#123;<span class="doctag">@link</span> AdviceMode#PROXY&#125;.&lt;/b&gt;</span></span><br><span class="line"><span class="comment">	 * Please note that proxy mode allows for interception of calls through the proxy</span></span><br><span class="line"><span class="comment">	 * only. Local calls within the same class cannot get intercepted that way; an</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> Async&#125; annotation on such a method within a local call will be ignored</span></span><br><span class="line"><span class="comment">	 * since Spring&#x27;s interceptor does not even kick in for such a runtime scenario.</span></span><br><span class="line"><span class="comment">	 * For a more advanced mode of interception, consider switching this to</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> AdviceMode#ASPECTJ&#125;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">AdviceMode <span class="title">mode</span><span class="params">()</span> <span class="keyword">default</span> AdviceMode.PROXY</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标明标明异步注解bean处理器应该遵循的执行顺序，默认最低的优先级</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Indicate the order in which the &#123;<span class="doctag">@link</span> AsyncAnnotationBeanPostProcessor&#125;</span></span><br><span class="line"><span class="comment">	 * should be applied.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;The default is &#123;<span class="doctag">@link</span> Ordered#LOWEST_PRECEDENCE&#125; in order to run</span></span><br><span class="line"><span class="comment">	 * after all other post-processors, so that it can add an advisor to</span></span><br><span class="line"><span class="comment">	 * existing proxies rather than double-proxy.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> Ordered.LOWEST_PRECEDENCE</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>好，看到了<code>@Import(AsyncConfigurationSelector.class)</code>，来看看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncConfigurationSelector</span> <span class="keyword">extends</span> <span class="title">AdviceModeImportSelector</span>&lt;<span class="title">EnableAsync</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ASYNC_EXECUTION_ASPECT_CONFIGURATION_CLASS_NAME =</span><br><span class="line">			<span class="string">&quot;org.springframework.scheduling.aspectj.AspectJAsyncConfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 决定选择哪个ProxyAsyncConfiguration</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (adviceMode) &#123;</span><br><span class="line">			<span class="keyword">case</span> PROXY:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; ProxyAsyncConfiguration.class.getName() &#125;;</span><br><span class="line">			<span class="keyword">case</span> ASPECTJ:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; ASYNC_EXECUTION_ASPECT_CONFIGURATION_CLASS_NAME &#125;;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>ProxyAsyncConfiguration.class</code>继承于<code>AbstractAsyncConfiguration</code>，再看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAsyncConfiguration</span> <span class="keyword">implements</span> <span class="title">ImportAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> AnnotationAttributes enableAsync;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> Executor executor;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> AsyncUncaughtExceptionHandler exceptionHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到所有AsyncConfiguer并使用其配置</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Collect any &#123;<span class="doctag">@link</span> AsyncConfigurer&#125; beans through autowiring.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Autowired(required = false)</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setConfigurers</span><span class="params">(Collection&lt;AsyncConfigurer&gt; configurers)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (CollectionUtils.isEmpty(configurers)) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (configurers.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Only one AsyncConfigurer may exist&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		AsyncConfigurer configurer = configurers.iterator().next();</span><br><span class="line">		<span class="keyword">this</span>.executor = configurer.getAsyncExecutor();</span><br><span class="line">		<span class="keyword">this</span>.exceptionHandler = configurer.getAsyncUncaughtExceptionHandler();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么如果没有实现AsyncConfigurer，程序默认会创建什么？带着这个疑问，我们找到了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(value = &quot;spring.sleuth.async.enabled&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(Tracer.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(AsyncCustomAutoConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncDefaultAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span> <span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果找不到AsyncConfigurer的bean就执行</span></span><br><span class="line">	<span class="meta">@Configuration</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean(AsyncConfigurer.class)</span></span><br><span class="line">	<span class="meta">@ConditionalOnProperty(value = &quot;spring.sleuth.async.configurer.enabled&quot;, matchIfMissing = true)</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAsyncConfigurerSupport</span> <span class="keyword">extends</span> <span class="title">AsyncConfigurerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Autowired</span> <span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Executor <span class="title">getAsyncExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> LazyTraceExecutor(<span class="keyword">this</span>.beanFactory, <span class="keyword">new</span> SimpleAsyncTaskExecutor());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，我们知道了。如果我们没有自定义任何一个AsyncConfigurer，则程序会选择<code>SimpleAsyncTaskExecutor</code>作为默认的线程池。</p>
<p>再来看看这个默认线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> TaskExecutor&#125; implementation that fires up a new Thread for each task,</span></span><br><span class="line"><span class="comment"> * executing it asynchronously.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Supports limiting concurrent threads through the &quot;concurrencyLimit&quot;</span></span><br><span class="line"><span class="comment"> * bean property. By default, the number of concurrent threads is unlimited.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span> This implementation does not reuse threads!&lt;/b&gt; Consider a</span></span><br><span class="line"><span class="comment"> * thread-pooling TaskExecutor implementation instead, in particular for</span></span><br><span class="line"><span class="comment"> * executing a large number of short-lived tasks.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setConcurrencyLimit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> SyncTaskExecutor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.scheduling.commonj.WorkManagerTaskExecutor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleAsyncTaskExecutor</span> <span class="keyword">extends</span> <span class="title">CustomizableThreadCreator</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">AsyncListenableTaskExecutor</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>好了，我们知道了这个默认线程池的特点：</p>
<ul>
<li>每个task都创建一个新线程</li>
<li>如果不创建concurrencyLimit bean，则线程数量无上限</li>
<li>SimpleAsyncTaskExecutor不会复用线程，每次都是新创建</li>
</ul>
<p>所以，SimpleAsyncTaskExecutor其实不是真的线程池，而是一个不断生成新线程的工具，对线程的利用管理非常低下。</p>
<p>那么，如果我们只使用了<code>@EnableAsync</code>和<code>@Async</code>。那么spring就会给我们创建这个默认的<code>SimpleAsyncTaskExecutor</code>。每次进行线程异步调用，系统都会创建新线程执行任务并丢弃。好的，问题出现了：如果异步调用的线程数量不多，那么没有任何问题。如果异步调用的线程面临高并发的问题，那么就会出现大量的线程创建及占用，对系统造成大量负担。最终可能导致线上服务爆线程等问题</p>
<h2 id="安全使用方法">3.3. 安全使用方法</h2><h3 id="方式一：指定线程池">3.3.1. 方式一：指定线程池</h3><p>@Async方法可以通过传入Executor的Bean名称，指定线程池。因此我们可以通过自定义线程池，配置参数，来控制@Async方法使用的线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;Executor&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">getAsyncExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">    <span class="comment">// add thread config</span></span><br><span class="line">    executor.initialize();</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Async(&quot;Executor&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方式二：实现接口AsyncConfigurer">3.3.2. 方式二：实现接口AsyncConfigurer</h3><p>这种方法相当于配置一个全局的线程池供Async使用。所有标注@Async并且没有指定线程池的方法，都会放入这个默认的Async线程池中执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">asyncConfig</span> <span class="keyword">implements</span> <span class="title">AsyncConfigurer</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> Executor <span class="title">newExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">            <span class="comment">// add thread config</span></span><br><span class="line">            executor.initialize();</span><br><span class="line">            <span class="keyword">return</span> executor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Executor <span class="title">getAsyncExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> newExecutor();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> AsyncUncaughtExceptionHandler <span class="title">getAsyncUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java复健系列(1)：Java基础知识</title>
    <url>/2020/10/16/Java-review-1/</url>
    <content><![CDATA[<h1 id="Java基本概念">1. Java基本概念</h1><h2 id="Java-语言有哪些特点">1.1. Java 语言有哪些特点?</h2><ul>
<li>简单易学；</li>
<li>面向对象（封装，继承，多态）；</li>
<li>平台无关性（ Java 虚拟机实现平台无关性）；</li>
<li>可靠性；</li>
<li>安全性；</li>
<li>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；</li>
<li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</li>
<li>编译与解释并存；</li>
</ul>
<h2 id="关于-JVM-JDK-和-JRE">1.2. 关于 JVM JDK 和 JRE</h2><ul>
<li>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</li>
<li>JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</li>
<li>JRE 是 Java 运行时环境(Java Runtime Environment)。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</li>
</ul>
<h2 id="字节码">1.3. 字节码</h2><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
<p>源代码（java文件）-&gt;字节码（class文件）-&gt;机器码</p>
<h2 id="为什么-Java-是编译与解释共存的语言。">1.4. 为什么 Java 是编译与解释共存的语言。</h2><p>高级编程语言按照程序的执行方式分为编译型和解释型两种。简单来说，编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。比如，你想阅读一本英文名著，你可以找一个英文翻译人员帮助你阅读， 有两种选择方式，你可以先等翻译人员将全本的英文名著（也就是源码）都翻译成汉语，再去阅读，也可以让翻译人员翻译一段，你在旁边阅读一段，慢慢把书读完。</p>
<p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（*.class 文件），这种字节码必须由 Java 解释器来解释执行。因此，我们可以认为 Java 语言编译与解释并存。</p>
<p>在.class-&gt;机器码 这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</p>
<p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。</p>
<h2 id="Oracle-JDK与OpenJDK">1.5. Oracle JDK与OpenJDK</h2><ol>
<li>Oracle JDK 大概每 6 个月发一次主要版本，而 OpenJDK 版本大概每三个月发布一次。详情参见：<a href="https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence">https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence</a> 。<br>OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；</li>
<li>Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业&#x2F;商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；</li>
<li>在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；<br>Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li>
<li>Oracle JDK 根据二进制代码许可协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。</li>
</ol>
<h2 id="Java和C-区别">1.6. Java和C++区别</h2><ul>
<li>都是面向对象的语言，都支持封装、继承和多态</li>
<li>Java 不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是可以通过接口实现多继承。</li>
<li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存</li>
<li>在 C 语言中，字符串或字符数组最后都会有一个额外的字符’\0’来表示结束。但是，Java 语言中没有结束符这一概念。 这是一个值得深度思考的问题。简单来说可以视为Java万物皆对象，不需要额外的’\0’来表示结束而是通过length确定。具体原因推荐看这篇文章： <a href="https://blog.csdn.net/sszgg2006/article/details/49148189">https://blog.csdn.net/sszgg2006/article/details/49148189</a></li>
</ul>
<h2 id="Java程序的主类是什么？应用程序和Applet程序的主类区别？">1.7. Java程序的主类是什么？应用程序和Applet程序的主类区别？</h2><p>一个程序中可以有多个类，但只能有一个类是主类。在 Java 应用程序中，这个主类是指包含 main() 方法的类。而在 Java 小程序中，这个主类是一个继承自系统类 JApplet 或 Applet 的子类。应用程序的主类不一定要求是 public 类，但小程序的主类要求必须是 public 类。主类是 Java 程序执行的入口点。</p>
<h2 id="Java主程序与Applet小程序区别">1.8. Java主程序与Applet小程序区别</h2><p>简单说应用程序是从主线程启动(也就是 main() 方法)。applet 小程序没有 main() 方法，主要是嵌在浏览器页面上运行(调用init()或者run()来启动)，嵌入浏览器这点跟 flash 的小游戏类似。</p>
<h2 id="Java和javax有什么区别？">1.9. Java和javax有什么区别？</h2><p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来使用。然而随着时间的推移，javax 逐渐地扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包确实太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准 API 的一部分。<br>所以，实际上 java 和 javax 没有区别。这都是一个名字。</p>
<h1 id="Java基本类型">2. Java基本类型</h1><p>Java中基本变量类型(primitive type)占据内存空间如图所示。Java中基本变量的大小不随硬件架构变化而变化。这种不变性是Java程序更加具有可移植性的原因之一。</p>
<table>
<thead>
<tr>
<th>变量类型</th>
<th align="left">存储大小</th>
<th align="center">最小值</th>
<th align="center">最大值</th>
<th align="center">注释</th>
<th align="right">包装器类型</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td align="left">1byte</td>
<td align="center">-128</td>
<td align="center">+127</td>
<td align="center">字节</td>
<td align="right">Character</td>
</tr>
<tr>
<td>int</td>
<td align="left">4byte</td>
<td align="center">$-2^{31}$</td>
<td align="center">$+2^{31}-1$</td>
<td align="center">整形</td>
<td align="right">Integer</td>
</tr>
<tr>
<td>short</td>
<td align="left">2bytes</td>
<td align="center">$-2^{15}$</td>
<td align="center">$+2^{15}-1$</td>
<td align="center">短整形</td>
<td align="right">Short</td>
</tr>
<tr>
<td>long</td>
<td align="left">8bytes</td>
<td align="center">$-2^{63}$</td>
<td align="center">$+2^{63}-1$</td>
<td align="center">长整形</td>
<td align="right">Long</td>
</tr>
<tr>
<td>float</td>
<td align="left">4bytes</td>
<td align="center">IEEE754</td>
<td align="center">IEEE753</td>
<td align="center">单精度浮点数</td>
<td align="right">Float</td>
</tr>
<tr>
<td>double</td>
<td align="left">8bytes</td>
<td align="center">IEEE754</td>
<td align="center">IEEE754</td>
<td align="center">双精度浮点数</td>
<td align="right">Double</td>
</tr>
<tr>
<td>char</td>
<td align="left">2bytes</td>
<td align="center">Unicode 0</td>
<td align="center">Unicode $2^{16}-1$</td>
<td align="center">字符</td>
<td align="right">Character</td>
</tr>
<tr>
<td>boolean</td>
<td align="left">1bit</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">布尔值</td>
<td align="right">Boolean</td>
</tr>
</tbody></table>
<p>注意：</p>
<ol>
<li>对于boolean，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1位，但是实际中会考虑计算机高效存储因素。</li>
<li>Java 里使用 long 类型的数据一定要在数值后面加上 L，否则将作为整型解析</li>
</ol>
<h2 id="包装类（装箱与拆箱）">2.1. 包装类（装箱与拆箱）</h2><p>八种基本数据类型并不支持面向对象编程，基本类型的数据不具备“对象”的特性——不携带属性、没有方法可调用。Java为每种基本数据类型分别设计了对应的类，称之为包装类(Wrapper Classes)。每个包装类的对象可以封装一个相应的基本类型的数据，并提供了其它一些有用的方法。包装类对象一经创建，其内容（所封装的基本类型数据值）不可改变。</p>
<p>基本类型和对应的包装类可以相互装换：</p>
<ul>
<li>由基本类型向对应的包装类转换称为装箱，例如把 int 包装成 Integer 类的对象；</li>
<li>包装类向对应的基本类型转换称为拆箱，例如把 Integer 类的对象重新简化为 int。</li>
</ul>
<h3 id="实现-int-和-Integer-的相互转换">2.1.1. 实现 int 和 Integer 的相互转换</h3><p>可以通过 Integer 类的构造方法将 int 装箱，通过 Integer 类的 intValue 方法将 Integer 拆箱。</p>
<h3 id="将字符串转换为整数">2.1.2. 将字符串转换为整数</h3><p>Integer 类有一个静态的 paseInt() 方法，可以将字符串转换为整数，语法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parseInt(String s, int radix);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="将整数转换为字符串">2.1.3. 将整数转换为字符串</h3><p>Integer 类有一个静态的 toString() 方法，可以将整数转换为字符串。</p>
<h3 id="自动拆箱和装箱">2.1.4. 自动拆箱和装箱</h3><p>上面的例子都需要手动实例化一个包装类，称为手动拆箱装箱。Java 1.5(5.0) 之前必须手动拆箱装箱。</p>
<p>Java 1.5 之后可以自动拆箱装箱，也就是在进行基本数据类型和对应的包装类转换时，系统将自动进行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int m &#x3D; 500;</span><br><span class="line">        Integer obj &#x3D; m;  &#x2F;&#x2F; 自动装箱</span><br><span class="line">        int n &#x3D; obj;  &#x2F;&#x2F; 自动拆箱</span><br><span class="line">        System.out.println(&quot;n &#x3D; &quot; + n);</span><br><span class="line">      </span><br><span class="line">        Integer obj1 &#x3D; 500;</span><br><span class="line">        System.out.println(&quot;obj 等价于 obj1？&quot; + obj.equals(obj1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常量池">2.2. 常量池</h2><p>Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character创建了数值在[0,127]范围的缓存数据，Boolean 直接返回True Or False。如果超出对应范围仍然会去创建新的对象。</p>
<p>应用场景：</p>
<ul>
<li>Integer i1&#x3D;40；Java 在编译的时候会直接将代码封装成 Integer i1&#x3D;Integer.valueOf(40);，从而使用常量池中的对象。</li>
<li>Integer i1 &#x3D; new Integer(40);这种情况下会创建新的对象。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Integer i1 &#x3D; 40;</span><br><span class="line">Integer i2 &#x3D; 40;</span><br><span class="line">Integer i3 &#x3D; 0;</span><br><span class="line">Integer i4 &#x3D; new Integer(40);</span><br><span class="line">Integer i5 &#x3D; new Integer(40);</span><br><span class="line">Integer i6 &#x3D; new Integer(0);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;i1&#x3D;i2   &quot; + (i1 &#x3D;&#x3D; i2));</span><br><span class="line">System.out.println(&quot;i1&#x3D;i2+i3   &quot; + (i1 &#x3D;&#x3D; i2 + i3));</span><br><span class="line">System.out.println(&quot;i1&#x3D;i4   &quot; + (i1 &#x3D;&#x3D; i4));</span><br><span class="line">System.out.println(&quot;i4&#x3D;i5   &quot; + (i4 &#x3D;&#x3D; i5));</span><br><span class="line">System.out.println(&quot;i4&#x3D;i5+i6   &quot; + (i4 &#x3D;&#x3D; i5 + i6));   </span><br><span class="line">System.out.println(&quot;40&#x3D;i5+i6   &quot; + (40 &#x3D;&#x3D; i5 + i6));   </span><br></pre></td></tr></table></figure>
输出：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i1&#x3D;i2   true</span><br><span class="line">i1&#x3D;i2+i3   true</span><br><span class="line">i1&#x3D;i4   false</span><br><span class="line">i4&#x3D;i5   false</span><br><span class="line">i4&#x3D;i5+i6   true</span><br><span class="line">40&#x3D;i5+i6   true</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Java基本语法">3. Java基本语法</h1><h2 id="数组">3.1. 数组</h2><p>数组声明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[] a</span><br></pre></td></tr></table></figure>
<p>声明时数组没有分配空间。使用new创建数组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[] a &#x3D; new int[100]</span><br></pre></td></tr></table></figure>
<p>声明同时赋值（变长数组）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[] a &#x3D; new int[]&#123;1,3,5,7,9&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组初始化">3.1.1. 数组初始化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 静态初始化</span><br><span class="line">&#x2F;&#x2F; 静态初始化的同时就为数组元素分配空间并赋值</span><br><span class="line">int intArray[] &#x3D; &#123;1,2,3,4&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 动态初始化</span><br><span class="line">float floatArray[] &#x3D; new float[3]; &#x2F;&#x2F; 分配空间</span><br><span class="line">&#x2F;&#x2F; 赋值</span><br><span class="line">floatArray[0] &#x3D; 1.0f;</span><br><span class="line">floatArray[1] &#x3D; 132.63f;</span><br><span class="line">floatArray[2] &#x3D; 100F;</span><br></pre></td></tr></table></figure>
<h3 id="引用">3.1.2. 引用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arrayName[index]</span><br></pre></td></tr></table></figure>
<p>index从0开始。与C、C++不同，Java对数组元素要进行越界检查以保证安全性。<br>每个数组都有一个length属性来指明它的长度，例如 intArray.length 指明数组 intArray 的长度。</p>
<h3 id="数组遍历">3.1.3. 数组遍历</h3><p>经典for循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int arrayDemo[] &#x3D; &#123;1, 2, 4, 7, 9, 192, 100&#125;;</span><br><span class="line">for(int i&#x3D;0,len&#x3D;arrayDemo.length; i&lt;len; i++)&#123;</span><br><span class="line">    System.out.println(arrayDemo[i] + &quot;, &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java特例。foreach循环。每次循环自动获取下一个元素的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(arrayType varName:arrayName)&#123;</span><br><span class="line">    &#x2F;&#x2F;some code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int arrayDemo[] &#x3D; &#123;1, 2, 4, 7, 9, 192, 100&#125;;</span><br><span class="line">for(int x: arrayDemo)&#123;</span><br><span class="line">    System.out.println(x + &quot;, &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二维数组">3.1.4. 二维数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int intArray[ ][ ] &#x3D; &#123; &#123;1,2&#125;, &#123;2,3&#125;, &#123;4,5&#125; &#125;;</span><br><span class="line">int a[ ][ ] &#x3D; new int[2][3];</span><br><span class="line">a[0][0] &#x3D; 12;</span><br><span class="line">a[0][1] &#x3D; 34;</span><br><span class="line">&#x2F;&#x2F; ......</span><br><span class="line">a[1][2] &#x3D; 93;</span><br></pre></td></tr></table></figure>
<p>java中，二维数组被看做数组的数组，空间不连续分配。因此每一维大小可以不同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int intArray[ ][ ] &#x3D; &#123;&#123;1,2&#125;, &#123;2,3,4,5&#125;&#125;;</span><br><span class="line">int a[ ][ ] &#x3D; new int[2][ ];</span><br><span class="line">a[0] &#x3D; new int[3];</span><br><span class="line">a[1] &#x3D; new int[5];</span><br></pre></td></tr></table></figure>

<ul>
<li>上面讲的是静态数组。静态数组一旦被声明，它的容量就固定了，不容改变。所以在声明数组时，一定要考虑数组的最大容量，防止容量不够的现象。</li>
<li>如果想在运行程序时改变容量，就需要用到数组列表(ArrayList，也称动态数组)或向量(Vector)。</li>
<li>正是由于静态数组容量固定的缺点，实际开发中使用频率不高，被 ArrayList 或 Vector 代替，因为实际开发中经常需要向数组中添加或删除元素，而它的容量不好预估。</li>
</ul>
<h2 id="表达式">3.2. 表达式</h2><h3 id="数学表达式">3.2.1. 数学表达式</h3><table>
<thead>
<tr>
<th>名称</th>
<th>种类</th>
</tr>
</thead>
<tbody><tr>
<td>1+2</td>
<td>加法</td>
</tr>
<tr>
<td>4-3</td>
<td>减法</td>
</tr>
<tr>
<td>3*6</td>
<td>乘法</td>
</tr>
<tr>
<td>7&#x2F;2</td>
<td>除法</td>
</tr>
<tr>
<td>7%2</td>
<td>取余</td>
</tr>
</tbody></table>
<h3 id="布尔表达式">3.2.2. 布尔表达式</h3><table>
<thead>
<tr>
<th>名称</th>
<th>种类</th>
</tr>
</thead>
<tbody><tr>
<td>true&amp;&amp;flase</td>
<td>and</td>
</tr>
<tr>
<td>true|flase</td>
<td>or</td>
</tr>
<tr>
<td>!true</td>
<td>not</td>
</tr>
</tbody></table>
<h3 id="位运算">3.2.3. 位运算</h3><table>
<thead>
<tr>
<th>名称</th>
<th>种类</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>and</td>
</tr>
<tr>
<td>|</td>
<td>or</td>
</tr>
<tr>
<td>^</td>
<td>xor</td>
</tr>
<tr>
<td>~</td>
<td>not</td>
</tr>
<tr>
<td>5&lt;&lt;3</td>
<td>left shift 3 bits</td>
</tr>
<tr>
<td>6&gt;&gt;1</td>
<td>right shift 1 bits</td>
</tr>
</tbody></table>
<h2 id="控制结构">3.3. 控制结构</h2><h3 id="if">3.3.1. if</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (conditon1) &#123;</span><br><span class="line">  statements;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">else if (condition2) &#123;</span><br><span class="line">  statements;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">  statements;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="while">3.3.2. while</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (condition) &#123;</span><br><span class="line">statements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="do-while">3.3.3. do while</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">statements;</span><br><span class="line">&#125;while(condition);</span><br></pre></td></tr></table></figure>
<h3 id="for">3.3.4. for</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (initial; condition; update) &#123;</span><br><span class="line">statements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jump-out">3.3.5. jump out</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">break;</span><br><span class="line">continue;</span><br></pre></td></tr></table></figure>
<h3 id="switch">3.3.6. switch</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">switch(expression) &#123;</span><br><span class="line">case 1:</span><br><span class="line">    statements; </span><br><span class="line">    break; </span><br><span class="line">case 2:</span><br><span class="line">    statements; </span><br><span class="line">    break; </span><br><span class="line">...</span><br><span class="line">default:</span><br><span class="line">    statements; </span><br><span class="line">    break; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串">3.4. 字符串</h2><p>String类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String str &#x3D; &quot;java study&quot;</span><br></pre></td></tr></table></figure>
<p>字符串可以用’+’链接，基本数据类型与字符串’+’会自动转换为字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        String stuName &#x3D; &quot;小明&quot;;</span><br><span class="line">        int stuAge &#x3D; 17;</span><br><span class="line">        float stuScore &#x3D; 92.5f;</span><br><span class="line">       </span><br><span class="line">        String info &#x3D; stuName + &quot;的年龄是 &quot; + stuAge + &quot;，成绩是 &quot; + stuScore;</span><br><span class="line">        System.out.println(info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>String类似数组，初始化后长度不变，内容也无法改变。如果修改就会产生新字符串。<br>如下，在str后加上’world!’。程序首先产生了str1字符串，并在内存中申请了一段空间。此时要追加新的字符串是不可能的，因为字符串被初始化后，长度是固定的。如果要改变它，只有放弃原来的空间，重新申请能够容纳“Hello World!”字符串的内存空间，然后将“Hello World!”字符串放到内存中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String str &#x3D; &quot;Hello&quot;;</span><br><span class="line">str + &#x3D; &quot;World!&quot;;</span><br></pre></td></tr></table></figure>
<p>实际上，String 是java.lang包下的一个类，按照标准的面向对象的语法，其格式应该为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String stringName &#x3D; new String(&quot;string content&quot;);</span><br></pre></td></tr></table></figure>
<p>例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String url &#x3D; new String(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;);</span><br></pre></td></tr></table></figure>
<p>但是由于String特别常用，所以Java提供了一种简化的语法。</p>
<p>使用简化语法的另外一个原因是，按照标准的面向对象的语法，在内存使用上存在比较大的浪费。例如String str &#x3D; new String(“abc”);实际上创建了两个String对象，一个是”abc”对象，存储在常量空间中，一个是使用new关键字为对象str申请的空间。</p>
<h2 id="字符型常量与字符串常量的区别？">3.5. 字符型常量与字符串常量的区别？</h2><ul>
<li>形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的0个或若干个字符</li>
<li>含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)</li>
<li>占内存大小 字符常量只占 2 个字节; 字符串常量占若干个字节 (注意： char 在 Java 中占两个字节),</li>
</ul>
<h2 id="标识符和关键字？">3.6. 标识符和关键字？</h2><p>在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了标识符，简单来说，标识符就是一个名字。但是有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这种特殊的标识符就是关键字。因此，关键字是被赋予特殊含义的标识符。比如，在我们的日常生活中 ，“警察局”这个名字已经被赋予了特殊的含义，所以如果你开一家店，店的名字不能叫“警察局”，“警察局”就是我们日常生活中的关键字。</p>
<h2 id="Java常见关键字">3.7. Java常见关键字</h2><table>
<thead>
<tr>
<th>访问控制</th>
<th>private</th>
<th>protected</th>
<th>public</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>类，方法和变量修饰符</td>
<td>abstract</td>
<td>class</td>
<td>extends</td>
<td>final</td>
<td>implements</td>
<td>interface</td>
<td>native</td>
</tr>
<tr>
<td></td>
<td>new</td>
<td>static</td>
<td>strictfp</td>
<td>synchronized</td>
<td>transient</td>
<td>volatile</td>
<td></td>
</tr>
<tr>
<td>程序控制</td>
<td>break</td>
<td>continue</td>
<td>return</td>
<td>do</td>
<td>while</td>
<td>if</td>
<td>else</td>
</tr>
<tr>
<td></td>
<td>for</td>
<td>instanceof</td>
<td>switch</td>
<td>case</td>
<td>default</td>
<td></td>
<td></td>
</tr>
<tr>
<td>错误处理</td>
<td>try</td>
<td>catch</td>
<td>throw</td>
<td>throws</td>
<td>finally</td>
<td></td>
<td></td>
</tr>
<tr>
<td>包相关</td>
<td>import</td>
<td>package</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>基本类型</td>
<td>boolean</td>
<td>byte</td>
<td>char</td>
<td>double</td>
<td>float</td>
<td>int</td>
<td>long</td>
</tr>
<tr>
<td></td>
<td>short</td>
<td>null</td>
<td>true</td>
<td>false</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>变量引用</td>
<td>super</td>
<td>this</td>
<td>void</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>保留字</td>
<td>goto</td>
<td>const</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="和–">3.8. ++和–</h2><p>自增运算符（++)和自减运算符（–）。++和–运算符可以放在变量之前，也可以放在变量之后，当运算符放在变量之前时(前缀)，先自增&#x2F;减，再赋值；当运算符放在变量之后时(后缀)，先赋值，再自增&#x2F;减。例如，当 b &#x3D; ++a 时，先自增（自己增加 1），再赋值（赋值给 b）；当 b &#x3D; a++ 时，先赋值(赋值给 b)，再自增（自己增加 1）。也就是，++a 输出的是 a+1 的值，a++输出的是 a 值。符号在前就先加&#x2F;减，符号在后就后加&#x2F;减。</p>
<h2 id="continue、break、和return的区别是什么？">3.9. continue、break、和return的区别是什么？</h2><p>在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：</p>
<ol>
<li>continue ：指跳出当前的这一次循环，继续下一次循环。</li>
<li>break ：指跳出整个循环体，继续执行循环下面的语句。</li>
<li>return 用于跳出所在方法，结束该方法的运行。</li>
</ol>
<p>return 一般有两种用法：</p>
<ol>
<li>return; ：直接使用 return 结束方法执行，用于没有返回值函数的方法</li>
<li>return value; ：return 一个特定值，用于有返回值函数的方法</li>
</ol>
<h2 id="Java泛型">3.10. Java泛型</h2><p>泛型(generics)的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<p>Java的泛型是伪泛型，这是因为Java在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。如在代码中定义List<object>和List<string>等类型，在编译后都会变成List，JVM看到的只是List，而由泛型附加的类型信息对JVM是看不到的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法在运行时刻出现的类型转换异常的情况，类型擦除也是Java的泛型与C++模板机制实现方式之间的重要区别。 更多关于类型擦除的问题，可以查看这篇文章：<a href="https://www.cnblogs.com/wuqinglong/p/9456193.html">《Java泛型类型擦除以及类型擦除带来的问题</a>。</string></object></p>
<p>泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。</p>
<h3 id="1-泛型类">3.10.1. 1. 泛型类</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span><br><span class="line">&#x2F;&#x2F;在实例化泛型类时，必须指定T的具体类型</span><br><span class="line">public class Generic&lt;T&gt;&#123; </span><br><span class="line"></span><br><span class="line">    private T key;</span><br><span class="line"></span><br><span class="line">    public Generic(T key) &#123; </span><br><span class="line">        this.key &#x3D; key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getKey()&#123; </span><br><span class="line">        return key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Generic&lt;Integer&gt; genericInteger &#x3D; new Generic&lt;Integer&gt;(123456);</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="2-泛型接口">3.10.2. 2. 泛型接口</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Generator&lt;T&gt; &#123;</span><br><span class="line">    public T method();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
实现泛型接口，不指定类型：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class GeneratorImpl&lt;T&gt; implements Generator&lt;T&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public T method() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
实现泛型接口，指定类型：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class GeneratorImpl&lt;T&gt; implements Generator&lt;String&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String method() &#123;</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="3-泛型方法">3.10.3. 3. 泛型方法</h3>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static &lt; E &gt; void printArray( E[] inputArray )&#123;         </span><br><span class="line">     for ( E element : inputArray )&#123;        </span><br><span class="line">        System.out.printf( &quot;%s &quot;, element );</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常用的通配符为： T，E，K，V，？</p>
<ul>
<li>？ 表示不确定的 java 类型</li>
<li>T (type) 表示具体的一个java类型</li>
<li>K V (key value) 分别代表java键值中的Key Value</li>
<li>E (element) 代表Element</li>
</ul>
<h2 id="，equals与hashCode">3.11. &#x3D;&#x3D;，equals与hashCode</h2><h3 id="1">3.11.1. 1.&#x3D;&#x3D;</h3><p>它的作用是判断两个对象的地址是不是相等。即判断两个对象是不是同一个对象。</p>
<ul>
<li>若操作数的类型是基本数据类型，则该关系操作符判断的是左右两边操作数的“值”是否相等</li>
<li>若操作数的类型是引用数据类型，则该关系操作符判断的是左右两边操作数的内存地址是否相同。也就是说，若此时返回true,则该操作符作用的一定是同一个对象。</li>
</ul>
<h3 id="2-equals">3.11.2. 2.equals()</h3><p>它的作用也是判断两个对象是否相等。equals()方法存在于Object类中，而Object类是所有类的直接或间接父类。因此所有类都可以调用equals()来判断。它不能用于比较基本数据类型的变量，因为基本数据类型不是类。</p>
<p>Object类中的equals()方法如下所示。在Object类中，equals方法是用来比较两个对象的引用是否相等，即是否指向同一个对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">     return (this &#x3D;&#x3D; obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>equals() 方法存在两种使用情况：</p>
<ul>
<li>情况 1：类没有覆盖 equals()方法。则通过 equals()比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象。使用的默认是 Object类equals()方法。</li>
<li>情况 2：类覆盖了 equals()方法。一般，我们都覆盖 equals()方法来两个对象的内容相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。</li>
</ul>
<p>对于内置类的equals方法，Java内部实现分为三个步骤：</p>
<ol>
<li>先比较引用是否相同(是否为同一对象),</li>
<li>再判断类型是否一致（是否为同一类型）,</li>
<li>最后比较内容是否一致</li>
</ol>
<p>Java 中所有内置的类的 equals 方法的实现步骤均是如此，特别是诸如 Integer，Double 等包装器类。例如String类的equals就被重载过，具体实现为对于string中的每个char一一比较来比较两个字符串是否相等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">    if (this &#x3D;&#x3D; anObject) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (anObject instanceof String) &#123;</span><br><span class="line">        String anotherString &#x3D; (String) anObject;</span><br><span class="line">        int n &#x3D; value.length;</span><br><span class="line">        if (n &#x3D;&#x3D; anotherString.value.length) &#123;</span><br><span class="line">            char v1[] &#x3D; value;</span><br><span class="line">            char v2[] &#x3D; anotherString.value;</span><br><span class="line">            int i &#x3D; 0;</span><br><span class="line">            while (n-- !&#x3D; 0) &#123;</span><br><span class="line">                if (v1[i] !&#x3D; v2[i])</span><br><span class="line">                        return false;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class test1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String a &#x3D; new String(&quot;ab&quot;); &#x2F;&#x2F; a 为一个引用</span><br><span class="line">        String b &#x3D; new String(&quot;ab&quot;); &#x2F;&#x2F; b为另一个引用,对象的内容一样</span><br><span class="line">        String aa &#x3D; &quot;ab&quot;; &#x2F;&#x2F; 放在常量池中</span><br><span class="line">        String bb &#x3D; &quot;ab&quot;; &#x2F;&#x2F; 从常量池中查找</span><br><span class="line">        if (aa &#x3D;&#x3D; bb) &#x2F;&#x2F; true</span><br><span class="line">            System.out.println(&quot;aa&#x3D;&#x3D;bb&quot;);</span><br><span class="line">        if (a &#x3D;&#x3D; b) &#x2F;&#x2F; false，非同一对象</span><br><span class="line">            System.out.println(&quot;a&#x3D;&#x3D;b&quot;);</span><br><span class="line">        if (a.equals(b)) &#x2F;&#x2F; true</span><br><span class="line">            System.out.println(&quot;aEQb&quot;);</span><br><span class="line">        if (42 &#x3D;&#x3D; 42.0) &#123; &#x2F;&#x2F; true</span><br><span class="line">            System.out.println(&quot;true&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>equals重写规则</p>
<ul>
<li>对称性： 如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true” ；</li>
<li>自反性： x.equals(x)必须返回是“true” ；</li>
<li>类推性： 如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true” ；</li>
<li>一致性： 如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true” ；</li>
<li>对称性： 如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。</li>
<li>任何情况下，x.equals(null)【应使用关系比较符 &#x3D;&#x3D;】，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”</li>
</ul>
<p>equals本意是比较两个对象的 content 是否相同。必要的时候，我们需要重写该方法，避免违背本意，且要遵循上述原则</p>
<h3 id="3-hashCode">3.11.3. 3.hashCode()</h3><h4 id="hashCode是什么">3.11.3.1. hashCode是什么</h4><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。</p>
<p>一般来讲，equals 这个方法是给用户调用的，而 hashcode 方法一般用户不会去调用。</p>
<h4 id="为什么要有hashCode">3.11.3.2. 为什么要有hashCode</h4><p>HashCode来源于Hash表。当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals() 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p>
<h3 id="为什么重写-equals-时必须重写-hashCode-方法？">3.11.4. 为什么重写 equals 时必须重写 hashCode 方法？</h3><p>当一个对象作为HashSet对象元素时，HashSet需要通过hashCode与equals来判断，并且是先调用hashCode再调用equals。如果一个对象的equals需要重写，那么他的hashCode也必定需要重写来适应。否则该class的两个对象永远不会相等，即使他们指向相同的数据。</p>
<p>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖。</p>
<h3 id="为什么两个对象有相同的-hashcode-值，它们也不一定是相等的？">3.11.5. 为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？</h3><p>因为在哈希表中 hashCode() 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode。</p>
<p>我们刚刚也提到了 HashSet,如果 HashSet 在对比的时候，同样的 hashcode 有多个对象，它会使用 equals() 来判断是否真的相同。也就是说 hashcode 只是用来缩小查找成本。</p>
<h2 id="正确使用equals">3.12. 正确使用equals</h2><p>Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。</p>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常</span><br><span class="line">String str &#x3D; null;</span><br><span class="line">if (str.equals(&quot;SnailClimb&quot;)) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的程序会抛出空指针异常，但是我们把第二行的条件判断语句改为下面这样的话，就不会抛出空指针异常，else 语句块得到执行。：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;SnailClimb&quot;.equals(str);&#x2F;&#x2F; false </span><br></pre></td></tr></table></figure>

<p>不过更推荐使用 java.util.Objects#equals(JDK7 引入的工具类)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Objects.equals(null,&quot;SnailClimb&quot;);&#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>原因见java.util.Objects#equals的源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static boolean equals(Object a, Object b) &#123;</span><br><span class="line">    &#x2F;&#x2F; 可以避免空指针异常。如果a&#x3D;&#x3D;null的话此时a.equals(b)就不会得到执行，避免出现空指针异常。</span><br><span class="line">    return (a &#x3D;&#x3D; b) || (a !&#x3D; null &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="包装类的比较">3.13. 包装类的比较</h2><p>所有整型包装类对象值的比较必须使用equals方法。</p>
<p>先看下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Integer x &#x3D; 3;</span><br><span class="line">Integer y &#x3D; 3;</span><br><span class="line">System.out.println(x &#x3D;&#x3D; y);&#x2F;&#x2F; true</span><br><span class="line">Integer a &#x3D; new Integer(3);</span><br><span class="line">Integer b &#x3D; new Integer(3);</span><br><span class="line">System.out.println(a &#x3D;&#x3D; b);&#x2F;&#x2F;false</span><br><span class="line">System.out.println(a.equals(b));&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<p>当使用自动装箱方式创建一个Integer对象时，当数值在-128 ~127时，会将创建的 Integer 对象缓存起来，当下次再出现该数值时，直接从缓存中取出对应的Integer对象。所以上述代码中，x和y引用的是相同的Integer对象。</p>
<h1 id="方法">4. 方法</h1><h2 id="什么是方法的返回值-返回值在类的方法里的作用是什么">4.1. 什么是方法的返回值?返回值在类的方法里的作用是什么?</h2><p>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用是接收出结果，使得它可以用于其他的操作！</p>
<h2 id="为什么-Java-中只有值传递？">4.2. 为什么 Java 中只有值传递？</h2><p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 它用来描述各种程序设计语言（不只是 Java)中方法参数传递方式。</p>
<p>Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</p>
<p>很多程序设计语言（特别是，C++和 Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员认为 Java 程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。理由很简单，方法得到的是对象引用的拷贝，也就是将参数对象的引用赋值到了拷贝对象中，对象引用及拷贝对象同时引用同一个对象。</p>
<p>因此</p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li>
<li>一个方法可以改变一个对象参数的状态。</li>
<li>一个方法不能让对象参数引用一个新的对象。</li>
</ul>
<h2 id="重载和重写的区别">4.3. 重载和重写的区别</h2><p>重载（Overloading）就是同样的一个方法能够根据输入数据的不同，做出不同的处理。发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p>
<p>重写（Overwrite）就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p>
<ul>
<li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>
<li>如果父类方法访问修饰符为 private&#x2F;final&#x2F;static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li>
<li>构造方法无法被重写</li>
</ul>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载方法</th>
<th>重写方法</th>
</tr>
</thead>
<tbody><tr>
<td>发生范围</td>
<td>同一个类</td>
<td>子类</td>
</tr>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可修改</td>
<td>子类方法返回值类型应比父类方法返回值类型更小或相等</td>
</tr>
<tr>
<td>异常</td>
<td>可修改</td>
<td>子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>可修改</td>
<td>一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td>发生阶段</td>
<td>编译期</td>
<td>运行期</td>
</tr>
</tbody></table>
<h2 id="深拷贝和浅拷贝">4.4. 深拷贝和浅拷贝</h2><ul>
<li>浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</li>
<li>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
</search>
